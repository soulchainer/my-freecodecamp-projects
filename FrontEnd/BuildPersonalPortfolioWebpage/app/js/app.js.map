{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/leaflet/dist/leaflet-src.js","app.js","node_modules/vivus/dist/vivus.js","src/js/app.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","window","document","undefined","oldL","L","version","define","amd","noConflict","this","Util","extend","dest","j","len","src","sources","Array","prototype","slice","arguments","hasOwnProperty","bind","fn","obj","args","apply","stamp","lastId","key","invokeEach","method","context","concat","limitExecByInterval","time","lock","execOnUnlock","wrapperFn","setTimeout","falseFn","formatNum","num","digits","pow","Math","round","trim","str","replace","splitWords","split","setOptions","options","getParamString","existingUrl","uppercase","params","push","encodeURIComponent","toUpperCase","indexOf","join","template","data","value","isArray","Object","toString","emptyImageUrl","getPrefixed","name","prefixes","timeoutDefer","Date","timeToCall","max","lastTime","requestFn","requestAnimationFrame","cancelFn","cancelAnimationFrame","id","clearTimeout","requestAnimFrame","immediate","element","cancelAnimFrame","Class","props","NewClass","initialize","_initHooks","callInitHooks","F","proto","constructor","statics","includes","parent","__super__","_initHooksCalled","include","mergeOptions","addInitHook","init","eventsKey","Mixin","Events","addEventListener","types","event","type","indexKey","indexLenKey","typeIndex","events","contextId","action","hasEventListeners","removeEventListener","clearAllEventListeners","listeners","removed","splice","fireEvent","target","addOneTimeEventListener","handler","on","off","once","fire","ie","ielt9","ua","navigator","userAgent","toLowerCase","webkit","chrome","phantomjs","android","android23","search","gecko","mobile","orientation","msPointer","PointerEvent","MSPointerEvent","pointer","pointerEnabled","retina","devicePixelRatio","matchMedia","matches","doc","documentElement","ie3d","style","webkit3d","WebKitCSSMatrix","gecko3d","opera3d","any3d","L_DISABLE_3D","touch","L_NO_TOUCH","DocumentTouch","Browser","opera","mobileWebkit","mobileWebkit3d","mobileOpera","Point","x","y","clone","add","point","_add","subtract","_subtract","divideBy","_divideBy","multiplyBy","_multiplyBy","_round","floor","_floor","distanceTo","sqrt","equals","contains","abs","Bounds","b","points","min","getCenter","getBottomLeft","getTopRight","getSize","bounds","intersects","min2","max2","xIntersects","yIntersects","isValid","Transformation","c","d","_a","_b","_c","_d","transform","scale","_transform","untransform","DomUtil","get","getElementById","getStyle","el","currentStyle","defaultView","css","getComputedStyle","getViewportOffset","pos","top","left","docBody","body","docEl","offsetTop","offsetLeft","parseInt","offsetParent","scrollTop","scrollLeft","width","maxWidth","getBoundingClientRect","clientLeft","parentNode","documentIsLtr","_docIsLtrCached","_docIsLtr","create","tagName","className","container","createElement","appendChild","hasClass","classList","_getClass","RegExp","test","addClass","classes","_setClass","removeClass","remove","baseVal","setOpacity","opacity","filter","filterName","filters","item","Enabled","Opacity","testProp","getTranslateString","is3d","open","close","getScaleString","origin","preTranslateStr","scaleStr","setPosition","disable3D","_leaflet_pos","TRANSFORM","getPosition","TRANSITION","TRANSITION_END","disableTextSelection","DomEvent","preventDefault","enableTextSelection","userSelectProperty","_userSelect","disableImageDrag","enableImageDrag","LatLng","lat","lng","alt","parseFloat","isNaN","DEG_TO_RAD","PI","RAD_TO_DEG","MAX_MARGIN","latLng","margin","precision","other","R","d2r","dLat","dLon","lat1","lat2","sin1","sin","sin2","cos","atan2","wrap","lon","LatLngBounds","southWest","northEast","latlngs","latLngBounds","_southWest","_northEast","pad","bufferRatio","sw","ne","heightBuffer","widthBuffer","getSouthWest","getNorthEast","getNorthWest","getNorth","getWest","getSouthEast","getSouth","getEast","sw2","ne2","latIntersects","lngIntersects","toBBoxString","Projection","SphericalMercator","MAX_LATITUDE","project","latlng","log","tan","unproject","atan","exp","LonLat","CRS","latLngToPoint","zoom","projectedPoint","projection","transformation","pointToLatLng","untransformedPoint","Simple","EPSG3857","earthRadius","EPSG900913","EPSG4326","Map","crs","fadeAnimation","trackResize","markerZoomAnimation","_initContainer","_initLayout","_onResize","_initEvents","maxBounds","setMaxBounds","center","setView","reset","_handlers","_layers","_zoomBoundLayers","_tileLayersNum","_addLayers","layers","getZoom","_resetView","_limitZoom","setZoom","_loaded","_zoom","zoomIn","delta","zoomOut","setZoomAround","getZoomScale","viewHalf","containerPoint","latLngToContainerPoint","centerOffset","newCenter","containerPointToLatLng","fitBounds","getBounds","paddingTL","paddingTopLeft","padding","paddingBR","paddingBottomRight","getBoundsZoom","maxZoom","paddingOffset","swPoint","nePoint","fitWorld","panTo","pan","panBy","offset","_rawPanBy","_panInsideMaxBounds","panInsideBounds","_limitCenter","addLayer","layer","minZoom","_updateZoomLevels","zoomAnimation","TileLayer","_tileLayersToLoad","_onTileLayerLoad","_layerAdd","removeLayer","onRemove","hasLayer","eachLayer","invalidateSize","animate","oldSize","_sizeChanged","_initialCenter","newSize","oldCenter","debounceMoveend","_sizeTimer","addHandler","HandlerClass","enable","_container","_leaflet","_clearPanes","_clearControlPos","_clearHandlers","_checkIfLoaded","_moved","layerPointToLatLng","_getCenterLayerPoint","getPixelBounds","getMinZoom","_layersMinZoom","getMaxZoom","_layersMaxZoom","Infinity","inside","boundsSize","size","nw","se","zoomNotFound","_size","clientWidth","clientHeight","topLeftPoint","_getTopLeftPoint","getPixelOrigin","_initialTopLeftPoint","getPanes","_panes","getContainer","toZoom","getScaleZoom","LN2","latLngToLayerPoint","containerPointToLayerPoint","_getMapPanePos","layerPointToContainerPoint","layerPoint","mouseEventToContainerPoint","getMousePosition","mouseEventToLayerPoint","mouseEventToLatLng","position","_initPanes","_initControlPos","panes","_mapPane","mapPane","_createPane","_tilePane","tilePane","objectsPane","shadowPane","overlayPane","markerPane","popupPane","zoomHide","removeChild","preserveMapOffset","afterZoomAnim","zoomChanged","_getNewTopLeftPoint","loading","hard","_getZoomSpan","oldZoomSpan","onOff","_onMouseClick","_fireMouseEvent","_resizeRequest","_simulated","dragging","moved","boxZoom","_skipped","originalEvent","disable","whenReady","callback","onAdd","_latLngToNewLayerPoint","newZoom","topLeft","_getCenterOffset","centerPoint","viewBounds","_getBoundsOffset","_limitOffset","newBounds","pxBounds","nwOffset","seOffset","dx","_rebound","dy","right","ceil","map","Mercator","R_MINOR","R_MAJOR","r2","tmp","eccent","con","ts","phi","numIter","tol","dphi","EPSG3395","m","tileSize","subdomains","errorTileUrl","attribution","zoomOffset","unloadInvisibleTiles","updateWhenIdle","url","detectRetina","_url","_map","_animated","_zoomAnimated","viewreset","_reset","moveend","_update","zoomanim","_animateZoom","zoomend","_endZoomAnim","_limitedUpdate","addTo","bringToFront","pane","_setAutoZIndex","bringToBack","insertBefore","firstChild","getAttribution","_updateOpacity","setZIndex","zIndex","_updateZIndex","setUrl","noRedraw","redraw","compare","children","edgeZIndex","isFinite","tiles","_tiles","_bgBuffer","_tileContainer","tile","_tilesToLoad","reuseTiles","_unusedTiles","innerHTML","_clearBgBuffer","_getTileSize","zoomN","maxNativeZoom","tileBounds","_addTilesFromCenterOut","_removeOtherTiles","queue","_tileShouldBeLoaded","tilesToLoad","sort","fragment","createDocumentFragment","_addTile","tilePoint","continuousWorld","limit","_getWrapTileNum","noWrap","nwPoint","sePoint","kArr","_removeTile","onload","tilePos","_getTilePos","_getTile","_loadTile","_getZoomForUrl","zoomReverse","getTileUrl","_getSubdomain","z","_adjustTilePoint","tms","index","pop","_resetTile","_createTile","height","galleryimg","onselectstart","onmousemove","WebkitBackfaceVisibility","_layer","_tileOnLoad","onerror","_tileOnError","_tileLoaded","_clearBgBufferTimer","newUrl","tileLayer","WMS","defaultWmsParams","service","request","styles","format","transparent","wmsParams","_crs","_wmsVersion","projectionKey","bbox","setParams","wms","Canvas","async","_redrawTile","drawTile","_tilePoint","tileDrawn","canvas","ImageOverlay","_bounds","_image","_initImage","_onImageLoad","image","imageOverlay","Icon","createIcon","oldIcon","_createIcon","createShadow","_getIconUrl","img","_createImg","_setIconStyles","anchor","shadowAnchor","iconAnchor","marginLeft","marginTop","icon","Default","iconSize","popupAnchor","shadowSize","path","imagePath","scripts","getElementsByTagName","leafletRe","match","Marker","title","clickable","draggable","keyboard","zIndexOffset","riseOnHover","riseOffset","_latlng","update","_initIcon","_removeIcon","_removeShadow","getLatLng","setLatLng","setZIndexOffset","setIcon","_popup","bindPopup","_icon","_setPos","animation","classToAdd","addIcon","tabIndex","_initInteraction","_bringToFront","_resetZIndex","newShadow","_shadow","addShadow","_zIndex","opt","_onKeyPress","Handler","MarkerDrag","wasDragged","stopPropagation","_enabled","keyCode","marker","DivIcon","html","div","bgPos","backgroundPosition","divIcon","closePopupOnClick","Popup","minWidth","autoPan","closeButton","autoPanPadding","keepInView","source","_source","_isOpen","animFade","_getEvents","popup","openOn","openPopup","offsetWidth","_updatePosition","_adjustPan","getContent","_content","setContent","content","visibility","_updateContent","_updateLayout","_zoomAnimation","closeOnClick","preclick","_close","closePopup","prefix","containerClass","_closeButton","href","disableClickPropagation","_onCloseButtonClick","wrapper","_wrapper","_contentNode","disableScrollPropagation","_tipContainer","_tip","hasChildNodes","whiteSpace","offsetHeight","maxHeight","scrolledClass","_containerWidth","animated","_containerBottom","_containerLeft","bottom","containerHeight","containerWidth","layerPos","containerPos","autoPanPaddingTopLeft","autoPanPaddingBottomRight","stop","togglePopup","_popupHandlersAdded","_movePopup","setPopupContent","unbindPopup","getPopup","LayerGroup","getLayerId","clearLayers","invoke","methodName","getLayer","getLayers","layerGroup","FeatureGroup","EVENTS","_propagateEvent","_popupContent","_popupOptions","setStyle","featureGroup","Path","CLIP_PADDING","outerWidth","outerHeight","stroke","color","dashArray","lineCap","lineJoin","weight","fill","fillColor","fillOpacity","_initElements","projectLatlngs","_updatePath","_pathRoot","vml","_stroke","_fill","_updateStyle","_updatePathViewport","p","panePos","_pathViewport","SVG_NS","svg","createElementNS","createSVGRect","SVG","root","lastChild","first","getPathString","_createElement","_initPathRoot","_initPath","_initStyle","_path","setAttribute","pointerEvents","removeAttribute","_animatePathZoom","_endPathZoom","_updateSvgViewport","_pathZooming","vp","_openPopup","_latlngs","shape","behavior","adj","VML","namespaces","coordsize","stroked","filled","endcap","dashStyle","joinstyle","display","v","getContext","L_PREFER_CANVAS","CANVAS","_requestUpdate","_onClick","_onMouseMove","_updateRequest","_fireMapMoveEnd","_ctx","_canvasCtx","lineWidth","strokeStyle","fillStyle","_drawPath","len2","drawMethod","beginPath","_parts","Polygon","closePath","_checkIfEmpty","ctx","save","globalAlpha","fillRule","restore","_containsPoint","_animatingZoom","cursor","_mouseInside","_updateCanvasViewport","translate","LineUtil","simplify","tolerance","sqTolerance","_reducePoints","_simplifyDP","pointToSegmentDistance","p1","p2","_sqClosestPointOnSegment","closestPointOnSegment","ArrayConstructor","Uint8Array","markers","_simplifyDPStep","newPoints","last","sqDist","maxSqDist","reducedPoints","prev","_sqDist","clipSegment","useLastCode","codeOut","newCode","codeA","_lastCode","_getBitCode","codeB","_getEdgeIntersection","dot","Polyline","_convertLatLngs","smoothFactor","noClip","_originalPoints","_getPathPartStr","getLatLngs","setLatLngs","addLatLng","spliceLatLngs","closestLayerPoint","minDistance","parts","minPoint","jLen","distance","overwrite","_clipPoints","k","segment","lu","_simplifyPoints","polyline","PolyUtil","clipPolygon","clippedPoints","edge","edges","_code","_initWithHoles","hole","_holes","_holePoints","newParts","clipped","polygon","createMulti","Klass","_options","MultiPolyline","MultiPolygon","multiPolyline","multiPolygon","Rectangle","_boundsToLatLngs","setBounds","rectangle","Circle","radius","_mRadius","setRadius","lngRadius","_getLngRadius","pointLeft","_point","_radius","latRadius","getRadius","_getLatRadius","circle","CircleMarker","circleMarker","closed","dist","part","w","arc","w2","GeoJSON","geojson","addData","feature","features","geometries","geometry","coordinates","geometryToLayer","pointToLayer","coordsToLatLng","asFeature","defaultOptions","resetStyle","onEachFeature","_setLayerStyle","vectorOptions","coords","coordsToLatLngs","properties","levelsDeep","latLngToCoords","latLngsToCoords","latLngs","getFeature","newGeometry","geoJSON","PointToGeoJSON","toGeoJSON","multiToGeoJSON","json","jsons","isGeometryCollection","geoJson","addListener","originalHandler","newType","_getEvent","addPointerListener","addDoubleTapListener","_checkMouse","_filterClick","attachEvent","removeListener","removePointerListener","removeDoubleTapListener","detachEvent","cancelBubble","Draggable","START","_fakeStop","returnValue","clientX","clientY","rect","clientTop","getWheelDelta","wheelDelta","detail","_skipEvents","skipped","related","relatedTarget","err","caller","callee","Event","timeStamp","elapsed","_lastClick","_simulatedClick","END","mousedown","touchstart","pointerdown","MSPointerDown","MOVE","dragStartTarget","_element","_dragStartTarget","_onDown","shiftKey","which","button","touches","_disabled","_moving","_startPoint","_startPos","_newPos","_onMove","_onUp","newPoint","_lastTarget","srcElement","_animRequest","addHooks","removeHooks","enabled","inertia","inertiaDeceleration","inertiaMaxSpeed","inertiaThreshold","easeLinearity","worldCopyJump","Drag","_draggable","dragstart","_onDragStart","drag","_onDrag","dragend","_onDragEnd","_onPreDrag","_onViewReset","_panAnim","_positions","_times","_lastTime","_lastPos","shift","pxCenter","pxWorldCenter","_initialWorldOffset","_worldWidth","worldWidth","halfWidth","newX1","newX2","newX","delay","noInertia","direction","duration","ease","speedVector","speed","limitedSpeed","limitedSpeedVector","decelerationDuration","noMoveStart","doubleClickZoom","DoubleClickZoom","_onDoubleClick","scrollWheelZoom","ScrollWheelZoom","_onWheelScroll","_delta","_lastMousePos","_startTime","_timer","_performZoom","_touchstart","_touchend","onTouchStart","count","trackedTouches","pointerId","now","doubleTap","onTouchEnd","idx","prop","newTouch","pre","touchend","endElement","POINTER_CANCEL","POINTER_DOWN","POINTER_MOVE","POINTER_UP","_pointers","_pointerDocumentListener","addPointerListenerStart","addPointerListenerEnd","addPointerListenerMove","pointers","cb","pointerType","MSPOINTER_TYPE_MOUSE","alreadyInArray","changedTouches","internalCb","buttons","touchZoom","bounceAtZoomLimits","TouchZoom","_onTouchStart","_zooming","viewCenter","_startCenter","_startDist","_centerOffset","_onTouchMove","_onTouchEnd","_scale","_updateOnMove","_getScaleOrigin","oldZoom","floatZoomDelta","roundZoomDelta","tap","tapTolerance","Tap","_fireClick","_holdTimeout","_isTapValid","_simulateEvent","simulatedEvent","createEvent","initMouseEvent","screenX","screenY","dispatchEvent","BoxZoom","_pane","_onMouseDown","_startLayerPoint","_onMouseUp","_onKeyDown","_box","startPoint","box","newPos","_finish","boxZoomBounds","keyboardPanOffset","keyboardZoomOffset","Keyboard","keyCodes","down","up","_setPanOffset","_setZoomOffset","_onFocus","_onBlur","_addHooks","_removeHooks","_focused","focus","scrollTo","keys","_panKeys","codes","_zoomKeys","_inProgress","_marker","shadow","iconPos","Control","removeControl","addControl","corner","_controlCorners","removeFrom","_refocusOnMap","control","createCorner","vSide","hSide","corners","_controlContainer","Zoom","zoomInText","zoomInTitle","zoomOutText","zoomOutTitle","zoomName","_zoomInButton","_createButton","_zoomIn","_zoomOutButton","_zoomOut","_updateDisabled","link","zoomControl","Attribution","_attributions","addAttribution","_onLayerAdd","_onLayerRemove","setPrefix","text","removeAttribution","attribs","prefixAndAttribs","attributionControl","Scale","metric","imperial","_addScales","_mScale","_iScale","centerLat","halfWorldMeters","maxMeters","_updateScales","_updateMetric","_updateImperial","meters","_getRoundNum","_getScaleWidth","maxMiles","miles","feet","maxFeet","ratio","pow10","Layers","collapsed","autoZIndex","baseLayers","overlays","_lastZIndex","_handlingClick","_addLayer","_onLayerChange","addBaseLayer","addOverlay","form","_form","_expand","_collapse","_layersLink","_onInputClick","_baseLayersList","_separator","_overlaysList","overlay","baseLayersPresent","overlaysPresent","_addItem","_createRadioElement","checked","radioHtml","radioFragment","input","label","defaultChecked","layerId","inputs","inputsLen","PosAnimation","run","_el","_onTransitionEnd","_stepTimer","setInterval","_onStep","_getPos","stepPos","_transformRe","clearInterval","_tryAnimatedZoom","_tryAnimatedPan","step","_onPanTransitionStep","end","_onPanTransitionEnd","_duration","_easeOutPower","_offset","_animate","_step","_complete","_animId","_runFrame","_easeOut","progress","zoomAnimationThreshold","_catchTransitionEnd","propertyName","_onZoomTransitionEnd","_nothingToAnimate","getElementsByClassName","backwards","forTouchZoom","_animateToCenter","_animateToZoom","_animating","_prepareBgBuffer","bg","initialTransform","front","bgLoaded","_getLoadedTilesPercentage","frontLoaded","_stopLoadingImages","complete","_defaultLocateOptions","watch","timeout","maximumAge","enableHighAccuracy","locate","_locateOptions","geolocation","_handleGeolocationError","message","onResponse","_handleGeolocationResponse","onError","_locationWatchId","watchPosition","getCurrentPosition","stopLocate","clearWatch","error","latitude","longitude","latAccuracy","accuracy","lngAccuracy","timestamp",2,"Pathformer","String","SVGElement","nodeName","scan","Vivus","isReady","setElement","setCallback","TYPES","ATTR_WATCH","pathData","pathDom","elements","querySelectorAll","parseAttr","attributes","pathMaker","replaceChild","lineToPath","newElement","x1","y1","x2","y2","rectToPath","polylineToPath","formattedPoints","polygonToPath","ellipseToPath","startX","cx","rx","startY","cy","endX","endY","ry","circleToPath","attr","pathTag","output","parsePositiveInt","LINEAR","EASE","EASE_OUT","EASE_IN","EASE_OUT_BOUNCE","base","rate","rateR","parentEl","file","objElm","SVGSVGElement","HTMLObjectElement","onLoad","self","contentDocument","querySelector","getAttribute","allowedTypes","allowedStarts","start","isIE","dashGap","forceRender","selfDestroy","onReady","frameLength","currentFrame","delayUnit","handle","ignoreInvisible","animTimingFunction","pathTimingFunction","Function","mapping","paths","pAttrs","pathObj","totalLength","lengthMeter","timePoint","isInvisible","getTotalLength","console","warn","strokeDasharray","strokeDashoffset","renderPath","startAt","drawer","trace","destroy","newPath","cloneNode","starter","play","listener","isInViewport","getStatus","setFrameProgress","finish","ignoreAttr","h","scrolled","scrollY","viewed","getViewportH","elBCR","elHeight","elTop","elBottom","docElem","client","inner","innerHeight","pageYOffset","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","defaultValue",3,"smoothScroll","elem","btns","to","from","getTime","timer","btn-home","btn-about","btn-projects","btn-contact","toggleFoldedMenu","folded","menuMobileContainer","greeting","accessToken","contactWays","contactForm","insertAdjacentHTML","mobilemenu","leaflet","vivus"],"mappings":"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","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.7';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n\twindow.L = oldL;\r\n\treturn this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, j, len, src;\r\n\r\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\tsrc = sources[j] || {};\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t};\r\n\t},\r\n\r\n\tstamp: (function () {\r\n\t\tvar lastId = 0,\r\n\t\t    key = '_leaflet_id';\r\n\t\treturn function (obj) {\r\n\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\treturn obj[key];\r\n\t\t};\r\n\t}()),\r\n\r\n\tinvokeEach: function (obj, method, context) {\r\n\t\tvar i, args;\r\n\r\n\t\tif (typeof obj === 'object') {\r\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\r\n\t\t\tfor (i in obj) {\r\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tlimitExecByInterval: function (fn, time, context) {\r\n\t\tvar lock, execOnUnlock;\r\n\r\n\t\treturn function wrapperFn() {\r\n\t\t\tvar args = arguments;\r\n\r\n\t\t\tif (lock) {\r\n\t\t\t\texecOnUnlock = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlock = true;\r\n\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlock = false;\r\n\r\n\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t}\r\n\t\t\t}, time);\r\n\r\n\t\t\tfn.apply(context, args);\r\n\t\t};\r\n\t},\r\n\r\n\tfalseFn: function () {\r\n\t\treturn false;\r\n\t},\r\n\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\tsetOptions: function (obj, options) {\r\n\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\tvar i, fn,\r\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\tfn = window[prefixes[i] + name];\r\n\t\t}\r\n\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame ||\r\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t        getPrefixed('CancelAnimationFrame') ||\r\n\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\tfn = L.bind(fn, context);\r\n\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn();\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tif (this._initHooks) {\r\n\t\t\tthis.callInitHooks();\r\n\t\t}\r\n\t};\r\n\r\n\t// instantiate class without calling constructor\r\n\tvar F = function () {};\r\n\tF.prototype = this.prototype;\r\n\r\n\tvar proto = new F();\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t//inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (props.options && proto.options) {\r\n\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\tvar parent = this;\r\n\t// jshint camelcase: false\r\n\tNewClass.__super__ = parent.prototype;\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n\t\t// types can be a string of space-separated words\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\tevent = {\r\n\t\t\t\taction: fn,\r\n\t\t\t\tcontext: context || this\r\n\t\t\t};\r\n\t\t\ttype = types[i];\r\n\r\n\t\t\tif (contextId) {\r\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\ttypeIndex[contextId] = [];\r\n\r\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttypeIndex[contextId].push(event);\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\tevents[type].push(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\tvar events = this[eventsKey];\r\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t},\r\n\r\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n\t\tif (!this[eventsKey]) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!types) {\r\n\t\t\treturn this.clearAllEventListeners();\r\n\t\t}\r\n\r\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\ttype = types[i];\r\n\t\t\tindexKey = type + '_idx';\r\n\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\ttypeIndex = events[indexKey];\r\n\r\n\t\t\tif (!fn) {\r\n\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\tdelete events[type];\r\n\t\t\t\tdelete events[indexKey];\r\n\t\t\t\tdelete events[indexLenKey];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearAllEventListeners: function () {\r\n\t\tdelete this[eventsKey];\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    listeners, i, len, typeIndex, contextId;\r\n\r\n\t\tif (events[type]) {\r\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// fire event for the context-indexed listeners as well\r\n\t\ttypeIndex = events[type + '_idx'];\r\n\r\n\t\tfor (contextId in typeIndex) {\r\n\t\t\tlisteners = typeIndex[contextId].slice();\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOneTimeEventListener: function (types, fn, context) {\r\n\r\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\treturn this\r\n\t\t    .addEventListener(types, fn, context)\r\n\t\t    .addEventListener(types, handler, context);\r\n\t}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ie = 'ActiveXObject' in window,\r\n\t\tielt9 = ie && !document.addEventListener,\r\n\r\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t    ua = navigator.userAgent.toLowerCase(),\r\n\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android = ua.indexOf('android') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\r\n\t    mobile = typeof orientation !== undefined + '',\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\r\n\t\t\t\t  msPointer,\r\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n\t    doc = document.documentElement,\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera3d = 'OTransition' in doc.style,\r\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ielt9,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n\t\tandroid: android,\r\n\t\tandroid23: android23,\r\n\r\n\t\tchrome: chrome,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera3d: opera3d,\r\n\t\tany3d: any3d,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\r\n\t\ttouch: touch,\r\n\t\tmsPointer: msPointer,\r\n\t\tpointer: pointer,\r\n\r\n\t\tretina: retina\r\n\t};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style];\r\n\r\n\t\tif (!value && el.currentStyle) {\r\n\t\t\tvalue = el.currentStyle[style];\r\n\t\t}\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tgetViewportOffset: function (element) {\r\n\r\n\t\tvar top = 0,\r\n\t\t    left = 0,\r\n\t\t    el = element,\r\n\t\t    docBody = document.body,\r\n\t\t    docEl = document.documentElement,\r\n\t\t    pos;\r\n\r\n\t\tdo {\r\n\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\tleft += el.offsetLeft || 0;\r\n\r\n\t\t\t//add borders\r\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\r\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n\t\t\tif (pos === 'fixed') {\r\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t    r = el.getBoundingClientRect();\r\n\r\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tel = el.offsetParent;\r\n\r\n\t\t} while (el);\r\n\r\n\t\tel = element;\r\n\r\n\t\tdo {\r\n\t\t\tif (el === docBody) { break; }\r\n\r\n\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\tleft -= el.scrollLeft || 0;\r\n\r\n\t\t\tel = el.parentNode;\r\n\t\t} while (el);\r\n\r\n\t\treturn new L.Point(left, top);\r\n\t},\r\n\r\n\tdocumentIsLtr: function () {\r\n\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t}\r\n\t\treturn L.DomUtil._docIsLtr;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil._getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\t_setClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\r\n\t\t\tvar filter = false,\r\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\ttry {\r\n\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\tif (value === 1) { return; }\r\n\t\t\t}\r\n\r\n\t\t\tvalue = Math.round(value * 100);\r\n\r\n\t\t\tif (filter) {\r\n\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\tfilter.Opacity = value;\r\n\t\t\t} else {\r\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetTranslateString: function (point) {\r\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t    close = (is3d ? ',0' : '') + ')';\r\n\r\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t},\r\n\r\n\tgetScaleString: function (scale, origin) {\r\n\r\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\r\n\t\treturn preTranslateStr + scaleStr;\r\n\t},\r\n\r\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t// jshint camelcase: false\r\n\t\tel._leaflet_pos = point;\r\n\r\n\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\t// jshint camelcase: false\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\tL.extend(L.DomUtil, {\r\n\t\tdisableImageDrag: function () {\r\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t},\r\n\r\n\t\tenableImageDrag: function () {\r\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\tlat = parseFloat(lat);\r\n\tlng = parseFloat(lng);\r\n\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = lat;\r\n\tthis.lng = lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = parseFloat(alt);\r\n\t}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n\tDEG_TO_RAD: Math.PI / 180,\r\n\tRAD_TO_DEG: 180 / Math.PI,\r\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t},\r\n\r\n\ttoString: function (precision) { // (Number) -> String\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\tother = L.latLng(other);\r\n\r\n\t\tvar R = 6378137, // earth radius in meters\r\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t    lat1 = this.lat * d2r,\r\n\t\t    lat2 = other.lat * d2r,\r\n\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t    sin2 = Math.sin(dLon / 2);\r\n\r\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t},\r\n\r\n\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\tvar lng = this.lng;\r\n\r\n\t\ta = a || -180;\r\n\t\tb = b ||  180;\r\n\r\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n\t\treturn new L.LatLng(this.lat, lng);\r\n\t}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a)) {\r\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tif (!obj) { return this; }\r\n\r\n\t\tvar latLng = L.latLng(obj);\r\n\t\tif (latLng !== null) {\r\n\t\t\tobj = latLng;\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t} else {\r\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t}\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tthis.extend(obj._southWest);\r\n\t\t\tthis.extend(obj._northEast);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    x = latlng.lng * d,\r\n\t\t    y = lat * d;\r\n\r\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    lng = point.x * d,\r\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n\t\treturn new L.LatLng(lat, lng);\r\n\t}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tgetSize: function (zoom) {\r\n\t\tvar s = this.scale(zoom);\r\n\t\treturn L.point(s, s);\r\n\t}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3857',\r\n\r\n\tprojection: L.Projection.SphericalMercator,\r\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    earthRadius = 6378137;\r\n\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:4326',\r\n\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._tileLayersNum = 0;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn this.setView(center, zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tvar center = this.getCenter(),\r\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\treturn this.panTo(newCenter, options);\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\t// TODO method is too big, refactor\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (this._layers[id]) { return this; }\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor!!!\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum++;\r\n\t\t\tthis._tileLayersToLoad++;\r\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._layerAdd(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (!this._layers[id]) { return this; }\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tlayer.onRemove(this);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t}\r\n\r\n\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum--;\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (L.stamp(layer) in this._layers);\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._initialCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tthis._initEvents('off');\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tthis._clearPanes();\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\treturn this._initialCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\tthis.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function () {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._initialTopLeftPoint;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale) {\r\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t},\r\n\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\r\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t}\r\n\t},\r\n\r\n\t_createPane: function (className, container) {\r\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t},\r\n\r\n\t_clearPanes: function () {\r\n\t\tthis._container.removeChild(this._mapPane);\r\n\t},\r\n\r\n\t_addLayers: function (layers) {\r\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\tthis.addLayer(layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\r\n\t\tif (!afterZoomAnim) {\r\n\t\t\tthis.fire('movestart');\r\n\r\n\t\t\tif (zoomChanged) {\r\n\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._initialCenter = center;\r\n\r\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n\t\tif (!preserveMapOffset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t} else {\r\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t}\r\n\r\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\r\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t}\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_updateZoomLevels: function () {\r\n\t\tvar i,\r\n\t\t\tminZoom = Infinity,\r\n\t\t\tmaxZoom = -Infinity,\r\n\t\t\toldZoomSpan = this._getZoomSpan();\r\n\r\n\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t}\r\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t} else {\r\n\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t}\r\n\r\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\t\t}\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// map events\r\n\r\n\t_initEvents: function (onOff) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tonOff = onOff || 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t    i, len;\r\n\r\n\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t            L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tthis.fire('preclick');\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n\t\tif (!this.hasEventListeners(type)) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t_onTileLayerLoad: function () {\r\n\t\tthis._tileLayersToLoad--;\r\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\tthis.fire('tilelayersload');\r\n\t\t}\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, this);\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_layerAdd: function (layer) {\r\n\t\tlayer.onAdd(this);\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function () {\r\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t// TODO round on display, not calculation to increase precision?\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tMAX_LATITUDE: 85.0840591556,\r\n\r\n\tR_MINOR: 6356752.314245179,\r\n\tR_MAJOR: 6378137,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    x = latlng.lng * d * r,\r\n\t\t    y = lat * d,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t    con = eccent * Math.sin(y);\r\n\r\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\ty = -r * Math.log(ts);\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    lng = point.x * d / r,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t    ts = Math.exp(- point.y / r),\r\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t    numIter = 15,\r\n\t\t    tol = 1e-7,\r\n\t\t    i = numIter,\r\n\t\t    dphi = 0.1,\r\n\t\t    con;\r\n\r\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, lng);\r\n\t}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3395',\r\n\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar m = L.Projection.Mercator,\r\n\t\t    r = m.R_MAJOR,\r\n\t\t    scale = 0.5 / (Math.PI * r);\r\n\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminZoom: 0,\r\n\t\tmaxZoom: 18,\r\n\t\ttileSize: 256,\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tattribution: '',\r\n\t\tzoomOffset: 0,\r\n\t\topacity: 1,\r\n\t\t/*\r\n\t\tmaxNativeZoom: null,\r\n\t\tzIndex: null,\r\n\t\ttms: false,\r\n\t\tcontinuousWorld: false,\r\n\t\tnoWrap: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\treuseTiles: false,\r\n\t\tbounds: false,\r\n\t\t*/\r\n\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\tupdateWhenIdle: L.Browser.mobile\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\toptions.minZoom--;\r\n\t\t\t}\r\n\t\t\tthis.options.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar subdomains = this.options.subdomains;\r\n\r\n\t\tif (typeof subdomains === 'string') {\r\n\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._animated = map._zoomAnimated;\r\n\r\n\t\t// create a container div for tiles\r\n\t\tthis._initContainer();\r\n\r\n\t\t// set up events\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.on({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t\tthis._update();\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis._container.parentNode.removeChild(this._container);\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.off({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._container = null;\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.appendChild(this._container);\r\n\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\tthis.options.zIndex = zIndex;\r\n\t\tthis._updateZIndex();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateZIndex: function () {\r\n\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t}\r\n\t},\r\n\r\n\t_setAutoZIndex: function (pane, compare) {\r\n\r\n\t\tvar layers = pane.children,\r\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t    zIndex, i, len;\r\n\r\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\r\n\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar i,\r\n\t\t    tiles = this._tiles;\r\n\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tfor (i in tiles) {\r\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_initContainer: function () {\r\n\t\tvar tilePane = this._map._panes.tilePane;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n\t\t\tthis._updateZIndex();\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tvar className = 'leaflet-tile-container';\r\n\r\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t}\r\n\r\n\t\t\ttilePane.appendChild(this._container);\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_reset: function (e) {\r\n\t\tfor (var key in this._tiles) {\r\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t}\r\n\r\n\t\tthis._tiles = {};\r\n\t\tthis._tilesToLoad = 0;\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tthis._unusedTiles = [];\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.innerHTML = '';\r\n\r\n\t\tif (this._animated && e && e.hard) {\r\n\t\t\tthis._clearBgBuffer();\r\n\t\t}\r\n\r\n\t\tthis._initContainer();\r\n\t},\r\n\r\n\t_getTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t    tileSize = this.options.tileSize;\r\n\r\n\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t}\r\n\r\n\t\treturn tileSize;\r\n\t},\r\n\r\n\t_update: function () {\r\n\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    bounds = map.getPixelBounds(),\r\n\t\t    zoom = map.getZoom(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tileBounds = L.bounds(\r\n\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\r\n\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\r\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_addTilesFromCenterOut: function (bounds) {\r\n\t\tvar queue = [],\r\n\t\t    center = bounds.getCenter();\r\n\r\n\t\tvar j, i, point;\r\n\r\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\tpoint = new L.Point(i, j);\r\n\r\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar tilesToLoad = queue.length;\r\n\r\n\t\tif (tilesToLoad === 0) { return; }\r\n\r\n\t\t// load tiles in order of their distance to center\r\n\t\tqueue.sort(function (a, b) {\r\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t});\r\n\r\n\t\tvar fragment = document.createDocumentFragment();\r\n\r\n\t\t// if its the first batch of tiles to load\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('loading');\r\n\t\t}\r\n\r\n\t\tthis._tilesToLoad += tilesToLoad;\r\n\r\n\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.appendChild(fragment);\r\n\t},\r\n\r\n\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\treturn false; // already loaded\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (!options.continuousWorld) {\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t\t// don't load if exceeds world bounds\r\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\tvar tileSize = this._getTileSize(),\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t    se = this._map.unproject(sePoint);\r\n\r\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\tnw = nw.wrap();\r\n\t\t\t\tse = se.wrap();\r\n\t\t\t}\r\n\r\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_removeOtherTiles: function (bounds) {\r\n\t\tvar kArr, x, y, key;\r\n\r\n\t\tfor (key in this._tiles) {\r\n\t\t\tkArr = key.split(':');\r\n\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\ty = parseInt(kArr[1], 10);\r\n\r\n\t\t\t// remove tile if it's out of bounds\r\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\tthis._removeTile(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_removeTile: function (key) {\r\n\t\tvar tile = this._tiles[key];\r\n\r\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\tthis._unusedTiles.push(tile);\r\n\r\n\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t}\r\n\r\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\ttile.onload = null;\r\n\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t}\r\n\r\n\t\tdelete this._tiles[key];\r\n\t},\r\n\r\n\t_addTile: function (tilePoint, container) {\r\n\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\r\n\t\t// get unused tile - or create a new tile\r\n\t\tvar tile = this._getTile();\r\n\r\n\t\t/*\r\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t*/\r\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n\t\tthis._loadTile(tile, tilePoint);\r\n\r\n\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\tcontainer.appendChild(tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getTilePos: function (tilePoint) {\r\n\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t},\r\n\r\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n\tgetTileUrl: function (tilePoint) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\tz: tilePoint.z,\r\n\t\t\tx: tilePoint.x,\r\n\t\t\ty: tilePoint.y\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_getWrapTileNum: function () {\r\n\t\tvar crs = this._map.options.crs,\r\n\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t},\r\n\r\n\t_adjustTilePoint: function (tilePoint) {\r\n\r\n\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t// wrap tile coordinates\r\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t}\r\n\r\n\t\tif (this.options.tms) {\r\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t}\r\n\r\n\t\ttilePoint.z = this._getZoomForUrl();\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t_getTile: function () {\r\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\tthis._resetTile(tile);\r\n\t\t\treturn tile;\r\n\t\t}\r\n\t\treturn this._createTile();\r\n\t},\r\n\r\n\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t_resetTile: function (/*tile*/) {},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\ttile.galleryimg = 'no';\r\n\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t}\r\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t}\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer  = this;\r\n\t\ttile.onload  = this._tileOnLoad;\r\n\t\ttile.onerror = this._tileOnError;\r\n\r\n\t\tthis._adjustTilePoint(tilePoint);\r\n\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\r\n\t\tthis.fire('tileloadstart', {\r\n\t\t\ttile: tile,\r\n\t\t\turl: tile.src\r\n\t\t});\r\n\t},\r\n\r\n\t_tileLoaded: function () {\r\n\t\tthis._tilesToLoad--;\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t}\r\n\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('load');\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnLoad: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\t//Only if we are loading an actual image\r\n\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n\t\t\tlayer.fire('tileload', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t},\r\n\r\n\t_tileOnError: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\tlayer.fire('tileerror', {\r\n\t\t\ttile: this,\r\n\t\t\turl: this.src\r\n\t\t});\r\n\r\n\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\tif (newUrl) {\r\n\t\t\tthis.src = newUrl;\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) { // (String, Object)\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t} else {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t}\r\n\r\n\t\tfor (var i in options) {\r\n\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = this.options.tileSize,\r\n\r\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n\toptions: {\r\n\t\tasync: false\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tfor (var i in this._tiles) {\r\n\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_redrawTile: function (tile) {\r\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer = this;\r\n\t\ttile._tilePoint = tilePoint;\r\n\r\n\t\tthis._redrawTile(tile);\r\n\r\n\t\tif (!this.options.async) {\r\n\t\t\tthis.tileDrawn(tile);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t// override with rendering code\r\n\t},\r\n\r\n\ttileDrawn: function (tile) {\r\n\t\tthis._tileOnLoad.call(tile);\r\n\t}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n\treturn new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\topacity: 1\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\t\t}\r\n\r\n\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\r\n\t\tmap.on('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\r\n\t\tmap.off('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation) {\r\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tthis._updateOpacity();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\tbringToFront: function () {\r\n\t\tif (this._image) {\r\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.overlayPane;\r\n\t\tif (this._image) {\r\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\t\tthis._image.src = this._url;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t}\r\n\r\n\t\tthis._updateOpacity();\r\n\r\n\t\t//TODO createImage util method to remove duplication\r\n\t\tL.extend(this._image, {\r\n\t\t\tgalleryimg: 'no',\r\n\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\tsrc: this._url\r\n\t\t});\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar map = this._map,\r\n\t\t    image = this._image,\r\n\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t    se = this._bounds.getSouthEast(),\r\n\r\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image   = this._image,\r\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n\t\tL.DomUtil.setPosition(image, topLeft);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_onImageLoad: function () {\r\n\t\tthis.fire('load');\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\toptions: {\r\n\t\t/*\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\t*/\r\n\t\tclassName: ''\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img;\r\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\timg = this._createImg(src);\r\n\t\t} else {\r\n\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t}\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor;\r\n\r\n\t\tif (name === 'shadow') {\r\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t} else {\r\n\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t}\r\n\r\n\t\tif (!anchor && size) {\r\n\t\t\tanchor = size.divideBy(2, true);\r\n\t\t}\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t}\r\n\t\treturn this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\ttitle: '',\r\n\t\talt: '',\r\n\t\tclickable: true,\r\n\t\tdraggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\triseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tmap.on('viewreset', this.update, this);\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t\tthis.fire('add');\r\n\r\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging.disable();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\r\n\t\tthis.fire('remove');\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.update,\r\n\t\t\t'zoomanim': this._animateZoom\r\n\t\t}, this);\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\r\n\t\tthis.update();\r\n\r\n\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\tthis.update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (this._icon) {\r\n\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    map = this._map,\r\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\taddIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tthis._initInteraction();\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\taddShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tvar panes = this._map._panes;\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t}\r\n\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t}\r\n\r\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.clickable) { return; }\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\r\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\r\n\t\tif (wasDragged) { return; }\r\n\r\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\t},\r\n\r\n\t_onKeyPress: function (e) {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tthis.fire('click', {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\r\n\t\t// TODO proper custom event propagation\r\n\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousedown') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: null,\r\n\t\tautoPan: true,\r\n\t\tcloseButton: true,\r\n\t\toffset: [0, 7],\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: null,\r\n\t\t// autoPanPaddingBottomRight: null,\r\n\t\tkeepInView: false,\r\n\t\tclassName: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\tthis._isOpen = false;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tvar animFade = map.options.fadeAnimation;\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\t\tmap._panes.popupPane.appendChild(this._container);\r\n\r\n\t\tmap.on(this._getEvents(), this);\r\n\r\n\t\tthis.update();\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tthis.fire('open');\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._panes.popupPane.removeChild(this._container);\r\n\r\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n\t\tmap.off(this._getEvents(), this);\r\n\r\n\t\tif (map.options.fadeAnimation) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\tthis.fire('close');\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\t_getEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\tcloseButton;\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tcloseButton = this._closeButton =\r\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper =\r\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tif (typeof this._content === 'string') {\r\n\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t} else {\r\n\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t}\r\n\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    animated = this._animated,\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (animated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t}\r\n\r\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t},\r\n\r\n\t_zoomAnimation: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tthis.closePopup();\r\n\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tvar content = popup;\r\n\r\n\t\t\tpopup = new L.Popup(options)\r\n\t\t\t    .setLatLng(latlng)\r\n\t\t\t    .setContent(content);\r\n\t\t}\r\n\t\tpopup._isOpen = true;\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t\tpopup._isOpen = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\topenPopup: function () {\r\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttogglePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\tthis.closePopup();\r\n\t\t\t} else {\r\n\t\t\t\tthis.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n\t\tif (options && options.offset) {\r\n\t\t\tanchor = anchor.add(options.offset);\r\n\t\t}\r\n\r\n\t\toptions = L.extend({offset: anchor}, options);\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tL.setOptions(content, options);\r\n\t\t\tthis._popup = content;\r\n\t\t\tcontent._source = this;\r\n\t\t} else {\r\n\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t.setContent(content);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPopupContent: function (content) {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPopup: function () {\r\n\t\treturn this._popup;\r\n\t},\r\n\r\n\t_movePopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis.eachLayer(map.addLayer, map);\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ('on' in layer) {\r\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t}\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tif ('off' in layer) {\r\n\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent) {\r\n\t\t\tthis.invoke('unbindPopup');\r\n\t\t}\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tthis._popupContent = content;\r\n\t\tthis._popupOptions = options;\r\n\t\treturn this.invoke('bindPopup', content, options);\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\t\t// open popup on the first layer\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t});\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\te = L.extend({\r\n\t\t\tlayer: e.target,\r\n\t\t\ttarget: this\r\n\t\t}, e);\r\n\t\tthis.fire(e.type, e);\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n\tincludes: [L.Mixin.Events],\r\n\r\n\tstatics: {\r\n\t\t// how much to extend the clip area around the map view\r\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\tCLIP_PADDING: (function () {\r\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t})()\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#0033ff',\r\n\t\tdashArray: null,\r\n\t\tlineCap: null,\r\n\t\tlineJoin: null,\r\n\t\tweight: 5,\r\n\t\topacity: 0.5,\r\n\r\n\t\tfill: false,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\r\n\t\tclickable: true\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initElements();\r\n\t\t\tthis._initEvents();\r\n\t\t}\r\n\r\n\t\tthis.projectLatlngs();\r\n\t\tthis._updatePath();\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t}\r\n\r\n\t\tthis.fire('add');\r\n\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._pathRoot.removeChild(this._container);\r\n\r\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\r\n\t\tif (L.Browser.vml) {\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._stroke = null;\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\t// do all projection stuff here\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._updateStyle();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_updatePathViewport: function () {\r\n\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t    size = this.getSize(),\r\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n\tstatics: {\r\n\t\tSVG: L.Browser.svg\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container;\r\n\r\n\t\tif (path && root.lastChild !== path) {\r\n\t\t\troot.appendChild(path);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container,\r\n\t\t    first = root.firstChild;\r\n\r\n\t\tif (path && first !== path) {\r\n\t\t\troot.insertBefore(path, first);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\t// form path string here\r\n\t},\r\n\r\n\t_createElement: function (name) {\r\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._initPath();\r\n\t\tthis._initStyle();\r\n\t},\r\n\r\n\t_initPath: function () {\r\n\t\tthis._container = this._createElement('g');\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\r\n\t\tif (this.options.className) {\r\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t}\r\n\r\n\t\tthis._container.appendChild(this._path);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t}\r\n\t\tif (this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t}\r\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t}\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\tif (this.options.dashArray) {\r\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t}\r\n\t\t\tif (this.options.lineCap) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t}\r\n\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar str = this.getPathString();\r\n\t\tif (!str) {\r\n\t\t\t// fix webkit empty string parsing bug\r\n\t\t\tstr = 'M0 0';\r\n\t\t}\r\n\t\tthis._path.setAttribute('d', str);\r\n\t},\r\n\r\n\t// TODO remove duplication with L.Map\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t}\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\r\n\t\tif (e.type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousemove') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_initPathRoot: function () {\r\n\t\tif (!this._pathRoot) {\r\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\r\n\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\tthis._updateSvgViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_animatePathZoom: function (e) {\r\n\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n\t\tthis._pathZooming = true;\r\n\t},\r\n\r\n\t_endPathZoom: function () {\r\n\t\tthis._pathZooming = false;\r\n\t},\r\n\r\n\t_updateSvgViewport: function () {\r\n\r\n\t\tif (this._pathZooming) {\r\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    max = vp.max,\r\n\t\t    width = max.x - min.x,\r\n\t\t    height = max.y - min.y,\r\n\t\t    root = this._pathRoot,\r\n\t\t    pane = this._panes.overlayPane;\r\n\r\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.removeChild(root);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.setAttribute('width', width);\r\n\t\troot.setAttribute('height', height);\r\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.appendChild(root);\r\n\t\t}\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n\tbindPopup: function (content, options) {\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tif (!this._popup || options) {\r\n\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t}\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this);\r\n\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openPopup)\r\n\t\t\t    .off('remove', this.closePopup);\r\n\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_openPopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t\tthis._map.openPopup(this._popup);\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n\ttry {\r\n\t\tvar div = document.createElement('div');\r\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n\t\tvar shape = div.firstChild;\r\n\t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n\t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\tVML: true,\r\n\t\tCLIP_PADDING: 0.02\r\n\t},\r\n\r\n\t_createElement: (function () {\r\n\t\ttry {\r\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement(\r\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t};\r\n\t\t}\r\n\t}()),\r\n\r\n\t_initPath: function () {\r\n\t\tvar container = this._container = this._createElement('shape');\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t}\r\n\r\n\t\tcontainer.coordsize = '1 1';\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\t\tcontainer.appendChild(this._path);\r\n\r\n\t\tthis._map._pathRoot.appendChild(container);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar stroke = this._stroke,\r\n\t\t    fill = this._fill,\r\n\t\t    options = this.options,\r\n\t\t    container = this._container;\r\n\r\n\t\tcontainer.stroked = options.stroke;\r\n\t\tcontainer.filled = options.fill;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tif (!stroke) {\r\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t}\r\n\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\tstroke.color = options.color;\r\n\t\t\tstroke.opacity = options.opacity;\r\n\r\n\t\t\tif (options.dashArray) {\r\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t} else {\r\n\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t}\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t}\r\n\r\n\t\t} else if (stroke) {\r\n\t\t\tcontainer.removeChild(stroke);\r\n\t\t\tthis._stroke = null;\r\n\t\t}\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tif (!fill) {\r\n\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t}\r\n\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\tfill.opacity = options.fillOpacity;\r\n\r\n\t\t} else if (fill) {\r\n\t\t\tcontainer.removeChild(fill);\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar style = this._container.style;\r\n\r\n\t\tstyle.display = 'none';\r\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\tstyle.display = '';\r\n\t}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tif (this._pathRoot) { return; }\r\n\r\n\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\troot.className = 'leaflet-vml-container';\r\n\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\tthis._updatePathViewport();\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n\treturn !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\tCANVAS: true,\r\n\t\tSVG: false\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateStyle();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t    .off('moveend', this._updatePath, this);\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\r\n\t\tthis._requestUpdate();\r\n\t\t\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t_requestUpdate: function () {\r\n\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMapMoveEnd: function () {\r\n\t\tL.Path._updateRequest = null;\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._ctx = this._map._canvasCtx;\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t}\r\n\t\tif (options.fill) {\r\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t}\r\n\r\n\t\tif (options.lineCap) {\r\n\t\t\tthis._ctx.lineCap = options.lineCap;\r\n\t\t}\r\n\t\tif (options.lineJoin) {\r\n\t\t\tthis._ctx.lineJoin = options.lineJoin;\r\n\t\t}\r\n\t},\r\n\r\n\t_drawPath: function () {\r\n\t\tvar i, j, len, len2, point, drawMethod;\r\n\r\n\t\tthis._ctx.beginPath();\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t}\r\n\t\t\t// TODO refactor ugly hack\r\n\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\tthis._ctx.closePath();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\treturn !this._parts.length;\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (this._checkIfEmpty()) { return; }\r\n\r\n\t\tvar ctx = this._ctx,\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._drawPath();\r\n\t\tctx.save();\r\n\t\tthis._updateStyle();\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\tctx.fill(options.fillRule || 'evenodd');\r\n\t\t}\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\r\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis.fire(e.type, e);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\r\n\t\t// TODO don't do on each move\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\tthis._mouseInside = true;\r\n\t\t\tthis.fire('mouseover', e);\r\n\r\n\t\t} else if (this._mouseInside) {\r\n\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\tthis._mouseInside = false;\r\n\t\t\tthis.fire('mouseout', e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tvar root = this._pathRoot,\r\n\t\t    ctx;\r\n\r\n\t\tif (!root) {\r\n\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\troot.style.position = 'absolute';\r\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\r\n\t\t\tctx.lineCap = 'round';\r\n\t\t\tctx.lineJoin = 'round';\r\n\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t}\r\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\tthis._updateCanvasViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_updateCanvasViewport: function () {\r\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\tif (this._pathZooming) { return; }\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    size = vp.max.subtract(min),\r\n\t\t    root = this._pathRoot;\r\n\r\n\t\t//TODO check if this works properly on mobile webkit\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.width = size.x;\r\n\t\troot.height = size.y;\r\n\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\treturn [a, b];\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\treturn false;\r\n\t\t\t// other cases\r\n\t\t\t} else {\r\n\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\ta = p;\r\n\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb = p;\r\n\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t} else if (code & 2) { // right\r\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t} else if (code & 1) { // left\r\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t},\r\n\r\n\toptions: {\r\n\t\t// how much to simplify the polyline on each zoom level\r\n\t\t// more = better performance and smoother look, less = more accurate\r\n\t\tsmoothFactor: 1.0,\r\n\t\tnoClip: false\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._originalPoints = [];\r\n\r\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\tgetLatLngs: function () {\r\n\t\treturn this._latlngs;\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\taddLatLng: function (latlng) {\r\n\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\tthis.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclosestLayerPoint: function (p) {\r\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\tvar points = parts[j];\r\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\tp2 = points[i];\r\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (minPoint) {\r\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t}\r\n\t\treturn minPoint;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t},\r\n\r\n\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tL.Path.prototype._initEvents.call(this);\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar round = L.Path.VML;\r\n\r\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\tp = points[j];\r\n\t\t\tif (round) {\r\n\t\t\t\tp._round();\r\n\t\t\t}\r\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    len = points.length,\r\n\t\t    i, k, segment;\r\n\r\n\t\tif (this.options.noClip) {\r\n\t\t\tthis._parts = [points];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._parts = [];\r\n\r\n\t\tvar parts = this._parts,\r\n\t\t    vp = this._map._pathViewport,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\tif (!segment) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tparts[k] = parts[k] || [];\r\n\t\t\tparts[k].push(segment[0]);\r\n\r\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// simplify each clipped part of the polyline\r\n\t_simplifyPoints: function () {\r\n\t\tvar parts = this._parts,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._clipPoints();\r\n\t\tthis._simplifyPoints();\r\n\r\n\t\tL.Path.prototype._updatePath.call(this);\r\n\t}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n\treturn new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\tthis._initWithHoles(latlngs);\r\n\t},\r\n\r\n\t_initWithHoles: function (latlngs) {\r\n\t\tvar i, len, hole;\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\tthis._holes = latlngs.slice(1);\r\n\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\thole.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// filter out last point if its equal to the first one\r\n\t\tlatlngs = this._latlngs;\r\n\r\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\tlatlngs.pop();\r\n\t\t}\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n\t\t// project polygon holes points\r\n\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\tthis._holePoints = [];\r\n\r\n\t\tif (!this._holes) { return; }\r\n\r\n\t\tvar i, j, len, len2;\r\n\r\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\tthis._holePoints[i] = [];\r\n\r\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t} else {\r\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    newParts = [];\r\n\r\n\t\tthis._parts = [points].concat(this._holePoints);\r\n\r\n\t\tif (this.options.noClip) { return; }\r\n\r\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\tif (clipped.length) {\r\n\t\t\t\tnewParts.push(clipped);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._parts = newParts;\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n\treturn new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n\tfunction createMulti(Klass) {\r\n\r\n\t\treturn L.FeatureGroup.extend({\r\n\r\n\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\tthis._layers = {};\r\n\t\t\t\tthis._options = options;\r\n\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t},\r\n\r\n\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\tvar i = 0,\r\n\t\t\t\t    len = latlngs.length;\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\twhile (i < len) {\r\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\tgetLatLngs: function () {\r\n\t\t\t\tvar latlngs = [];\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn latlngs;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tL.MultiPolyline = createMulti(L.Polyline);\r\n\tL.MultiPolygon = createMulti(L.Polygon);\r\n\r\n\tL.multiPolyline = function (latlngs, options) {\r\n\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t};\r\n\r\n\tL.multiPolygon = function (latlngs, options) {\r\n\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n\tinitialize: function (latLngBounds, options) {\r\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t},\r\n\r\n\tsetBounds: function (latLngBounds) {\r\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t},\r\n\r\n\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\treturn [\r\n\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\tlatLngBounds.getSouthEast()\r\n\t\t];\r\n\t}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n\treturn new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n\tinitialize: function (latlng, radius, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis._mRadius = radius;\r\n\t},\r\n\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis._mRadius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latlng = this._latlng,\r\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t    latlng = this._latlng;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tvar p = this._point,\r\n\t\t    r = this._radius;\r\n\r\n\t\tif (this._checkIfEmpty()) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tif (L.Browser.svg) {\r\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t} else {\r\n\t\t\tp._round();\r\n\t\t\tr = Math.round(r);\r\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._mRadius;\r\n\t},\r\n\r\n\t// TODO Earth hardcoded, move into projection code!\r\n\r\n\t_getLatRadius: function () {\r\n\t\treturn (this._mRadius / 40075017) * 360;\r\n\t},\r\n\r\n\t_getLngRadius: function () {\r\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar vp = this._map._pathViewport,\r\n\t\t    r = this._radius,\r\n\t\t    p = this._point;\r\n\r\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n\treturn new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n\toptions: {\r\n\t\tradius: 10,\r\n\t\tweight: 2\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\tthis._radius = this.options.radius;\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t},\r\n\r\n\t_updateStyle : function () {\r\n\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\tthis.setRadius(this.options.radius);\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis.options.radius = this._radius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._radius;\r\n\t}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n\treturn new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p, closed) {\r\n\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t    w = this.options.weight / 2;\r\n\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p) {\r\n\t\tvar inside = false,\r\n\t\t    part, p1, p2,\r\n\t\t    i, j, k,\r\n\t\t    len, len2;\r\n\r\n\t\t// TODO optimization: check if within bounds first\r\n\r\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t// click on polygon border\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// ray casting algorithm for detecting if point is in polygon\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tp1 = part[j];\r\n\t\t\t\tp2 = part[k];\r\n\r\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn inside;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t_drawPath: function () {\r\n\t\tvar p = this._point;\r\n\t\tthis._ctx.beginPath();\r\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t},\r\n\r\n\t_containsPoint: function (p) {\r\n\t\tvar center = this._point,\r\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\tvar style = this.options.style;\r\n\t\tif (style) {\r\n\t\t\t// reset any custom styles\r\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry.coordinates,\r\n\t\t    layers = [],\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'Polygon':\r\n\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\tvar latlng, i, len,\r\n\t\t    latlngs = [];\r\n\r\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\tvar coords = [latlng.lng, latlng.lat];\r\n\r\n\t\tif (latlng.alt !== undefined) {\r\n\t\t\tcoords.push(latlng.alt);\r\n\t\t}\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latLngs) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'LineString',\r\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t});\r\n\t}\r\n});\r\n\r\nL.Polygon.include({\r\n\ttoGeoJSON: function () {\r\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t    i, len, hole;\r\n\r\n\t\tcoords[0].push(coords[0][0]);\r\n\r\n\t\tif (this._holes) {\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\thole.push(hole[0]);\r\n\t\t\t\tcoords.push(hole);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Polygon',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t}\r\n});\r\n\r\n(function () {\r\n\tfunction multiToGeoJSON(type) {\r\n\t\treturn function () {\r\n\t\t\tvar coords = [];\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t});\r\n\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n\tL.LayerGroup.include({\r\n\t\ttoGeoJSON: function () {\r\n\r\n\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\tjsons = [],\r\n\t\t\t\tjson;\r\n\r\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t}\r\n\r\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (isGeometryCollection) {\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\tfeatures: jsons\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler, originalHandler, newType;\r\n\r\n\t\tif (obj[key]) { return this; }\r\n\r\n\t\thandler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t};\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t}\r\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t}\r\n\r\n\t\tif ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\r\n\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler = obj[key];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t}\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t}\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t.on(el, 'dblclick', stop);\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_checkMouse: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t_getEvent: function () { // evil magic for IE\r\n\t\t/*jshint noarg:false */\r\n\t\tvar e = window.event;\r\n\t\tif (!e) {\r\n\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\twhile (caller) {\r\n\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcaller = caller.caller;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn e;\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\treturn handler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n\t\tL.DomEvent.stopPropagation(e);\r\n\r\n\t\tif (L.Draggable._disabled) { return; }\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tthis.fire('predrag');\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag');\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t}\r\n});\r\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250,\r\n\t\t    touch,\r\n\t\t    pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend,\r\n\t\t    trackedTouches = [];\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\t\t\tif (count > 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t\tdelta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd(e) {\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (doubleTap) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\tprop;\r\n\r\n\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_';\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\tfalse);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveFrom: function (map) {\r\n\t\tvar pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tcorner.removeChild(this._container);\r\n\t\tthis._map = null;\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(map);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.removeFrom(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tthis._container.removeChild(this._controlContainer);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n\t\tthis._map = map;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(\r\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\tthis._zoomOutButton = this._createButton(\r\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'click', stop)\r\n\t\t    .on(link, 'mousedown', stop)\r\n\t\t    .on(link, 'dblclick', stop)\r\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t    .on(link, 'click', fn, context)\r\n\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t\tclassName = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t    .off('layerremove', this._onLayerRemove);\r\n\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t},\r\n\r\n\t_onLayerAdd: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t},\r\n\r\n\t_onLayerRemove: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t    .on('layerremove', this._onLayerChange, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\t\tdelete this._layers[id];\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t.disableScrollPropagation(container);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t}\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList.innerHTML = '';\r\n\t\tthis._overlaysList.innerHTML = '';\r\n\r\n\t\tvar baseLayersPresent = false,\r\n\t\t    overlaysPresent = false,\r\n\t\t    i, obj;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\r\n\t\tif (!obj) { return; }\r\n\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\tif (checked) {\r\n\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t}\r\n\t\tradioHtml += '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    input,\r\n\t\t    checked = this._map.hasLayer(obj.layer);\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\tlabel.appendChild(input);\r\n\t\tlabel.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar i, input, obj,\r\n\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t    inputsLen = inputs.length;\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tobj = this._layers[input.layerId];\r\n\r\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.addLayer(obj.layer);\r\n\r\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = false;\n\t\t\t}\n\t\t}, this);\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\twatch: false,\r\n\t\tsetView: false,\r\n\t\tmaxZoom: Infinity,\r\n\t\ttimeout: 10000,\r\n\t\tmaximumAge: 0,\r\n\t\tenableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (/*Object*/ options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n\t\tif (!navigator.geolocation) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\r\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n\t\t    bounds = L.latLngBounds(\r\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\tthis.setView(latlng, zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.7';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n\twindow.L = oldL;\r\n\treturn this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, j, len, src;\r\n\r\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\tsrc = sources[j] || {};\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t};\r\n\t},\r\n\r\n\tstamp: (function () {\r\n\t\tvar lastId = 0,\r\n\t\t    key = '_leaflet_id';\r\n\t\treturn function (obj) {\r\n\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\treturn obj[key];\r\n\t\t};\r\n\t}()),\r\n\r\n\tinvokeEach: function (obj, method, context) {\r\n\t\tvar i, args;\r\n\r\n\t\tif (typeof obj === 'object') {\r\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\r\n\t\t\tfor (i in obj) {\r\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tlimitExecByInterval: function (fn, time, context) {\r\n\t\tvar lock, execOnUnlock;\r\n\r\n\t\treturn function wrapperFn() {\r\n\t\t\tvar args = arguments;\r\n\r\n\t\t\tif (lock) {\r\n\t\t\t\texecOnUnlock = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlock = true;\r\n\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlock = false;\r\n\r\n\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t}\r\n\t\t\t}, time);\r\n\r\n\t\t\tfn.apply(context, args);\r\n\t\t};\r\n\t},\r\n\r\n\tfalseFn: function () {\r\n\t\treturn false;\r\n\t},\r\n\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\tsetOptions: function (obj, options) {\r\n\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\tvar i, fn,\r\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\tfn = window[prefixes[i] + name];\r\n\t\t}\r\n\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame ||\r\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t        getPrefixed('CancelAnimationFrame') ||\r\n\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\tfn = L.bind(fn, context);\r\n\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn();\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tif (this._initHooks) {\r\n\t\t\tthis.callInitHooks();\r\n\t\t}\r\n\t};\r\n\r\n\t// instantiate class without calling constructor\r\n\tvar F = function () {};\r\n\tF.prototype = this.prototype;\r\n\r\n\tvar proto = new F();\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t//inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (props.options && proto.options) {\r\n\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\tvar parent = this;\r\n\t// jshint camelcase: false\r\n\tNewClass.__super__ = parent.prototype;\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n\t\t// types can be a string of space-separated words\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\tevent = {\r\n\t\t\t\taction: fn,\r\n\t\t\t\tcontext: context || this\r\n\t\t\t};\r\n\t\t\ttype = types[i];\r\n\r\n\t\t\tif (contextId) {\r\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\ttypeIndex[contextId] = [];\r\n\r\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttypeIndex[contextId].push(event);\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\tevents[type].push(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\tvar events = this[eventsKey];\r\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t},\r\n\r\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n\t\tif (!this[eventsKey]) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!types) {\r\n\t\t\treturn this.clearAllEventListeners();\r\n\t\t}\r\n\r\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\ttype = types[i];\r\n\t\t\tindexKey = type + '_idx';\r\n\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\ttypeIndex = events[indexKey];\r\n\r\n\t\t\tif (!fn) {\r\n\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\tdelete events[type];\r\n\t\t\t\tdelete events[indexKey];\r\n\t\t\t\tdelete events[indexLenKey];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearAllEventListeners: function () {\r\n\t\tdelete this[eventsKey];\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    listeners, i, len, typeIndex, contextId;\r\n\r\n\t\tif (events[type]) {\r\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// fire event for the context-indexed listeners as well\r\n\t\ttypeIndex = events[type + '_idx'];\r\n\r\n\t\tfor (contextId in typeIndex) {\r\n\t\t\tlisteners = typeIndex[contextId].slice();\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOneTimeEventListener: function (types, fn, context) {\r\n\r\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\treturn this\r\n\t\t    .addEventListener(types, fn, context)\r\n\t\t    .addEventListener(types, handler, context);\r\n\t}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ie = 'ActiveXObject' in window,\r\n\t\tielt9 = ie && !document.addEventListener,\r\n\r\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t    ua = navigator.userAgent.toLowerCase(),\r\n\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android = ua.indexOf('android') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\r\n\t    mobile = typeof orientation !== undefined + '',\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\r\n\t\t\t\t  msPointer,\r\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n\t    doc = document.documentElement,\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera3d = 'OTransition' in doc.style,\r\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ielt9,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n\t\tandroid: android,\r\n\t\tandroid23: android23,\r\n\r\n\t\tchrome: chrome,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera3d: opera3d,\r\n\t\tany3d: any3d,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\r\n\t\ttouch: touch,\r\n\t\tmsPointer: msPointer,\r\n\t\tpointer: pointer,\r\n\r\n\t\tretina: retina\r\n\t};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style];\r\n\r\n\t\tif (!value && el.currentStyle) {\r\n\t\t\tvalue = el.currentStyle[style];\r\n\t\t}\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tgetViewportOffset: function (element) {\r\n\r\n\t\tvar top = 0,\r\n\t\t    left = 0,\r\n\t\t    el = element,\r\n\t\t    docBody = document.body,\r\n\t\t    docEl = document.documentElement,\r\n\t\t    pos;\r\n\r\n\t\tdo {\r\n\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\tleft += el.offsetLeft || 0;\r\n\r\n\t\t\t//add borders\r\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\r\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n\t\t\tif (pos === 'fixed') {\r\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t    r = el.getBoundingClientRect();\r\n\r\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tel = el.offsetParent;\r\n\r\n\t\t} while (el);\r\n\r\n\t\tel = element;\r\n\r\n\t\tdo {\r\n\t\t\tif (el === docBody) { break; }\r\n\r\n\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\tleft -= el.scrollLeft || 0;\r\n\r\n\t\t\tel = el.parentNode;\r\n\t\t} while (el);\r\n\r\n\t\treturn new L.Point(left, top);\r\n\t},\r\n\r\n\tdocumentIsLtr: function () {\r\n\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t}\r\n\t\treturn L.DomUtil._docIsLtr;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil._getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\t_setClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\r\n\t\t\tvar filter = false,\r\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\ttry {\r\n\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\tif (value === 1) { return; }\r\n\t\t\t}\r\n\r\n\t\t\tvalue = Math.round(value * 100);\r\n\r\n\t\t\tif (filter) {\r\n\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\tfilter.Opacity = value;\r\n\t\t\t} else {\r\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetTranslateString: function (point) {\r\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t    close = (is3d ? ',0' : '') + ')';\r\n\r\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t},\r\n\r\n\tgetScaleString: function (scale, origin) {\r\n\r\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\r\n\t\treturn preTranslateStr + scaleStr;\r\n\t},\r\n\r\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t// jshint camelcase: false\r\n\t\tel._leaflet_pos = point;\r\n\r\n\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\t// jshint camelcase: false\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\tL.extend(L.DomUtil, {\r\n\t\tdisableImageDrag: function () {\r\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t},\r\n\r\n\t\tenableImageDrag: function () {\r\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\tlat = parseFloat(lat);\r\n\tlng = parseFloat(lng);\r\n\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = lat;\r\n\tthis.lng = lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = parseFloat(alt);\r\n\t}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n\tDEG_TO_RAD: Math.PI / 180,\r\n\tRAD_TO_DEG: 180 / Math.PI,\r\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t},\r\n\r\n\ttoString: function (precision) { // (Number) -> String\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\tother = L.latLng(other);\r\n\r\n\t\tvar R = 6378137, // earth radius in meters\r\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t    lat1 = this.lat * d2r,\r\n\t\t    lat2 = other.lat * d2r,\r\n\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t    sin2 = Math.sin(dLon / 2);\r\n\r\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t},\r\n\r\n\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\tvar lng = this.lng;\r\n\r\n\t\ta = a || -180;\r\n\t\tb = b ||  180;\r\n\r\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n\t\treturn new L.LatLng(this.lat, lng);\r\n\t}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a)) {\r\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tif (!obj) { return this; }\r\n\r\n\t\tvar latLng = L.latLng(obj);\r\n\t\tif (latLng !== null) {\r\n\t\t\tobj = latLng;\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t} else {\r\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t}\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tthis.extend(obj._southWest);\r\n\t\t\tthis.extend(obj._northEast);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    x = latlng.lng * d,\r\n\t\t    y = lat * d;\r\n\r\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    lng = point.x * d,\r\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n\t\treturn new L.LatLng(lat, lng);\r\n\t}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tgetSize: function (zoom) {\r\n\t\tvar s = this.scale(zoom);\r\n\t\treturn L.point(s, s);\r\n\t}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3857',\r\n\r\n\tprojection: L.Projection.SphericalMercator,\r\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    earthRadius = 6378137;\r\n\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:4326',\r\n\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._tileLayersNum = 0;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn this.setView(center, zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tvar center = this.getCenter(),\r\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\treturn this.panTo(newCenter, options);\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\t// TODO method is too big, refactor\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (this._layers[id]) { return this; }\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor!!!\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum++;\r\n\t\t\tthis._tileLayersToLoad++;\r\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._layerAdd(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (!this._layers[id]) { return this; }\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tlayer.onRemove(this);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t}\r\n\r\n\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum--;\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (L.stamp(layer) in this._layers);\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._initialCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tthis._initEvents('off');\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tthis._clearPanes();\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\treturn this._initialCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\tthis.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function () {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._initialTopLeftPoint;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale) {\r\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t},\r\n\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\r\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t}\r\n\t},\r\n\r\n\t_createPane: function (className, container) {\r\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t},\r\n\r\n\t_clearPanes: function () {\r\n\t\tthis._container.removeChild(this._mapPane);\r\n\t},\r\n\r\n\t_addLayers: function (layers) {\r\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\tthis.addLayer(layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\r\n\t\tif (!afterZoomAnim) {\r\n\t\t\tthis.fire('movestart');\r\n\r\n\t\t\tif (zoomChanged) {\r\n\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._initialCenter = center;\r\n\r\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n\t\tif (!preserveMapOffset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t} else {\r\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t}\r\n\r\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\r\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t}\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_updateZoomLevels: function () {\r\n\t\tvar i,\r\n\t\t\tminZoom = Infinity,\r\n\t\t\tmaxZoom = -Infinity,\r\n\t\t\toldZoomSpan = this._getZoomSpan();\r\n\r\n\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t}\r\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t} else {\r\n\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t}\r\n\r\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\t\t}\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// map events\r\n\r\n\t_initEvents: function (onOff) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tonOff = onOff || 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t    i, len;\r\n\r\n\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t            L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tthis.fire('preclick');\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n\t\tif (!this.hasEventListeners(type)) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t_onTileLayerLoad: function () {\r\n\t\tthis._tileLayersToLoad--;\r\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\tthis.fire('tilelayersload');\r\n\t\t}\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, this);\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_layerAdd: function (layer) {\r\n\t\tlayer.onAdd(this);\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function () {\r\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t// TODO round on display, not calculation to increase precision?\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tMAX_LATITUDE: 85.0840591556,\r\n\r\n\tR_MINOR: 6356752.314245179,\r\n\tR_MAJOR: 6378137,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    x = latlng.lng * d * r,\r\n\t\t    y = lat * d,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t    con = eccent * Math.sin(y);\r\n\r\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\ty = -r * Math.log(ts);\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    lng = point.x * d / r,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t    ts = Math.exp(- point.y / r),\r\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t    numIter = 15,\r\n\t\t    tol = 1e-7,\r\n\t\t    i = numIter,\r\n\t\t    dphi = 0.1,\r\n\t\t    con;\r\n\r\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, lng);\r\n\t}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3395',\r\n\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar m = L.Projection.Mercator,\r\n\t\t    r = m.R_MAJOR,\r\n\t\t    scale = 0.5 / (Math.PI * r);\r\n\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminZoom: 0,\r\n\t\tmaxZoom: 18,\r\n\t\ttileSize: 256,\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tattribution: '',\r\n\t\tzoomOffset: 0,\r\n\t\topacity: 1,\r\n\t\t/*\r\n\t\tmaxNativeZoom: null,\r\n\t\tzIndex: null,\r\n\t\ttms: false,\r\n\t\tcontinuousWorld: false,\r\n\t\tnoWrap: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\treuseTiles: false,\r\n\t\tbounds: false,\r\n\t\t*/\r\n\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\tupdateWhenIdle: L.Browser.mobile\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\toptions.minZoom--;\r\n\t\t\t}\r\n\t\t\tthis.options.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar subdomains = this.options.subdomains;\r\n\r\n\t\tif (typeof subdomains === 'string') {\r\n\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._animated = map._zoomAnimated;\r\n\r\n\t\t// create a container div for tiles\r\n\t\tthis._initContainer();\r\n\r\n\t\t// set up events\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.on({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t\tthis._update();\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis._container.parentNode.removeChild(this._container);\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.off({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._container = null;\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.appendChild(this._container);\r\n\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\tthis.options.zIndex = zIndex;\r\n\t\tthis._updateZIndex();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateZIndex: function () {\r\n\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t}\r\n\t},\r\n\r\n\t_setAutoZIndex: function (pane, compare) {\r\n\r\n\t\tvar layers = pane.children,\r\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t    zIndex, i, len;\r\n\r\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\r\n\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar i,\r\n\t\t    tiles = this._tiles;\r\n\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tfor (i in tiles) {\r\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_initContainer: function () {\r\n\t\tvar tilePane = this._map._panes.tilePane;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n\t\t\tthis._updateZIndex();\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tvar className = 'leaflet-tile-container';\r\n\r\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t}\r\n\r\n\t\t\ttilePane.appendChild(this._container);\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_reset: function (e) {\r\n\t\tfor (var key in this._tiles) {\r\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t}\r\n\r\n\t\tthis._tiles = {};\r\n\t\tthis._tilesToLoad = 0;\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tthis._unusedTiles = [];\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.innerHTML = '';\r\n\r\n\t\tif (this._animated && e && e.hard) {\r\n\t\t\tthis._clearBgBuffer();\r\n\t\t}\r\n\r\n\t\tthis._initContainer();\r\n\t},\r\n\r\n\t_getTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t    tileSize = this.options.tileSize;\r\n\r\n\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t}\r\n\r\n\t\treturn tileSize;\r\n\t},\r\n\r\n\t_update: function () {\r\n\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    bounds = map.getPixelBounds(),\r\n\t\t    zoom = map.getZoom(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tileBounds = L.bounds(\r\n\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\r\n\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\r\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_addTilesFromCenterOut: function (bounds) {\r\n\t\tvar queue = [],\r\n\t\t    center = bounds.getCenter();\r\n\r\n\t\tvar j, i, point;\r\n\r\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\tpoint = new L.Point(i, j);\r\n\r\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar tilesToLoad = queue.length;\r\n\r\n\t\tif (tilesToLoad === 0) { return; }\r\n\r\n\t\t// load tiles in order of their distance to center\r\n\t\tqueue.sort(function (a, b) {\r\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t});\r\n\r\n\t\tvar fragment = document.createDocumentFragment();\r\n\r\n\t\t// if its the first batch of tiles to load\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('loading');\r\n\t\t}\r\n\r\n\t\tthis._tilesToLoad += tilesToLoad;\r\n\r\n\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.appendChild(fragment);\r\n\t},\r\n\r\n\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\treturn false; // already loaded\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (!options.continuousWorld) {\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t\t// don't load if exceeds world bounds\r\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\tvar tileSize = this._getTileSize(),\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t    se = this._map.unproject(sePoint);\r\n\r\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\tnw = nw.wrap();\r\n\t\t\t\tse = se.wrap();\r\n\t\t\t}\r\n\r\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_removeOtherTiles: function (bounds) {\r\n\t\tvar kArr, x, y, key;\r\n\r\n\t\tfor (key in this._tiles) {\r\n\t\t\tkArr = key.split(':');\r\n\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\ty = parseInt(kArr[1], 10);\r\n\r\n\t\t\t// remove tile if it's out of bounds\r\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\tthis._removeTile(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_removeTile: function (key) {\r\n\t\tvar tile = this._tiles[key];\r\n\r\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\tthis._unusedTiles.push(tile);\r\n\r\n\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t}\r\n\r\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\ttile.onload = null;\r\n\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t}\r\n\r\n\t\tdelete this._tiles[key];\r\n\t},\r\n\r\n\t_addTile: function (tilePoint, container) {\r\n\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\r\n\t\t// get unused tile - or create a new tile\r\n\t\tvar tile = this._getTile();\r\n\r\n\t\t/*\r\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t*/\r\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n\t\tthis._loadTile(tile, tilePoint);\r\n\r\n\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\tcontainer.appendChild(tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getTilePos: function (tilePoint) {\r\n\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t},\r\n\r\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n\tgetTileUrl: function (tilePoint) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\tz: tilePoint.z,\r\n\t\t\tx: tilePoint.x,\r\n\t\t\ty: tilePoint.y\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_getWrapTileNum: function () {\r\n\t\tvar crs = this._map.options.crs,\r\n\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t},\r\n\r\n\t_adjustTilePoint: function (tilePoint) {\r\n\r\n\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t// wrap tile coordinates\r\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t}\r\n\r\n\t\tif (this.options.tms) {\r\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t}\r\n\r\n\t\ttilePoint.z = this._getZoomForUrl();\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t_getTile: function () {\r\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\tthis._resetTile(tile);\r\n\t\t\treturn tile;\r\n\t\t}\r\n\t\treturn this._createTile();\r\n\t},\r\n\r\n\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t_resetTile: function (/*tile*/) {},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\ttile.galleryimg = 'no';\r\n\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t}\r\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t}\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer  = this;\r\n\t\ttile.onload  = this._tileOnLoad;\r\n\t\ttile.onerror = this._tileOnError;\r\n\r\n\t\tthis._adjustTilePoint(tilePoint);\r\n\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\r\n\t\tthis.fire('tileloadstart', {\r\n\t\t\ttile: tile,\r\n\t\t\turl: tile.src\r\n\t\t});\r\n\t},\r\n\r\n\t_tileLoaded: function () {\r\n\t\tthis._tilesToLoad--;\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t}\r\n\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('load');\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnLoad: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\t//Only if we are loading an actual image\r\n\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n\t\t\tlayer.fire('tileload', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t},\r\n\r\n\t_tileOnError: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\tlayer.fire('tileerror', {\r\n\t\t\ttile: this,\r\n\t\t\turl: this.src\r\n\t\t});\r\n\r\n\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\tif (newUrl) {\r\n\t\t\tthis.src = newUrl;\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) { // (String, Object)\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t} else {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t}\r\n\r\n\t\tfor (var i in options) {\r\n\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = this.options.tileSize,\r\n\r\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n\toptions: {\r\n\t\tasync: false\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tfor (var i in this._tiles) {\r\n\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_redrawTile: function (tile) {\r\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer = this;\r\n\t\ttile._tilePoint = tilePoint;\r\n\r\n\t\tthis._redrawTile(tile);\r\n\r\n\t\tif (!this.options.async) {\r\n\t\t\tthis.tileDrawn(tile);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t// override with rendering code\r\n\t},\r\n\r\n\ttileDrawn: function (tile) {\r\n\t\tthis._tileOnLoad.call(tile);\r\n\t}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n\treturn new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\topacity: 1\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\t\t}\r\n\r\n\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\r\n\t\tmap.on('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\r\n\t\tmap.off('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation) {\r\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tthis._updateOpacity();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\tbringToFront: function () {\r\n\t\tif (this._image) {\r\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.overlayPane;\r\n\t\tif (this._image) {\r\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\t\tthis._image.src = this._url;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t}\r\n\r\n\t\tthis._updateOpacity();\r\n\r\n\t\t//TODO createImage util method to remove duplication\r\n\t\tL.extend(this._image, {\r\n\t\t\tgalleryimg: 'no',\r\n\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\tsrc: this._url\r\n\t\t});\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar map = this._map,\r\n\t\t    image = this._image,\r\n\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t    se = this._bounds.getSouthEast(),\r\n\r\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image   = this._image,\r\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n\t\tL.DomUtil.setPosition(image, topLeft);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_onImageLoad: function () {\r\n\t\tthis.fire('load');\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\toptions: {\r\n\t\t/*\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\t*/\r\n\t\tclassName: ''\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img;\r\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\timg = this._createImg(src);\r\n\t\t} else {\r\n\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t}\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor;\r\n\r\n\t\tif (name === 'shadow') {\r\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t} else {\r\n\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t}\r\n\r\n\t\tif (!anchor && size) {\r\n\t\t\tanchor = size.divideBy(2, true);\r\n\t\t}\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t}\r\n\t\treturn this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\ttitle: '',\r\n\t\talt: '',\r\n\t\tclickable: true,\r\n\t\tdraggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\triseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tmap.on('viewreset', this.update, this);\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t\tthis.fire('add');\r\n\r\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging.disable();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\r\n\t\tthis.fire('remove');\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.update,\r\n\t\t\t'zoomanim': this._animateZoom\r\n\t\t}, this);\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\r\n\t\tthis.update();\r\n\r\n\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\tthis.update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (this._icon) {\r\n\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    map = this._map,\r\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\taddIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tthis._initInteraction();\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\taddShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tvar panes = this._map._panes;\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t}\r\n\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t}\r\n\r\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.clickable) { return; }\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\r\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\r\n\t\tif (wasDragged) { return; }\r\n\r\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\t},\r\n\r\n\t_onKeyPress: function (e) {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tthis.fire('click', {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\r\n\t\t// TODO proper custom event propagation\r\n\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousedown') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: null,\r\n\t\tautoPan: true,\r\n\t\tcloseButton: true,\r\n\t\toffset: [0, 7],\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: null,\r\n\t\t// autoPanPaddingBottomRight: null,\r\n\t\tkeepInView: false,\r\n\t\tclassName: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\tthis._isOpen = false;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tvar animFade = map.options.fadeAnimation;\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\t\tmap._panes.popupPane.appendChild(this._container);\r\n\r\n\t\tmap.on(this._getEvents(), this);\r\n\r\n\t\tthis.update();\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tthis.fire('open');\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._panes.popupPane.removeChild(this._container);\r\n\r\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n\t\tmap.off(this._getEvents(), this);\r\n\r\n\t\tif (map.options.fadeAnimation) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\tthis.fire('close');\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\t_getEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\tcloseButton;\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tcloseButton = this._closeButton =\r\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper =\r\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tif (typeof this._content === 'string') {\r\n\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t} else {\r\n\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t}\r\n\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    animated = this._animated,\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (animated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t}\r\n\r\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t},\r\n\r\n\t_zoomAnimation: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tthis.closePopup();\r\n\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tvar content = popup;\r\n\r\n\t\t\tpopup = new L.Popup(options)\r\n\t\t\t    .setLatLng(latlng)\r\n\t\t\t    .setContent(content);\r\n\t\t}\r\n\t\tpopup._isOpen = true;\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t\tpopup._isOpen = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\topenPopup: function () {\r\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttogglePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\tthis.closePopup();\r\n\t\t\t} else {\r\n\t\t\t\tthis.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n\t\tif (options && options.offset) {\r\n\t\t\tanchor = anchor.add(options.offset);\r\n\t\t}\r\n\r\n\t\toptions = L.extend({offset: anchor}, options);\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tL.setOptions(content, options);\r\n\t\t\tthis._popup = content;\r\n\t\t\tcontent._source = this;\r\n\t\t} else {\r\n\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t.setContent(content);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPopupContent: function (content) {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPopup: function () {\r\n\t\treturn this._popup;\r\n\t},\r\n\r\n\t_movePopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis.eachLayer(map.addLayer, map);\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ('on' in layer) {\r\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t}\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tif ('off' in layer) {\r\n\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent) {\r\n\t\t\tthis.invoke('unbindPopup');\r\n\t\t}\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tthis._popupContent = content;\r\n\t\tthis._popupOptions = options;\r\n\t\treturn this.invoke('bindPopup', content, options);\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\t\t// open popup on the first layer\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t});\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\te = L.extend({\r\n\t\t\tlayer: e.target,\r\n\t\t\ttarget: this\r\n\t\t}, e);\r\n\t\tthis.fire(e.type, e);\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n\tincludes: [L.Mixin.Events],\r\n\r\n\tstatics: {\r\n\t\t// how much to extend the clip area around the map view\r\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\tCLIP_PADDING: (function () {\r\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t})()\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#0033ff',\r\n\t\tdashArray: null,\r\n\t\tlineCap: null,\r\n\t\tlineJoin: null,\r\n\t\tweight: 5,\r\n\t\topacity: 0.5,\r\n\r\n\t\tfill: false,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\r\n\t\tclickable: true\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initElements();\r\n\t\t\tthis._initEvents();\r\n\t\t}\r\n\r\n\t\tthis.projectLatlngs();\r\n\t\tthis._updatePath();\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t}\r\n\r\n\t\tthis.fire('add');\r\n\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._pathRoot.removeChild(this._container);\r\n\r\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\r\n\t\tif (L.Browser.vml) {\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._stroke = null;\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\t// do all projection stuff here\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._updateStyle();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_updatePathViewport: function () {\r\n\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t    size = this.getSize(),\r\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n\tstatics: {\r\n\t\tSVG: L.Browser.svg\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container;\r\n\r\n\t\tif (path && root.lastChild !== path) {\r\n\t\t\troot.appendChild(path);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container,\r\n\t\t    first = root.firstChild;\r\n\r\n\t\tif (path && first !== path) {\r\n\t\t\troot.insertBefore(path, first);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\t// form path string here\r\n\t},\r\n\r\n\t_createElement: function (name) {\r\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._initPath();\r\n\t\tthis._initStyle();\r\n\t},\r\n\r\n\t_initPath: function () {\r\n\t\tthis._container = this._createElement('g');\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\r\n\t\tif (this.options.className) {\r\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t}\r\n\r\n\t\tthis._container.appendChild(this._path);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t}\r\n\t\tif (this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t}\r\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t}\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\tif (this.options.dashArray) {\r\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t}\r\n\t\t\tif (this.options.lineCap) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t}\r\n\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar str = this.getPathString();\r\n\t\tif (!str) {\r\n\t\t\t// fix webkit empty string parsing bug\r\n\t\t\tstr = 'M0 0';\r\n\t\t}\r\n\t\tthis._path.setAttribute('d', str);\r\n\t},\r\n\r\n\t// TODO remove duplication with L.Map\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t}\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\r\n\t\tif (e.type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousemove') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_initPathRoot: function () {\r\n\t\tif (!this._pathRoot) {\r\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\r\n\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\tthis._updateSvgViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_animatePathZoom: function (e) {\r\n\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n\t\tthis._pathZooming = true;\r\n\t},\r\n\r\n\t_endPathZoom: function () {\r\n\t\tthis._pathZooming = false;\r\n\t},\r\n\r\n\t_updateSvgViewport: function () {\r\n\r\n\t\tif (this._pathZooming) {\r\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    max = vp.max,\r\n\t\t    width = max.x - min.x,\r\n\t\t    height = max.y - min.y,\r\n\t\t    root = this._pathRoot,\r\n\t\t    pane = this._panes.overlayPane;\r\n\r\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.removeChild(root);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.setAttribute('width', width);\r\n\t\troot.setAttribute('height', height);\r\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.appendChild(root);\r\n\t\t}\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n\tbindPopup: function (content, options) {\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tif (!this._popup || options) {\r\n\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t}\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this);\r\n\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openPopup)\r\n\t\t\t    .off('remove', this.closePopup);\r\n\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_openPopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t\tthis._map.openPopup(this._popup);\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n\ttry {\r\n\t\tvar div = document.createElement('div');\r\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n\t\tvar shape = div.firstChild;\r\n\t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n\t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\tVML: true,\r\n\t\tCLIP_PADDING: 0.02\r\n\t},\r\n\r\n\t_createElement: (function () {\r\n\t\ttry {\r\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement(\r\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t};\r\n\t\t}\r\n\t}()),\r\n\r\n\t_initPath: function () {\r\n\t\tvar container = this._container = this._createElement('shape');\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t}\r\n\r\n\t\tcontainer.coordsize = '1 1';\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\t\tcontainer.appendChild(this._path);\r\n\r\n\t\tthis._map._pathRoot.appendChild(container);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar stroke = this._stroke,\r\n\t\t    fill = this._fill,\r\n\t\t    options = this.options,\r\n\t\t    container = this._container;\r\n\r\n\t\tcontainer.stroked = options.stroke;\r\n\t\tcontainer.filled = options.fill;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tif (!stroke) {\r\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t}\r\n\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\tstroke.color = options.color;\r\n\t\t\tstroke.opacity = options.opacity;\r\n\r\n\t\t\tif (options.dashArray) {\r\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t} else {\r\n\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t}\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t}\r\n\r\n\t\t} else if (stroke) {\r\n\t\t\tcontainer.removeChild(stroke);\r\n\t\t\tthis._stroke = null;\r\n\t\t}\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tif (!fill) {\r\n\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t}\r\n\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\tfill.opacity = options.fillOpacity;\r\n\r\n\t\t} else if (fill) {\r\n\t\t\tcontainer.removeChild(fill);\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar style = this._container.style;\r\n\r\n\t\tstyle.display = 'none';\r\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\tstyle.display = '';\r\n\t}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tif (this._pathRoot) { return; }\r\n\r\n\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\troot.className = 'leaflet-vml-container';\r\n\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\tthis._updatePathViewport();\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n\treturn !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\tCANVAS: true,\r\n\t\tSVG: false\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateStyle();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t    .off('moveend', this._updatePath, this);\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\r\n\t\tthis._requestUpdate();\r\n\t\t\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t_requestUpdate: function () {\r\n\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMapMoveEnd: function () {\r\n\t\tL.Path._updateRequest = null;\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._ctx = this._map._canvasCtx;\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t}\r\n\t\tif (options.fill) {\r\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t}\r\n\r\n\t\tif (options.lineCap) {\r\n\t\t\tthis._ctx.lineCap = options.lineCap;\r\n\t\t}\r\n\t\tif (options.lineJoin) {\r\n\t\t\tthis._ctx.lineJoin = options.lineJoin;\r\n\t\t}\r\n\t},\r\n\r\n\t_drawPath: function () {\r\n\t\tvar i, j, len, len2, point, drawMethod;\r\n\r\n\t\tthis._ctx.beginPath();\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t}\r\n\t\t\t// TODO refactor ugly hack\r\n\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\tthis._ctx.closePath();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\treturn !this._parts.length;\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (this._checkIfEmpty()) { return; }\r\n\r\n\t\tvar ctx = this._ctx,\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._drawPath();\r\n\t\tctx.save();\r\n\t\tthis._updateStyle();\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\tctx.fill(options.fillRule || 'evenodd');\r\n\t\t}\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\r\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis.fire(e.type, e);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\r\n\t\t// TODO don't do on each move\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\tthis._mouseInside = true;\r\n\t\t\tthis.fire('mouseover', e);\r\n\r\n\t\t} else if (this._mouseInside) {\r\n\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\tthis._mouseInside = false;\r\n\t\t\tthis.fire('mouseout', e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tvar root = this._pathRoot,\r\n\t\t    ctx;\r\n\r\n\t\tif (!root) {\r\n\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\troot.style.position = 'absolute';\r\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\r\n\t\t\tctx.lineCap = 'round';\r\n\t\t\tctx.lineJoin = 'round';\r\n\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t}\r\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\tthis._updateCanvasViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_updateCanvasViewport: function () {\r\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\tif (this._pathZooming) { return; }\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    size = vp.max.subtract(min),\r\n\t\t    root = this._pathRoot;\r\n\r\n\t\t//TODO check if this works properly on mobile webkit\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.width = size.x;\r\n\t\troot.height = size.y;\r\n\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\treturn [a, b];\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\treturn false;\r\n\t\t\t// other cases\r\n\t\t\t} else {\r\n\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\ta = p;\r\n\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb = p;\r\n\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t} else if (code & 2) { // right\r\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t} else if (code & 1) { // left\r\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t},\r\n\r\n\toptions: {\r\n\t\t// how much to simplify the polyline on each zoom level\r\n\t\t// more = better performance and smoother look, less = more accurate\r\n\t\tsmoothFactor: 1.0,\r\n\t\tnoClip: false\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._originalPoints = [];\r\n\r\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\tgetLatLngs: function () {\r\n\t\treturn this._latlngs;\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\taddLatLng: function (latlng) {\r\n\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\tthis.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclosestLayerPoint: function (p) {\r\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\tvar points = parts[j];\r\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\tp2 = points[i];\r\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (minPoint) {\r\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t}\r\n\t\treturn minPoint;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t},\r\n\r\n\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tL.Path.prototype._initEvents.call(this);\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar round = L.Path.VML;\r\n\r\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\tp = points[j];\r\n\t\t\tif (round) {\r\n\t\t\t\tp._round();\r\n\t\t\t}\r\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    len = points.length,\r\n\t\t    i, k, segment;\r\n\r\n\t\tif (this.options.noClip) {\r\n\t\t\tthis._parts = [points];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._parts = [];\r\n\r\n\t\tvar parts = this._parts,\r\n\t\t    vp = this._map._pathViewport,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\tif (!segment) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tparts[k] = parts[k] || [];\r\n\t\t\tparts[k].push(segment[0]);\r\n\r\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// simplify each clipped part of the polyline\r\n\t_simplifyPoints: function () {\r\n\t\tvar parts = this._parts,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._clipPoints();\r\n\t\tthis._simplifyPoints();\r\n\r\n\t\tL.Path.prototype._updatePath.call(this);\r\n\t}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n\treturn new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\tthis._initWithHoles(latlngs);\r\n\t},\r\n\r\n\t_initWithHoles: function (latlngs) {\r\n\t\tvar i, len, hole;\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\tthis._holes = latlngs.slice(1);\r\n\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\thole.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// filter out last point if its equal to the first one\r\n\t\tlatlngs = this._latlngs;\r\n\r\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\tlatlngs.pop();\r\n\t\t}\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n\t\t// project polygon holes points\r\n\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\tthis._holePoints = [];\r\n\r\n\t\tif (!this._holes) { return; }\r\n\r\n\t\tvar i, j, len, len2;\r\n\r\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\tthis._holePoints[i] = [];\r\n\r\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t} else {\r\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    newParts = [];\r\n\r\n\t\tthis._parts = [points].concat(this._holePoints);\r\n\r\n\t\tif (this.options.noClip) { return; }\r\n\r\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\tif (clipped.length) {\r\n\t\t\t\tnewParts.push(clipped);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._parts = newParts;\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n\treturn new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n\tfunction createMulti(Klass) {\r\n\r\n\t\treturn L.FeatureGroup.extend({\r\n\r\n\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\tthis._layers = {};\r\n\t\t\t\tthis._options = options;\r\n\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t},\r\n\r\n\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\tvar i = 0,\r\n\t\t\t\t    len = latlngs.length;\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\twhile (i < len) {\r\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\tgetLatLngs: function () {\r\n\t\t\t\tvar latlngs = [];\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn latlngs;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tL.MultiPolyline = createMulti(L.Polyline);\r\n\tL.MultiPolygon = createMulti(L.Polygon);\r\n\r\n\tL.multiPolyline = function (latlngs, options) {\r\n\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t};\r\n\r\n\tL.multiPolygon = function (latlngs, options) {\r\n\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n\tinitialize: function (latLngBounds, options) {\r\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t},\r\n\r\n\tsetBounds: function (latLngBounds) {\r\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t},\r\n\r\n\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\treturn [\r\n\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\tlatLngBounds.getSouthEast()\r\n\t\t];\r\n\t}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n\treturn new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n\tinitialize: function (latlng, radius, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis._mRadius = radius;\r\n\t},\r\n\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis._mRadius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latlng = this._latlng,\r\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t    latlng = this._latlng;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tvar p = this._point,\r\n\t\t    r = this._radius;\r\n\r\n\t\tif (this._checkIfEmpty()) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tif (L.Browser.svg) {\r\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t} else {\r\n\t\t\tp._round();\r\n\t\t\tr = Math.round(r);\r\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._mRadius;\r\n\t},\r\n\r\n\t// TODO Earth hardcoded, move into projection code!\r\n\r\n\t_getLatRadius: function () {\r\n\t\treturn (this._mRadius / 40075017) * 360;\r\n\t},\r\n\r\n\t_getLngRadius: function () {\r\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar vp = this._map._pathViewport,\r\n\t\t    r = this._radius,\r\n\t\t    p = this._point;\r\n\r\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n\treturn new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n\toptions: {\r\n\t\tradius: 10,\r\n\t\tweight: 2\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\tthis._radius = this.options.radius;\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t},\r\n\r\n\t_updateStyle : function () {\r\n\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\tthis.setRadius(this.options.radius);\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis.options.radius = this._radius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._radius;\r\n\t}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n\treturn new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p, closed) {\r\n\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t    w = this.options.weight / 2;\r\n\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p) {\r\n\t\tvar inside = false,\r\n\t\t    part, p1, p2,\r\n\t\t    i, j, k,\r\n\t\t    len, len2;\r\n\r\n\t\t// TODO optimization: check if within bounds first\r\n\r\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t// click on polygon border\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// ray casting algorithm for detecting if point is in polygon\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tp1 = part[j];\r\n\t\t\t\tp2 = part[k];\r\n\r\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn inside;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t_drawPath: function () {\r\n\t\tvar p = this._point;\r\n\t\tthis._ctx.beginPath();\r\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t},\r\n\r\n\t_containsPoint: function (p) {\r\n\t\tvar center = this._point,\r\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\tvar style = this.options.style;\r\n\t\tif (style) {\r\n\t\t\t// reset any custom styles\r\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry.coordinates,\r\n\t\t    layers = [],\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'Polygon':\r\n\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\tvar latlng, i, len,\r\n\t\t    latlngs = [];\r\n\r\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\tvar coords = [latlng.lng, latlng.lat];\r\n\r\n\t\tif (latlng.alt !== undefined) {\r\n\t\t\tcoords.push(latlng.alt);\r\n\t\t}\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latLngs) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'LineString',\r\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t});\r\n\t}\r\n});\r\n\r\nL.Polygon.include({\r\n\ttoGeoJSON: function () {\r\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t    i, len, hole;\r\n\r\n\t\tcoords[0].push(coords[0][0]);\r\n\r\n\t\tif (this._holes) {\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\thole.push(hole[0]);\r\n\t\t\t\tcoords.push(hole);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Polygon',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t}\r\n});\r\n\r\n(function () {\r\n\tfunction multiToGeoJSON(type) {\r\n\t\treturn function () {\r\n\t\t\tvar coords = [];\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t});\r\n\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n\tL.LayerGroup.include({\r\n\t\ttoGeoJSON: function () {\r\n\r\n\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\tjsons = [],\r\n\t\t\t\tjson;\r\n\r\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t}\r\n\r\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (isGeometryCollection) {\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\tfeatures: jsons\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler, originalHandler, newType;\r\n\r\n\t\tif (obj[key]) { return this; }\r\n\r\n\t\thandler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t};\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t}\r\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t}\r\n\r\n\t\tif ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\r\n\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler = obj[key];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t}\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t}\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t.on(el, 'dblclick', stop);\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_checkMouse: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t_getEvent: function () { // evil magic for IE\r\n\t\t/*jshint noarg:false */\r\n\t\tvar e = window.event;\r\n\t\tif (!e) {\r\n\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\twhile (caller) {\r\n\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcaller = caller.caller;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn e;\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\treturn handler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n\t\tL.DomEvent.stopPropagation(e);\r\n\r\n\t\tif (L.Draggable._disabled) { return; }\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tthis.fire('predrag');\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag');\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t}\r\n});\r\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250,\r\n\t\t    touch,\r\n\t\t    pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend,\r\n\t\t    trackedTouches = [];\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\t\t\tif (count > 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t\tdelta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd(e) {\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (doubleTap) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\tprop;\r\n\r\n\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_';\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\tfalse);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveFrom: function (map) {\r\n\t\tvar pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tcorner.removeChild(this._container);\r\n\t\tthis._map = null;\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(map);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.removeFrom(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tthis._container.removeChild(this._controlContainer);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n\t\tthis._map = map;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(\r\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\tthis._zoomOutButton = this._createButton(\r\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'click', stop)\r\n\t\t    .on(link, 'mousedown', stop)\r\n\t\t    .on(link, 'dblclick', stop)\r\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t    .on(link, 'click', fn, context)\r\n\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t\tclassName = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t    .off('layerremove', this._onLayerRemove);\r\n\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t},\r\n\r\n\t_onLayerAdd: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t},\r\n\r\n\t_onLayerRemove: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t    .on('layerremove', this._onLayerChange, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\t\tdelete this._layers[id];\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t.disableScrollPropagation(container);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t}\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList.innerHTML = '';\r\n\t\tthis._overlaysList.innerHTML = '';\r\n\r\n\t\tvar baseLayersPresent = false,\r\n\t\t    overlaysPresent = false,\r\n\t\t    i, obj;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\r\n\t\tif (!obj) { return; }\r\n\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\tif (checked) {\r\n\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t}\r\n\t\tradioHtml += '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    input,\r\n\t\t    checked = this._map.hasLayer(obj.layer);\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\tlabel.appendChild(input);\r\n\t\tlabel.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar i, input, obj,\r\n\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t    inputsLen = inputs.length;\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tobj = this._layers[input.layerId];\r\n\r\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.addLayer(obj.layer);\r\n\r\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = false;\n\t\t\t}\n\t\t}, this);\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\twatch: false,\r\n\t\tsetView: false,\r\n\t\tmaxZoom: Infinity,\r\n\t\ttimeout: 10000,\r\n\t\tmaximumAge: 0,\r\n\t\tenableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (/*Object*/ options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n\t\tif (!navigator.geolocation) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\r\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n\t\t    bounds = L.latLngBounds(\r\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\tthis.setView(latlng, zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));\n},{}],2:[function(require,module,exports){\n/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.3.0\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n'use strict';\n\n(function (window, document) {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element.constructor instanceof window.SVGElement || /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage. \n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n    elements = svg.querySelectorAll(this.TYPES.join(','));\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {};\n  newElement.d = 'M' + element.x1 + ',' + element.y1 + 'L' + element.x2 + ',' + element.y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n    x = parseFloat(element.x) || 0,\n    y = parseFloat(element.y) || 0,\n    width = parseFloat(element.width) || 0,\n    height = parseFloat(element.height) || 0;\n  newElement.d  = 'M' + x + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + (y + height) + ' ';\n  newElement.d += 'L' + x + ' ' + (y + height) + ' Z';\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var i, path;\n  var newElement = {};\n  var points = element.points.trim().split(' ');\n  \n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var startX = element.cx - element.rx,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.rx),\n      endY = element.cy;\n\n  var newElement = {};\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {};\n  var startX = element.cx - element.r,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.r),\n      endY = element.cy;\n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'async'|'oneByOne'|'script' (to know if the item must be drawn asynchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'async'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus (element, options, callback) {\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n ************************************** \n * \n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR          = function (x) {return x;};\nVivus.EASE            = function (x) {return -Math.cos(x * Math.PI) / 2 + 0.5;};\nVivus.EASE_OUT        = function (x) {return 1 - Math.pow(1-x, 3);};\nVivus.EASE_IN         = function (x) {return Math.pow(x, 3);};\nVivus.EASE_OUT_BOUNCE = function (x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base,1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI) )) + 1;\n  return (1- rateR) + (progress * rateR);\n};\n\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function (element, options) {\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Vivus [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  this.parentEl = element;\n\n  // Create the object element if the property `file` exists in the options object\n  if (options && options.file) {\n    var objElm = document.createElement('object');\n    objElm.setAttribute('type', 'image/svg+xml');\n    objElm.setAttribute('data', options.file);\n    objElm.setAttribute('built-by-vivus', 'true');\n    element.appendChild(objElm);\n    element = objElm;\n  }\n\n  switch (element.constructor) {\n  case window.SVGSVGElement:\n  case window.SVGElement:\n    this.el = element;\n    this.isReady = true;\n    break;\n\n  case window.HTMLObjectElement:\n    // If we have to wait for it\n    var onLoad, self;\n    \n    self = this;\n    onLoad = function (e) {\n      if (self.isReady) {\n        return;\n      }\n      self.el = element.contentDocument && element.contentDocument.querySelector('svg');\n      if (!self.el && e) {\n        throw new Error('Vivus [constructor]: object loaded does not contain any SVG');\n      }\n      else if (self.el) {\n        if (element.getAttribute('built-by-vivus')) {\n          self.parentEl.insertBefore(self.el, element);\n          self.parentEl.removeChild(element);\n          self.el.setAttribute('width', '100%');\n          self.el.setAttribute('height', '100%');\n        }\n        self.isReady = true;\n        self.init();\n        return true;\n      }\n    };\n\n    if (!onLoad()) {\n      element.addEventListener('load', onLoad);\n    }\n    break;\n\n  default:\n    throw new Error('Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)');\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function (options) {\n  var allowedTypes = ['delayed', 'async', 'oneByOne', 'scenario', 'scenario-sync'];\n  var allowedStarts =  ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error('Vivus [constructor]: \"options\" parameter must be an object');\n  }\n  else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.type + ' is not an existing animation `type`');\n  }\n  else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.start + ' is not an existing `start` option');\n  }\n  else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE        = (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.userAgent.indexOf('Trident/') !== -1 || window.navigator.userAgent.indexOf('Edge/') !== -1 );\n  this.duration    = parsePositiveInt(options.duration, 120);\n  this.delay       = parsePositiveInt(options.delay, null);\n  this.dashGap     = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender') ? !!options.forceRender : this.isIE;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady     = options.onReady;\n  this.frameLength = this.currentFrame = this.map = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible') ? !!options.ignoreInvisible : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function (callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error('Vivus [constructor]: \"callback\" parameter must be a function');\n  }\n  this.callback = callback || function () {};\n};\n\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function () {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n    pathObj = {\n      el: path,\n      length: Math.ceil(path.getTotalLength())\n    };\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn('Vivus [mapping]: cannot retrieve a path element length', path);\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray  = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n    case 'delayed':\n      pathObj.startAt = this.delayUnit * i;\n      pathObj.duration = this.duration - this.delay;\n      break;\n\n    case 'oneByOne':\n      pathObj.startAt = lengthMeter / totalLength * this.duration;\n      pathObj.duration = pathObj.length / totalLength * this.duration;\n      break;\n\n    case 'async':\n      pathObj.startAt = 0;\n      pathObj.duration = this.duration;\n      break;\n\n    case 'scenario-sync':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = timePoint + (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      timePoint = pAttrs['data-async'] !== undefined ? pathObj.startAt : pathObj.startAt + pathObj.duration;\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n\n    case 'scenario':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.drawer = function () {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n    this.callback(this);\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n    this.callback(this);\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function () {\n      self.drawer();\n    });\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function () {\n  var i, progress, path, currentFrame;\n  currentFrame = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n * \n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function (index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n        newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n * \n */\nVivus.prototype.init = function () {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function () {\n  switch (this.start) {\n  case 'manual':\n    return;\n\n  case 'autostart':\n    this.play();\n    break;\n\n  case 'inViewport':\n    var self = this,\n    listener = function () {\n      if (self.isInViewport(self.parentEl, 1)) {\n        self.play();\n        window.removeEventListener('scroll', listener);\n      }\n    };\n    window.addEventListener('scroll', listener);\n    listener();\n    break;\n  }\n};\n\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function () {\n  return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function () {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function () {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n * \n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function (progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function (speed) {\n  if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.drawer();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function () {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function () {\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function (el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  }\n  else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function (el, h) {\n  var scrolled   = this.scrollY(),\n    viewed       = scrolled + this.getViewportH(),\n    elBCR        = el.getBoundingClientRect(),\n    elHeight     = elBCR.height,\n    elTop        = scrolled + elBCR.top,\n    elBottom     = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return (elTop + elHeight * h) <= viewed && (elBottom) >= scrolled;\n};\n\n/**\n * Alias for document element\n *\n * @type {DOMelement}\n */\nVivus.prototype.docElem = window.document.documentElement;\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function () {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  }\n  else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function () {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\n/**\n * Alias for `requestAnimationFrame` or\n * `setTimeout` function for deprecated browsers.\n *\n */\nrequestAnimFrame = (function () {\n  return (\n    window.requestAnimationFrame       ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame    ||\n    window.oRequestAnimationFrame      ||\n    window.msRequestAnimationFrame     ||\n    function(/* function */ callback){\n      return window.setTimeout(callback, 1000 / 60);\n    }\n  );\n})();\n\n/**\n * Alias for `cancelAnimationFrame` or\n * `cancelTimeout` function for deprecated browsers.\n *\n */\ncancelAnimFrame = (function () {\n  return (\n    window.cancelAnimationFrame       ||\n    window.webkitCancelAnimationFrame ||\n    window.mozCancelAnimationFrame    ||\n    window.oCancelAnimationFrame      ||\n    window.msCancelAnimationFrame     ||\n    function(id){\n      return window.clearTimeout(id);\n    }\n  );\n})();\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function (value, defaultValue) {\n  var output = parseInt(value, 10);\n  return (output >= 0) ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}(window, document));\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar btns = { 'btn-home': document.getElementById('home'),\n  'btn-about': document.getElementById('about'),\n  'btn-projects': document.getElementById('projects'),\n  'btn-contact': document.getElementById('contact')\n};\nfunction smoothScroll(time) {\n  function animate(e) {\n    // smooth scrolling from @rahul_send89 function\n    // http://stackoverflow.com/a/26094310/1405004\n    var elem = btns[e.target.id];\n    var to = elem.offsetTop;\n    var from = window.scrollY;\n    var start = new Date().getTime(),\n        timer = setInterval(function () {\n      var step = Math.min(1, (new Date().getTime() - start) / time);\n      window.scrollTo(0, from + step * (to - from) + 1);\n      if (step === 1) {\n        clearInterval(timer);\n      }\n    }, 25);\n    window.scrollTo(0, from + 1);\n  }\n  return animate;\n}\n\n(function () {\n  var Vivus = require('vivus');\n  var L = require('leaflet');\n\n  // Hola! svg drawing animation\n  var paths = document.getElementById('paths');\n  var greeting = new Vivus('greeting', {\n    type: \"oneByOne\",\n    pathTimingFunction: Vivus.LINEAR,\n    animTimingFunction: Vivus.LINEAR\n  }, function () {\n    paths.classList.add('drawn');\n  });\n  greeting.play(1);\n\n  // render the map of contact section\n  var map = L.map('map').setView([37.9410106, -1.1398814], 11);\n  L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoianVhbnJpcWdvbiIsImEiOiJjaWs5MGR2bTAwMDA4d2xsdjNwOXQ3eXQ1In0.Y7PbFkq-Wxa2Kn5O1CWgUg', {\n    attribution: 'Map data &copy; <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, Imagery  <a href=\"http://mapbox.com\">Mapbox</a>',\n    maxZoom: 18,\n    id: 'juanriqgon.p2ln61p7',\n    accessToken: 'pk.eyJ1IjoianVhbnJpcWdvbiIsImEiOiJjaWs5MGR2bTAwMDA4d2xsdjNwOXQ3eXQ1In0.Y7PbFkq-Wxa2Kn5O1CWgUg'\n  }).addTo(map);\n  L.Icon.Default.imagePath = '../assets/images';\n  var marker = L.marker([37.9410106, -1.1398814]).addTo(map);\n  marker.bindPopup(\"I live around here.\").openPopup();\n\n  // render the contact form\n  var contactWays = document.getElementById('contact-ways');\n  var contactForm = '<form class=\"contact-form\" action=\"http://pooleapp.com/stash/52a1c0eb-dcc6-45b9-8923-73309fbb729b/\" method=\"post\">\\n\\t<input type=\"hidden\" name=\"redirect_to\" value=\"{YOUR-THANKS-PAGE}\" />\\n\\t<p>\\n\\t\\t<label for=\"name\">Name\\n\\t\\t\\t<input class=\"contact-field\" type=\"text\" name=\"name\" id=\"name\" placeholder=\"What\\'s your name?\" />\\n\\t\\t</label>\\n\\t</p>\\n\\t<p>\\n\\t\\t<label for=\"e-mail\">E-mail\\n\\t\\t\\t<input class=\"contact-field\" type=\"email\" name=\"email\" id=\"email\" placeholder=\"An email to answer you\">\\n\\t\\t</label>\\n\\t</p>\\n\\t<p>\\n\\t\\t<label for=\"message\">Message\\n\\t\\t\\t<textarea class=\"message\" id=\"message\" name=\"message\" rows=\"5\" placeholder=\"Your message\"></textarea>\\n\\t\\t</label>\\n\\t</p>\\n\\t<p>\\n\\t\\t<input class=\"submit\" type=\"submit\" value=\"Submit\" />\\n\\t</p>\\n</form>';\n  contactWays.insertAdjacentHTML('beforeend', contactForm);\n\n  // smooth scrolling\n  var btns = document.querySelectorAll('.nav-link>a');\n  for (var i = 0; i < btns.length; i++) {\n    btns[i].addEventListener('click', smoothScroll(200));\n  }\n\n  // menu mobile\n  var mobilemenu = document.getElementById('mobile-menu');\n  var menuMobileContainer = document.getElementById('navbar-mobile-menu-container');\n  function toggleFoldedMenu() {\n    var folded = menuMobileContainer.getAttribute('data-folded');\n    if (folded === 'true') {\n      menuMobileContainer.setAttribute('data-folded', 'false');\n      return;\n    }\n    menuMobileContainer.setAttribute('data-folded', 'true');\n  }\n\n  mobilemenu.addEventListener('click', toggleFoldedMenu);\n})();\n\n},{\"leaflet\":1,\"vivus\":2}]},{},[3])\n\n","/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.3.0\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n'use strict';\n\n(function (window, document) {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element.constructor instanceof window.SVGElement || /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage. \n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n    elements = svg.querySelectorAll(this.TYPES.join(','));\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {};\n  newElement.d = 'M' + element.x1 + ',' + element.y1 + 'L' + element.x2 + ',' + element.y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n    x = parseFloat(element.x) || 0,\n    y = parseFloat(element.y) || 0,\n    width = parseFloat(element.width) || 0,\n    height = parseFloat(element.height) || 0;\n  newElement.d  = 'M' + x + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + (y + height) + ' ';\n  newElement.d += 'L' + x + ' ' + (y + height) + ' Z';\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var i, path;\n  var newElement = {};\n  var points = element.points.trim().split(' ');\n  \n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var startX = element.cx - element.rx,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.rx),\n      endY = element.cy;\n\n  var newElement = {};\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {};\n  var startX = element.cx - element.r,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.r),\n      endY = element.cy;\n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'async'|'oneByOne'|'script' (to know if the item must be drawn asynchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'async'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus (element, options, callback) {\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n ************************************** \n * \n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR          = function (x) {return x;};\nVivus.EASE            = function (x) {return -Math.cos(x * Math.PI) / 2 + 0.5;};\nVivus.EASE_OUT        = function (x) {return 1 - Math.pow(1-x, 3);};\nVivus.EASE_IN         = function (x) {return Math.pow(x, 3);};\nVivus.EASE_OUT_BOUNCE = function (x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base,1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI) )) + 1;\n  return (1- rateR) + (progress * rateR);\n};\n\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function (element, options) {\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Vivus [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  this.parentEl = element;\n\n  // Create the object element if the property `file` exists in the options object\n  if (options && options.file) {\n    var objElm = document.createElement('object');\n    objElm.setAttribute('type', 'image/svg+xml');\n    objElm.setAttribute('data', options.file);\n    objElm.setAttribute('built-by-vivus', 'true');\n    element.appendChild(objElm);\n    element = objElm;\n  }\n\n  switch (element.constructor) {\n  case window.SVGSVGElement:\n  case window.SVGElement:\n    this.el = element;\n    this.isReady = true;\n    break;\n\n  case window.HTMLObjectElement:\n    // If we have to wait for it\n    var onLoad, self;\n    \n    self = this;\n    onLoad = function (e) {\n      if (self.isReady) {\n        return;\n      }\n      self.el = element.contentDocument && element.contentDocument.querySelector('svg');\n      if (!self.el && e) {\n        throw new Error('Vivus [constructor]: object loaded does not contain any SVG');\n      }\n      else if (self.el) {\n        if (element.getAttribute('built-by-vivus')) {\n          self.parentEl.insertBefore(self.el, element);\n          self.parentEl.removeChild(element);\n          self.el.setAttribute('width', '100%');\n          self.el.setAttribute('height', '100%');\n        }\n        self.isReady = true;\n        self.init();\n        return true;\n      }\n    };\n\n    if (!onLoad()) {\n      element.addEventListener('load', onLoad);\n    }\n    break;\n\n  default:\n    throw new Error('Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)');\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function (options) {\n  var allowedTypes = ['delayed', 'async', 'oneByOne', 'scenario', 'scenario-sync'];\n  var allowedStarts =  ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error('Vivus [constructor]: \"options\" parameter must be an object');\n  }\n  else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.type + ' is not an existing animation `type`');\n  }\n  else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.start + ' is not an existing `start` option');\n  }\n  else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE        = (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.userAgent.indexOf('Trident/') !== -1 || window.navigator.userAgent.indexOf('Edge/') !== -1 );\n  this.duration    = parsePositiveInt(options.duration, 120);\n  this.delay       = parsePositiveInt(options.delay, null);\n  this.dashGap     = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender') ? !!options.forceRender : this.isIE;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady     = options.onReady;\n  this.frameLength = this.currentFrame = this.map = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible') ? !!options.ignoreInvisible : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function (callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error('Vivus [constructor]: \"callback\" parameter must be a function');\n  }\n  this.callback = callback || function () {};\n};\n\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function () {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n    pathObj = {\n      el: path,\n      length: Math.ceil(path.getTotalLength())\n    };\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn('Vivus [mapping]: cannot retrieve a path element length', path);\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray  = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n    case 'delayed':\n      pathObj.startAt = this.delayUnit * i;\n      pathObj.duration = this.duration - this.delay;\n      break;\n\n    case 'oneByOne':\n      pathObj.startAt = lengthMeter / totalLength * this.duration;\n      pathObj.duration = pathObj.length / totalLength * this.duration;\n      break;\n\n    case 'async':\n      pathObj.startAt = 0;\n      pathObj.duration = this.duration;\n      break;\n\n    case 'scenario-sync':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = timePoint + (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      timePoint = pAttrs['data-async'] !== undefined ? pathObj.startAt : pathObj.startAt + pathObj.duration;\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n\n    case 'scenario':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.drawer = function () {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n    this.callback(this);\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n    this.callback(this);\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function () {\n      self.drawer();\n    });\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function () {\n  var i, progress, path, currentFrame;\n  currentFrame = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n * \n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function (index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n        newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n * \n */\nVivus.prototype.init = function () {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function () {\n  switch (this.start) {\n  case 'manual':\n    return;\n\n  case 'autostart':\n    this.play();\n    break;\n\n  case 'inViewport':\n    var self = this,\n    listener = function () {\n      if (self.isInViewport(self.parentEl, 1)) {\n        self.play();\n        window.removeEventListener('scroll', listener);\n      }\n    };\n    window.addEventListener('scroll', listener);\n    listener();\n    break;\n  }\n};\n\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function () {\n  return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function () {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function () {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n * \n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function (progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function (speed) {\n  if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.drawer();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function () {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function () {\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function (el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  }\n  else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function (el, h) {\n  var scrolled   = this.scrollY(),\n    viewed       = scrolled + this.getViewportH(),\n    elBCR        = el.getBoundingClientRect(),\n    elHeight     = elBCR.height,\n    elTop        = scrolled + elBCR.top,\n    elBottom     = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return (elTop + elHeight * h) <= viewed && (elBottom) >= scrolled;\n};\n\n/**\n * Alias for document element\n *\n * @type {DOMelement}\n */\nVivus.prototype.docElem = window.document.documentElement;\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function () {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  }\n  else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function () {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\n/**\n * Alias for `requestAnimationFrame` or\n * `setTimeout` function for deprecated browsers.\n *\n */\nrequestAnimFrame = (function () {\n  return (\n    window.requestAnimationFrame       ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame    ||\n    window.oRequestAnimationFrame      ||\n    window.msRequestAnimationFrame     ||\n    function(/* function */ callback){\n      return window.setTimeout(callback, 1000 / 60);\n    }\n  );\n})();\n\n/**\n * Alias for `cancelAnimationFrame` or\n * `cancelTimeout` function for deprecated browsers.\n *\n */\ncancelAnimFrame = (function () {\n  return (\n    window.cancelAnimationFrame       ||\n    window.webkitCancelAnimationFrame ||\n    window.mozCancelAnimationFrame    ||\n    window.oCancelAnimationFrame      ||\n    window.msCancelAnimationFrame     ||\n    function(id){\n      return window.clearTimeout(id);\n    }\n  );\n})();\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function (value, defaultValue) {\n  var output = parseInt(value, 10);\n  return (output >= 0) ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}(window, document));\n","var btns = {'btn-home': document.getElementById('home'),\n            'btn-about': document.getElementById('about'),\n            'btn-projects': document.getElementById('projects'),\n            'btn-contact': document.getElementById('contact')\n            };\nfunction smoothScroll(time) {\n  function animate(e) {\n    // smooth scrolling from @rahul_send89 function\n    // http://stackoverflow.com/a/26094310/1405004\n    var elem = btns[e.target.id];\n    var to = elem.offsetTop;\n    var from = window.scrollY;\n    var start = new Date().getTime(),\n        timer = setInterval(function() {\n          var step = Math.min(1,(new Date().getTime()-start)/time);\n              window.scrollTo(0,(from+step*(to-from))+1);\n              if( step === 1){\n                clearInterval(timer);\n              }\n        },25);\n        window.scrollTo(0,(from+1));\n  }\n  return animate;\n}\n\n\n(function(){\n  var Vivus = require('vivus');\n  var L = require('leaflet');\n\n  // Hola! svg drawing animation\n  var paths = document.getElementById('paths');\n  var greeting = new Vivus('greeting',  {\n    type: \"oneByOne\",\n    pathTimingFunction: Vivus.LINEAR,\n\t\tanimTimingFunction: Vivus.LINEAR\n  }, function () {\n    paths.classList.add('drawn');\n  });\n  greeting.play(1);\n\n  // render the map of contact section\n  var map = L.map('map').setView([37.9410106, -1.1398814], 11);\n  L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoianVhbnJpcWdvbiIsImEiOiJjaWs5MGR2bTAwMDA4d2xsdjNwOXQ3eXQ1In0.Y7PbFkq-Wxa2Kn5O1CWgUg', {\n    attribution: 'Map data &copy; <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, Imagery  <a href=\"http://mapbox.com\">Mapbox</a>',\n    maxZoom: 18,\n    id: 'juanriqgon.p2ln61p7',\n    accessToken: 'pk.eyJ1IjoianVhbnJpcWdvbiIsImEiOiJjaWs5MGR2bTAwMDA4d2xsdjNwOXQ3eXQ1In0.Y7PbFkq-Wxa2Kn5O1CWgUg'\n  }).addTo(map);\n  L.Icon.Default.imagePath = '../assets/images';\n  var marker = L.marker([37.9410106, -1.1398814]).addTo(map);\n  marker.bindPopup(\"I live around here.\").openPopup();\n\n  // render the contact form\n  var contactWays = document.getElementById('contact-ways');\n  var contactForm = '<form class=\"contact-form\" action=\"http://pooleapp.com/stash/52a1c0eb-dcc6-45b9-8923-73309fbb729b/\" method=\"post\">\\n\\t<input type=\"hidden\" name=\"redirect_to\" value=\"{YOUR-THANKS-PAGE}\" />\\n\\t<p>\\n\\t\\t<label for=\"name\">Name\\n\\t\\t\\t<input class=\"contact-field\" type=\"text\" name=\"name\" id=\"name\" placeholder=\"What\\'s your name?\" />\\n\\t\\t</label>\\n\\t</p>\\n\\t<p>\\n\\t\\t<label for=\"e-mail\">E-mail\\n\\t\\t\\t<input class=\"contact-field\" type=\"email\" name=\"email\" id=\"email\" placeholder=\"An email to answer you\">\\n\\t\\t</label>\\n\\t</p>\\n\\t<p>\\n\\t\\t<label for=\"message\">Message\\n\\t\\t\\t<textarea class=\"message\" id=\"message\" name=\"message\" rows=\"5\" placeholder=\"Your message\"></textarea>\\n\\t\\t</label>\\n\\t</p>\\n\\t<p>\\n\\t\\t<input class=\"submit\" type=\"submit\" value=\"Submit\" />\\n\\t</p>\\n</form>';\n  contactWays.insertAdjacentHTML('beforeend', contactForm);\n\n  // smooth scrolling\n  var btns = document.querySelectorAll('.nav-link>a');\n  for (let i = 0; i < btns.length; i++) {\n    btns[i].addEventListener('click', smoothScroll(200));\n  }\n\n  // menu mobile\n  var mobilemenu = document.getElementById('mobile-menu');\n  var menuMobileContainer = document.getElementById('navbar-mobile-menu-container');\n  function toggleFoldedMenu() {\n    var folded = menuMobileContainer.getAttribute('data-folded');\n    if (folded === 'true') {\n      menuMobileContainer.setAttribute('data-folded', 'false');\n      return;\n    }\n    menuMobileContainer.setAttribute('data-folded', 'true');\n  }\n\n  mobilemenu.addEventListener('click', toggleFoldedMenu);\n})();"],"sourceRoot":"/source/"}