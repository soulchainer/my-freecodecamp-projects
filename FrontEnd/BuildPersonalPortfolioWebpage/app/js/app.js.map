{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/vivus/dist/vivus.js","app.js","src/js/app.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","window","document","Pathformer","element","constructor","String","getElementById","SVGElement","test","nodeName","this","el","scan","Vivus","options","callback","isReady","setElement","setOptions","setCallback","init","prototype","TYPES","ATTR_WATCH","svg","fn","pathData","pathDom","elements","querySelectorAll","join","tagName","toLowerCase","parseAttr","attributes","pathMaker","parentNode","replaceChild","lineToPath","newElement","d","x1","y1","x2","y2","rectToPath","x","parseFloat","y","width","height","polylineToPath","path","points","trim","split","indexOf","formattedPoints","push","polygonToPath","ellipseToPath","startX","cx","rx","startY","cy","endX","endY","ry","circleToPath","attr","pathTag","createElementNS","name","setAttribute","value","output","requestAnimFrame","cancelAnimFrame","parsePositiveInt","LINEAR","EASE","Math","cos","PI","EASE_OUT","pow","EASE_IN","EASE_OUT_BOUNCE","base","rate","rateR","progress","abs","parentEl","file","objElm","createElement","appendChild","SVGSVGElement","HTMLObjectElement","onLoad","self","contentDocument","querySelector","getAttribute","insertBefore","removeChild","addEventListener","allowedTypes","allowedStarts","undefined","Object","type","start","isIE","navigator","userAgent","duration","delay","dashGap","forceRender","hasOwnProperty","selfDestroy","onReady","frameLength","currentFrame","map","delayUnit","speed","handle","ignoreInvisible","animTimingFunction","pathTimingFunction","Function","mapping","paths","pAttrs","pathObj","totalLength","lengthMeter","timePoint","isInvisible","ceil","getTotalLength","isNaN","console","warn","style","strokeDasharray","strokeDashoffset","renderPath","startAt","max","drawer","stop","reset","trace","destroy","min","floor","index","newPath","cloneNode","starter","play","listener","isInViewport","removeEventListener","getStatus","setFrameProgress","finish","round","rect","ignoreAttr","getBoundingClientRect","h","scrolled","scrollY","viewed","getViewportH","elBCR","elHeight","elTop","top","elBottom","docElem","documentElement","client","clientHeight","inner","innerHeight","pageYOffset","scrollTop","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","defaultValue","parseInt","define","amd",2,"greeting","classList","add","vivus"],"mappings":"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","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.3.0\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n'use strict';\n\n(function (window, document) {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element.constructor instanceof window.SVGElement || /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage. \n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n    elements = svg.querySelectorAll(this.TYPES.join(','));\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {};\n  newElement.d = 'M' + element.x1 + ',' + element.y1 + 'L' + element.x2 + ',' + element.y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n    x = parseFloat(element.x) || 0,\n    y = parseFloat(element.y) || 0,\n    width = parseFloat(element.width) || 0,\n    height = parseFloat(element.height) || 0;\n  newElement.d  = 'M' + x + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + (y + height) + ' ';\n  newElement.d += 'L' + x + ' ' + (y + height) + ' Z';\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var i, path;\n  var newElement = {};\n  var points = element.points.trim().split(' ');\n  \n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var startX = element.cx - element.rx,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.rx),\n      endY = element.cy;\n\n  var newElement = {};\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {};\n  var startX = element.cx - element.r,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.r),\n      endY = element.cy;\n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'async'|'oneByOne'|'script' (to know if the item must be drawn asynchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'async'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus (element, options, callback) {\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n ************************************** \n * \n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR          = function (x) {return x;};\nVivus.EASE            = function (x) {return -Math.cos(x * Math.PI) / 2 + 0.5;};\nVivus.EASE_OUT        = function (x) {return 1 - Math.pow(1-x, 3);};\nVivus.EASE_IN         = function (x) {return Math.pow(x, 3);};\nVivus.EASE_OUT_BOUNCE = function (x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base,1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI) )) + 1;\n  return (1- rateR) + (progress * rateR);\n};\n\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function (element, options) {\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Vivus [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  this.parentEl = element;\n\n  // Create the object element if the property `file` exists in the options object\n  if (options && options.file) {\n    var objElm = document.createElement('object');\n    objElm.setAttribute('type', 'image/svg+xml');\n    objElm.setAttribute('data', options.file);\n    objElm.setAttribute('built-by-vivus', 'true');\n    element.appendChild(objElm);\n    element = objElm;\n  }\n\n  switch (element.constructor) {\n  case window.SVGSVGElement:\n  case window.SVGElement:\n    this.el = element;\n    this.isReady = true;\n    break;\n\n  case window.HTMLObjectElement:\n    // If we have to wait for it\n    var onLoad, self;\n    \n    self = this;\n    onLoad = function (e) {\n      if (self.isReady) {\n        return;\n      }\n      self.el = element.contentDocument && element.contentDocument.querySelector('svg');\n      if (!self.el && e) {\n        throw new Error('Vivus [constructor]: object loaded does not contain any SVG');\n      }\n      else if (self.el) {\n        if (element.getAttribute('built-by-vivus')) {\n          self.parentEl.insertBefore(self.el, element);\n          self.parentEl.removeChild(element);\n          self.el.setAttribute('width', '100%');\n          self.el.setAttribute('height', '100%');\n        }\n        self.isReady = true;\n        self.init();\n        return true;\n      }\n    };\n\n    if (!onLoad()) {\n      element.addEventListener('load', onLoad);\n    }\n    break;\n\n  default:\n    throw new Error('Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)');\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function (options) {\n  var allowedTypes = ['delayed', 'async', 'oneByOne', 'scenario', 'scenario-sync'];\n  var allowedStarts =  ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error('Vivus [constructor]: \"options\" parameter must be an object');\n  }\n  else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.type + ' is not an existing animation `type`');\n  }\n  else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.start + ' is not an existing `start` option');\n  }\n  else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE        = (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.userAgent.indexOf('Trident/') !== -1 || window.navigator.userAgent.indexOf('Edge/') !== -1 );\n  this.duration    = parsePositiveInt(options.duration, 120);\n  this.delay       = parsePositiveInt(options.delay, null);\n  this.dashGap     = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender') ? !!options.forceRender : this.isIE;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady     = options.onReady;\n  this.frameLength = this.currentFrame = this.map = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible') ? !!options.ignoreInvisible : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function (callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error('Vivus [constructor]: \"callback\" parameter must be a function');\n  }\n  this.callback = callback || function () {};\n};\n\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function () {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n    pathObj = {\n      el: path,\n      length: Math.ceil(path.getTotalLength())\n    };\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn('Vivus [mapping]: cannot retrieve a path element length', path);\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray  = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n    case 'delayed':\n      pathObj.startAt = this.delayUnit * i;\n      pathObj.duration = this.duration - this.delay;\n      break;\n\n    case 'oneByOne':\n      pathObj.startAt = lengthMeter / totalLength * this.duration;\n      pathObj.duration = pathObj.length / totalLength * this.duration;\n      break;\n\n    case 'async':\n      pathObj.startAt = 0;\n      pathObj.duration = this.duration;\n      break;\n\n    case 'scenario-sync':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = timePoint + (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      timePoint = pAttrs['data-async'] !== undefined ? pathObj.startAt : pathObj.startAt + pathObj.duration;\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n\n    case 'scenario':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.drawer = function () {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n    this.callback(this);\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n    this.callback(this);\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function () {\n      self.drawer();\n    });\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function () {\n  var i, progress, path, currentFrame;\n  currentFrame = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n * \n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function (index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n        newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n * \n */\nVivus.prototype.init = function () {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function () {\n  switch (this.start) {\n  case 'manual':\n    return;\n\n  case 'autostart':\n    this.play();\n    break;\n\n  case 'inViewport':\n    var self = this,\n    listener = function () {\n      if (self.isInViewport(self.parentEl, 1)) {\n        self.play();\n        window.removeEventListener('scroll', listener);\n      }\n    };\n    window.addEventListener('scroll', listener);\n    listener();\n    break;\n  }\n};\n\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function () {\n  return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function () {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function () {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n * \n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function (progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function (speed) {\n  if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.drawer();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function () {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function () {\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function (el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  }\n  else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function (el, h) {\n  var scrolled   = this.scrollY(),\n    viewed       = scrolled + this.getViewportH(),\n    elBCR        = el.getBoundingClientRect(),\n    elHeight     = elBCR.height,\n    elTop        = scrolled + elBCR.top,\n    elBottom     = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return (elTop + elHeight * h) <= viewed && (elBottom) >= scrolled;\n};\n\n/**\n * Alias for document element\n *\n * @type {DOMelement}\n */\nVivus.prototype.docElem = window.document.documentElement;\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function () {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  }\n  else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function () {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\n/**\n * Alias for `requestAnimationFrame` or\n * `setTimeout` function for deprecated browsers.\n *\n */\nrequestAnimFrame = (function () {\n  return (\n    window.requestAnimationFrame       ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame    ||\n    window.oRequestAnimationFrame      ||\n    window.msRequestAnimationFrame     ||\n    function(/* function */ callback){\n      return window.setTimeout(callback, 1000 / 60);\n    }\n  );\n})();\n\n/**\n * Alias for `cancelAnimationFrame` or\n * `cancelTimeout` function for deprecated browsers.\n *\n */\ncancelAnimFrame = (function () {\n  return (\n    window.cancelAnimationFrame       ||\n    window.webkitCancelAnimationFrame ||\n    window.mozCancelAnimationFrame    ||\n    window.oCancelAnimationFrame      ||\n    window.msCancelAnimationFrame     ||\n    function(id){\n      return window.clearTimeout(id);\n    }\n  );\n})();\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function (value, defaultValue) {\n  var output = parseInt(value, 10);\n  return (output >= 0) ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}(window, document));\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.3.0\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n'use strict';\n\n(function (window, document) {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element.constructor instanceof window.SVGElement || /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage. \n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n    elements = svg.querySelectorAll(this.TYPES.join(','));\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {};\n  newElement.d = 'M' + element.x1 + ',' + element.y1 + 'L' + element.x2 + ',' + element.y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n    x = parseFloat(element.x) || 0,\n    y = parseFloat(element.y) || 0,\n    width = parseFloat(element.width) || 0,\n    height = parseFloat(element.height) || 0;\n  newElement.d  = 'M' + x + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + y + ' ';\n  newElement.d += 'L' + (x + width) + ' ' + (y + height) + ' ';\n  newElement.d += 'L' + x + ' ' + (y + height) + ' Z';\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var i, path;\n  var newElement = {};\n  var points = element.points.trim().split(' ');\n  \n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var startX = element.cx - element.rx,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.rx),\n      endY = element.cy;\n\n  var newElement = {};\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + element.rx + ',' + element.ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {};\n  var startX = element.cx - element.r,\n      startY = element.cy;\n  var endX = parseFloat(element.cx) + parseFloat(element.r),\n      endY = element.cy;\n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + element.r + ',' + element.r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'async'|'oneByOne'|'script' (to know if the item must be drawn asynchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'async'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus (element, options, callback) {\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n ************************************** \n * \n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR          = function (x) {return x;};\nVivus.EASE            = function (x) {return -Math.cos(x * Math.PI) / 2 + 0.5;};\nVivus.EASE_OUT        = function (x) {return 1 - Math.pow(1-x, 3);};\nVivus.EASE_IN         = function (x) {return Math.pow(x, 3);};\nVivus.EASE_OUT_BOUNCE = function (x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base,1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI) )) + 1;\n  return (1- rateR) + (progress * rateR);\n};\n\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function (element, options) {\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Vivus [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  this.parentEl = element;\n\n  // Create the object element if the property `file` exists in the options object\n  if (options && options.file) {\n    var objElm = document.createElement('object');\n    objElm.setAttribute('type', 'image/svg+xml');\n    objElm.setAttribute('data', options.file);\n    objElm.setAttribute('built-by-vivus', 'true');\n    element.appendChild(objElm);\n    element = objElm;\n  }\n\n  switch (element.constructor) {\n  case window.SVGSVGElement:\n  case window.SVGElement:\n    this.el = element;\n    this.isReady = true;\n    break;\n\n  case window.HTMLObjectElement:\n    // If we have to wait for it\n    var onLoad, self;\n    \n    self = this;\n    onLoad = function (e) {\n      if (self.isReady) {\n        return;\n      }\n      self.el = element.contentDocument && element.contentDocument.querySelector('svg');\n      if (!self.el && e) {\n        throw new Error('Vivus [constructor]: object loaded does not contain any SVG');\n      }\n      else if (self.el) {\n        if (element.getAttribute('built-by-vivus')) {\n          self.parentEl.insertBefore(self.el, element);\n          self.parentEl.removeChild(element);\n          self.el.setAttribute('width', '100%');\n          self.el.setAttribute('height', '100%');\n        }\n        self.isReady = true;\n        self.init();\n        return true;\n      }\n    };\n\n    if (!onLoad()) {\n      element.addEventListener('load', onLoad);\n    }\n    break;\n\n  default:\n    throw new Error('Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)');\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function (options) {\n  var allowedTypes = ['delayed', 'async', 'oneByOne', 'scenario', 'scenario-sync'];\n  var allowedStarts =  ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error('Vivus [constructor]: \"options\" parameter must be an object');\n  }\n  else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.type + ' is not an existing animation `type`');\n  }\n  else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.start + ' is not an existing `start` option');\n  }\n  else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE        = (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.userAgent.indexOf('Trident/') !== -1 || window.navigator.userAgent.indexOf('Edge/') !== -1 );\n  this.duration    = parsePositiveInt(options.duration, 120);\n  this.delay       = parsePositiveInt(options.delay, null);\n  this.dashGap     = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender') ? !!options.forceRender : this.isIE;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady     = options.onReady;\n  this.frameLength = this.currentFrame = this.map = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible') ? !!options.ignoreInvisible : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function (callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error('Vivus [constructor]: \"callback\" parameter must be a function');\n  }\n  this.callback = callback || function () {};\n};\n\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function () {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n    pathObj = {\n      el: path,\n      length: Math.ceil(path.getTotalLength())\n    };\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn('Vivus [mapping]: cannot retrieve a path element length', path);\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray  = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n    case 'delayed':\n      pathObj.startAt = this.delayUnit * i;\n      pathObj.duration = this.duration - this.delay;\n      break;\n\n    case 'oneByOne':\n      pathObj.startAt = lengthMeter / totalLength * this.duration;\n      pathObj.duration = pathObj.length / totalLength * this.duration;\n      break;\n\n    case 'async':\n      pathObj.startAt = 0;\n      pathObj.duration = this.duration;\n      break;\n\n    case 'scenario-sync':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = timePoint + (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      timePoint = pAttrs['data-async'] !== undefined ? pathObj.startAt : pathObj.startAt + pathObj.duration;\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n\n    case 'scenario':\n      path = paths[i];\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.drawer = function () {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n    this.callback(this);\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n    this.callback(this);\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function () {\n      self.drawer();\n    });\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function () {\n  var i, progress, path, currentFrame;\n  currentFrame = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n * \n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function (index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n        newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n * \n */\nVivus.prototype.init = function () {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function () {\n  switch (this.start) {\n  case 'manual':\n    return;\n\n  case 'autostart':\n    this.play();\n    break;\n\n  case 'inViewport':\n    var self = this,\n    listener = function () {\n      if (self.isInViewport(self.parentEl, 1)) {\n        self.play();\n        window.removeEventListener('scroll', listener);\n      }\n    };\n    window.addEventListener('scroll', listener);\n    listener();\n    break;\n  }\n};\n\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function () {\n  return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function () {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function () {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n * \n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function (progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function (speed) {\n  if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.drawer();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function () {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function () {\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function (el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  }\n  else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function (el, h) {\n  var scrolled   = this.scrollY(),\n    viewed       = scrolled + this.getViewportH(),\n    elBCR        = el.getBoundingClientRect(),\n    elHeight     = elBCR.height,\n    elTop        = scrolled + elBCR.top,\n    elBottom     = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return (elTop + elHeight * h) <= viewed && (elBottom) >= scrolled;\n};\n\n/**\n * Alias for document element\n *\n * @type {DOMelement}\n */\nVivus.prototype.docElem = window.document.documentElement;\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function () {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  }\n  else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function () {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\n/**\n * Alias for `requestAnimationFrame` or\n * `setTimeout` function for deprecated browsers.\n *\n */\nrequestAnimFrame = (function () {\n  return (\n    window.requestAnimationFrame       ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame    ||\n    window.oRequestAnimationFrame      ||\n    window.msRequestAnimationFrame     ||\n    function(/* function */ callback){\n      return window.setTimeout(callback, 1000 / 60);\n    }\n  );\n})();\n\n/**\n * Alias for `cancelAnimationFrame` or\n * `cancelTimeout` function for deprecated browsers.\n *\n */\ncancelAnimFrame = (function () {\n  return (\n    window.cancelAnimationFrame       ||\n    window.webkitCancelAnimationFrame ||\n    window.mozCancelAnimationFrame    ||\n    window.oCancelAnimationFrame      ||\n    window.msCancelAnimationFrame     ||\n    function(id){\n      return window.clearTimeout(id);\n    }\n  );\n})();\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function (value, defaultValue) {\n  var output = parseInt(value, 10);\n  return (output >= 0) ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}(window, document));\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\n(function () {\n  var Vivus = require('vivus');\n\n  var paths = document.getElementById('paths');\n  var greeting = new Vivus('greeting', {\n    type: \"oneByOne\",\n    pathTimingFunction: Vivus.LINEAR,\n    animTimingFunction: Vivus.LINEAR\n  }, function () {\n    paths.classList.add('drawn');\n  });\n  greeting.play(1);\n})();\n\n},{\"vivus\":1}]},{},[2])\n\n","(function(){\n  var Vivus = require('vivus');\n\n  var paths = document.getElementById('paths');\n  var greeting = new Vivus('greeting',  {\n    type: \"oneByOne\",\n    pathTimingFunction: Vivus.LINEAR,\n\t\tanimTimingFunction: Vivus.LINEAR\n  }, function () {\n    paths.classList.add('drawn');\n  });\n  greeting.play(1);\n})();"],"sourceRoot":"/source/"}