{"version":3,"sources":["app.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","err","Object","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","threeInARow","row","token","EMPTY","every","element","game","ttt","TicTacToe","start","TOP","Board","this","squares","fill","board","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","entries","_step$value","index","console","log","move","player","makeMove","rival","O","X","turn","lines","emptySquare","concat","keys","filter","bind","getWinner","getValidMoves","_this","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","line","map","depth","winner","playerFunction","isGameOver","draw","bestMove","currentMax","max","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","minValue","α","β","evalFinalState","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_move","Math","undoMove","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_move2","min","maxValue","time","minimax","floor","random","timeEnd","continueGame","humanPlayer","askMove","validMoves","Number","prompt","indexOf","cpuPlayer","playerOne","arguments"],"mappings":"AAAA,YAMA,SAASA,oBAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAOC,EAAKD,GAAKH,EAAIG,EAAM,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GAE1L,QAASO,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhH,GAAIC,gBAAiB,WAAc,QAASC,GAAcZ,EAAKG,GAAK,GAAIU,MAAeC,GAAK,EAAUC,GAAK,EAAWC,EAAKC,MAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKnB,EAAIoB,OAAOC,cAAmBP,GAAMI,EAAKC,EAAGG,QAAQC,QAAoBV,EAAKW,KAAKN,EAAGO,QAAYtB,GAAKU,EAAKR,SAAWF,GAA3DW,GAAK,IAAoE,MAAOY,GAAOX,GAAK,EAAMC,EAAKU,EAAO,QAAU,KAAWZ,GAAMK,EAAG,WAAWA,EAAG,YAAe,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUb,EAAKG,GAAK,GAAIF,MAAMC,QAAQF,GAAQ,MAAOA,EAAY,IAAIoB,OAAOC,WAAYM,QAAO3B,GAAQ,MAAOY,GAAcZ,EAAKG,EAAa,MAAM,IAAIO,WAAU,4DAEllBkB,aAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAI5B,GAAI,EAAGA,EAAI4B,EAAM1B,OAAQF,IAAK,CAAE,GAAI6B,GAAaD,EAAM5B,EAAI6B,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMR,OAAOS,eAAeN,EAAQE,EAAWK,IAAKL,IAAiB,MAAO,UAAUvB,EAAa6B,EAAYC,GAAiJ,MAA9HD,IAAYT,EAAiBpB,EAAY+B,UAAWF,GAAiBC,GAAaV,EAAiBpB,EAAa8B,GAAqB9B,OAJhiB,WAAW,QAmBEgC,GAAYC,GACjB,GAAIC,GAAQD,EAAI,EAChB,OAAIC,KAAUC,EACHF,EAAIG,MAAM,SAAAC,GAYb,MAZwBA,KAAYH,IAD5C,OAoSJ,QAASI,KACL,GAAIC,GAAM,GAAIC,EACdD,GAAIE,QAzTR,GAAMN,GAAQ,IASRO,EAAM,IAgBNC,EAAA,WAEF,QAFEA,KAkBE7C,gBAAgB8C,KAlBlBD,GAGEC,KAAKC,QAAUrD,MAAM,GAAGsD,KAAKX,GAkFjC,MA3DAhB,cA1BEwB,IA2BEf,IAAK,OACLZ,MAAO,WApBP,GAAI+B,GAAQ,GAsBJC,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiB1C,MAErB,KAzBJ,IAAA,GAA2B2C,GAA3BC,EAA2BR,KAAKC,QAAQQ,UAAb1C,OAAAC,cAA3BoC,GAAAG,EAAAC,EAAAvC,QAAAC,MAAAkC,GAAA,EAAmD,CA2BvC,GAAIM,GAAcpD,eAAeiD,EAAMnC,MAAO,GA3BhDuC,EAAAD,EAAA,GAAOtC,EAAAsC,EAAA,EACbP,IAASQ,EAAS,EAAIvC,EAAb,KAAyBA,GAiChC,MAAOC,GACLgC,GAAoB,EACpBC,EAAiBjC,EACnB,QACE,KACS+B,GAA6BI,EAAAA,WAC9BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IAzCtBM,QAAQC,IAAIV,MAwDZnB,IAAK,WACLZ,MAAO,SAjDF0C,EAAMC,GACXf,KAAKC,QAAQa,GAAQC,KA0DrB/B,IAAK,WACLZ,MAAO,SApDF0C,GACLd,KAAKgB,SAASF,EAAMvB,OA7BtBQ,KAkCAH,EAAA,WAUF,QAVEA,KAqEE1C,gBAAgB8C,KArElBJ,GAWEI,KAAKG,MAAQ,GAAIJ,GACjBC,KAAKiB,OAASC,EAAK,IAAKC,EAAK,KAC7BnB,KAAKoB,KAAO,EACZpB,KAAKqB,QAAS,EAAE,EAAE,IAAK,EAAE,EAAE,IAAK,EAAE,EAAE,IACvB,EAAE,EAAE,IAAK,EAAE,EAAE,IAAK,EAAE,EAAE,IACtB,EAAE,EAAE,IAAI,EAAE,EAAE,IAga7B,MA3VA9C,cArFEqB,IAsFEZ,IAAK,gBACLZ,MAAO,WA/DP,GAAI6B,GAAUD,KAAKG,MAAMF,QACrBqB,EAAc,SAAS7B,EAASkB,GAChC,MAAOV,GAAQU,KAAWpB,EAE9B,UAAOgC,OAAA7E,mBAAIuD,EAAQuB,SAAQC,OAAOH,EAAYI,KAAK1B,UAyEnDhB,IAAK,aACLZ,MAAO,WAlEP,MAAO4B,MAAK2B,cAAgB3B,KAAK4B,gBAAgB5E,UA4EjDgC,IAAK,YACLZ,MAAO,WACH,GAAIyD,GAAQ7B,KAER8B,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkBpE,MAEtB,KA5EJ,IAAA,GAAiBqE,GAAjBC,EAAiBlC,KAAKqB,MAALtD,OAAAC,cAAjB8D,GAAAG,EAAAC,EAAAjE,QAAAC,MAAA4D,GAAA,EAA6B,CA8EjB,GA9EHK,GAAAF,EAAA7D,MACDiB,EAAM8C,EAAKC,IAAI,SAAA3C,GAgFP,MAhFkBoC,GAAK1B,MAAMF,QAAQR,IACjD,IAAIL,EAAYC,GACZ,MAAOA,GAAI,IAoFb,MAAOhB,GACL0D,GAAqB,EACrBC,EAAkB3D,EACpB,QACE,KACSyD,GAA8BI,EAAAA,WAC/BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IA3FtB,MAAO,SAoHPhD,IAAK,iBACLZ,MAAO,SAnGI2C,EAAQsB,GACnB,GAAIC,GAAStC,KAAK2B,WAClB,OAAIW,KAAWvB,EACJjB,EAAMuC,EACNC,IAAWtC,KAAKiB,MAAMF,IACrBjB,EAAMuC,EAEX,KAgHPrD,IAAK,eACLZ,MAAO,SAtGE2C,EAAQwB,GACjB,GAAIvC,KAAKwC,aAAc,CACnBxC,KAAKG,MAAMsC,MACX,IAAIH,GAAStC,KAAK2B,WAClBf,SAAQC,IAAIyB,EAAA,UAAoBA,EAAA,QAAe,qBAE/CC,GAAeb,KAAK1B,MAAMA,KAAKiB,MAAMF,OAiHzC/B,IAAK,UACLZ,MAAO,SAzGH2C,EAAQsB,GACZ,GAAIK,GAAA9E,OACA+E,EAAA/E,OACAgF,GAAO9C,EA0GH+C,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkBnF,MAEtB,KA7GJ,IAAA,GAAiBoF,GAAjBC,EAAiBjD,KAAK4B,gBAAL7D,OAAAC,cAAjB6E,GAAAG,EAAAC,EAAAhF,QAAAC,MAAA2E,GAAA,EAAuC,CA+G3B,GA/GH/B,GAAAkC,EAAA5E,KACLuE,GAAa3C,KAAKkD,SAASpC,EAAMuB,EAAOrC,KAAKiB,MAAMF,IACvBjB,EAAKA,GAC7B6C,EAAaC,IACbA,EAAMD,EACND,EAAW5B,IAkHb,MAAOzC,GACLyE,GAAqB,EACrBC,EAAkB1E,EACpB,QACE,KACSwE,GAA8BI,EAAAA,WAC/BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IAzHtB,MAAOL,MAkJP1D,IAAK,WACLZ,MAAO,SAjIF0C,EAAMuB,EAAOtB,EAAQoC,EAAGC,GAC7B,IAEI,GADApD,KAAKG,MAAMa,SAASF,EAAMC,GACtBf,KAAKwC,aACL,MAAOxC,MAAKqD,eAAetC,EAAQsB,EAmInC,IAAIiB,IAA6B,EAC7BC,GAAqB,EACrBC,EAAkB5F,MAEtB,KArIJ,IAAA,GAAiB6F,GAAjBC,EAAiB1D,KAAK4B,gBAAL7D,OAAAC,cAAjBsF,GAAAG,EAAAC,EAAAzF,QAAAC,MAAAoF,GAAA,EAAuC,CAuI3B,GAvIHK,GAAAF,EAAArF,KAIL,IAHA+E,EAAIS,KAAKhB,IAAIO,EACAnD,KAAKkD,SAASS,EAAMtB,EAAQ,EACdrC,KAAKiB,MAAMF,GAASoC,EAAGC,IAC9CD,GAAKC,EACL,MAAOA,IAyIT,MAAO/E,GACLkF,GAAqB,EACrBC,EAAkBnF,EACpB,QACE,KACSiF,GAA8BI,EAAAA,WAC/BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IAhJtB,MAAOL,GAbX,QAgBInD,KAAKG,MAAM0D,SAAS/C,OAyKxB9B,IAAK,WACLZ,MAAO,SAvJF0C,EAAMuB,EAAOtB,EAAQoC,EAAGC,GAC7B,IAEI,GADApD,KAAKG,MAAMa,SAASF,EAAMC,GACtBf,KAAKwC,aACL,MAAOxC,MAAKqD,eAAetC,EAAQsB,EAyJnC,IAAIyB,IAA6B,EAC7BC,GAAqB,EACrBC,EAAkBpG,MAEtB,KA3JJ,IAAA,GAAiBqG,GAAjBC,EAAiBlE,KAAK4B,gBAAL7D,OAAAC,cAAjB8F,GAAAG,EAAAC,EAAAjG,QAAAC,MAAA4F,GAAA,EAAuC,CA6J3B,GA7JHK,GAAAF,EAAA7F,KAIL,IAHAgF,EAAIQ,KAAKQ,IAAIhB,EACApD,KAAKqE,SAASF,EAAM9B,EAAQ,EACdrC,KAAKiB,MAAMF,GAASoC,EAAGC,IAC9CD,GAAKC,EACL,MAAOD,IA+JT,MAAO9E,GACL0F,GAAqB,EACrBC,EAAkB3F,EACpB,QACE,KACSyF,GAA8BI,EAAAA,WAC/BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IAtKtB,MAAOZ,GAbX,QAgBIpD,KAAKG,MAAM0D,SAAS/C,OAoLxB9B,IAAK,YACLZ,MAAO,SA7KD2C,GACNH,QAAQ0D,KAAK,YACbtE,KAAKG,MAAMsC,MACX,IAAI3B,GAAAlD,MAEAkD,GADAd,KAAKoB,KACEpB,KAAKuE,QAAQxD,EAAQf,KAAKoB,MAE1BwC,KAAKY,MAAMZ,KAAKa,SAAWzE,KAAK4B,gBAAgB5E,QAE3D4D,QAAQC,IAAR,aAAyBC,GACzBF,QAAQ8D,QAAQ,YAChB1E,KAAKG,MAAMa,SAASF,EAAMC,GAE1Bf,KAAK2E,aAAa5D,EAAQf,KAAK4E,gBAsL/B5F,IAAK,cACLZ,MAAO,SAhLC2C,GAMR,QAAS8D,KACLjE,QAAQC,IAAR,oBAAgCiE,EADjB,IAGXhE,GAAOiE,OAAOC,OAAO,uBAEzB,OAAiC,KAA7BF,EAAWG,QAAQnE,GACZA,GAEXF,QAAQC,IAAOC,EAAA,mCACR+D,KAdX7E,KAAKoB,OACLR,QAAQC,IAAR,QAAoBb,KAAKoB,MACzBpB,KAAKG,MAAMsC,MACX,IAAIqC,GAAa9E,KAAK4B,gBAclBd,EAAO+D,GACX7E,MAAKG,MAAMa,SAASF,EAAMC,GAC1Bf,KAAK2E,aAAa5D,EAAQf,KAAKkF,cA2L/BlG,IAAK,QACLZ,MAAO,WACH,GArLF+G,GAAAC,UAAApI,QAAA,GAAAY,SAAAwH,UAAA,GAAU,MAAAA,UAAA,GAAO9F,EAAA8F,UAAApI,QAAA,GAAAY,SAAAwH,UAAA,GAAM,IAAAA,UAAA,EACP,SAAdD,EACAnF,KAAKkF,UAAU5F,GAEfU,KAAK4E,YAAYtF,OApPvBM,IAiQNF","file":"app.js","sourcesContent":["(function(){\n    /** @constant {String} EMPTY - Represent an EMPTY square in the board */\n    const EMPTY = '*';\n    /** @constant {String} X - The X token for the board*/\n    const X = 'X';\n    /** @constant {String} O - The O token for the board */\n    const O = 'O';\n    /**\n     * @constant {Number} TOP - The maximum value to be used by the search\n     * tree algorithm.\n     */\n    const TOP = 100;\n\n    /**\n     * Answer if the row isn't empty and all their elements are equal.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @returns {Boolean} True if all line elements are equal and not the\n     * empty token, false otherwise.\n     */\n    function threeInARow(row) { // return true if all row elements are equal\n        let token = row[0];\n        if (token !== EMPTY) {\n            return row.every(element => element === token);\n        }\n    }\n\n    /** Class representing a board. */\n    class Board {\n        /** Create a board. */\n        constructor() {\n            this.squares = Array(9).fill(EMPTY);\n        }\n\n        /** Draw the game board. */\n        draw() {\n            let board = '';\n            for (let [index, value] of this.squares.entries()) {\n                board += (index % 3)? value: `\\n${value}`;\n            }\n            console.log(board);\n        }\n\n        /**\n         * Place the token of a player in the board.\n         * @param {Number} move - The position where the token will be placed.\n         * @param {String} player - The token of the player.\n         */\n        makeMove(move, player) {\n            this.squares[move] = player;\n        }\n\n        /**\n         * Remove the player token in the given position of the board.\n         * @param {Number} move - The position of the token to be erased.\n         */\n        undoMove(move) {\n            this.makeMove(move, EMPTY);\n        }\n    }\n\n    /** Class representing a Tic Tac Toe game */\n    class TicTacToe {\n        /**\n         * Create a Tic Tac Toe game.\n         * @property {Board} board - The board where the game is played.\n         * @property {Object.<String, String>} - Pairs each token with their\n         * opposite, for easy switching between player tokens.\n         * @property {Number} turn - The actual turn of the game.\n         * @property {Array[]} lines - Array of winning lines in a Tic Tac Toe\n         * game.\n         */\n        constructor() {\n            this.board = new Board();\n            this.rival = {'O': 'X', 'X': 'O'};\n            this.turn = 0;\n            this.lines= [[0,1,2], [3,4,5], [6,7,8], // vertical\n                        [0,3,6], [1,4,7], [2,5,8], // horizontal\n                        [0,4,8],[2,4,6]];          // diagonal\n        }\n\n        /**\n         * Get squares still available (empty) in the board.\n         * @returns {Number[]} List of empty squares in the board.\n         */\n        getValidMoves() {\n            let squares = this.board.squares;\n            let emptySquare = function(element, index) {\n                return squares[index] === EMPTY;\n            };\n            return [...squares.keys()].filter(emptySquare.bind(this));\n        }\n\n        /**\n         * Answer if the game has come to an end.\n         * @returns {Boolean} True or false if game has come to an end or not.\n         */\n        isGameOver() {\n            return this.getWinner() || !this.getValidMoves().length;\n        }\n\n        /**\n         * Get the token of the winner player.\n         * @returns {?String} The token of the actual winner. null means a tie.\n         */\n        getWinner() {\n            for (let line of this.lines) {\n                let row = line.map(element => this.board.squares[element]);\n                if (threeInARow(row)) {\n                    return row[0];\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Evaluate (score) the state of the player at the end of a game.\n         * The possible states are: «Win» (a positive number),\n         * «Lose» (a negative) or «Tie» (zero).\n         * Take the number of moves done (depth) into account. Not taking that\n         * into account leads to a CPU playing awfully: a win in 4 moves is\n         * more valuable that one achieved in 6.\n         * @param {String} player - The token of the player which state is\n         * being evaluated.\n         * @param {Number} depth - The number of moves done to reach the actual\n         * state of the game.\n         *\n         * @returns {Number} The score of the actual state from the player\n         * perspective.\n         */\n        evalFinalState(player, depth) {\n            let winner = this.getWinner();\n            if (winner === player) {\n                return TOP - depth;\n            } else if (winner === this.rival[player]) {\n                return -TOP + depth;\n            }\n            return 0;\n        }\n\n        /**\n         * Check if the game can continue or not and act according to that.\n         * If game can continue, run the next player turn.\n         * If not, draw the final status of the game\n         * @param {String} player - The token of the actual player.\n         * @param {Function} playerFunction - The function to execute if the\n         * game should continue.\n         */\n        continueGame(player, playerFunction) {\n            if (this.isGameOver()) {\n                this.board.draw();\n                let winner = this.getWinner();\n                console.log((winner)? `Player ${winner} won.`: 'It was a tie.');\n            } else {\n                playerFunction.bind(this)(this.rival[player]);\n            }\n        }\n\n        /**\n         * Implement search of the best move to execute next in the game.\n         * Use MiniMax algorithm enhanced with alpha-beta pruning.\n         * @returns {Number} bestMove - Best move to do next to play perfectly.\n         */\n        minimax(player, depth) {\n            let bestMove,\n                currentMax,\n                max = -TOP;\n            for (let move of this.getValidMoves()) {\n                currentMax = this.minValue(move, depth, this.rival[player],\n                                           -TOP, TOP);\n                if (currentMax > max) {\n                    max = currentMax;\n                    bestMove = move;\n                }\n            }\n            return bestMove;\n        }\n\n        /**\n         * Evaluate the given position and get the best result the player could\n         * achieve from that.\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Best situation the player could achieve from the\n         * given position.\n         */\n        maxValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    α = Math.max(α,\n                                 this.minValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return β;\n                    }\n                }\n                return α;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Evaluate the given position and get the worst result for the player\n         * opponent (the best for the player).\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Worst situation the opponent player could achieve\n         * from the given position.\n         */\n        minValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    β = Math.min(β,\n                                 this.maxValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return α;\n                    }\n                }\n                return β;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Run cpu player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        cpuPlayer(player) {\n            console.time('cpu move');\n            this.board.draw();\n            let move;\n            if (this.turn) {\n                move = this.minimax(player, this.turn);\n            } else {\n                move = Math.floor(Math.random() * this.getValidMoves().length);\n            }\n            console.log(`Cpu moves ${move}`);\n            console.timeEnd('cpu move');\n            this.board.makeMove(move, player);\n\n            this.continueGame(player, this.humanPlayer);\n        }\n\n        /**\n         * Run human player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        humanPlayer(player) {\n            this.turn++;\n            console.log(`Turn ${this.turn}`);\n            this.board.draw();\n            let validMoves = this.getValidMoves();\n\n            function askMove() { // print moves available\n                console.log(`Moves available: ${validMoves}`);\n                // ask player for their next move\n                let move = Number(prompt('Give me your move: '));\n\n                if (validMoves.indexOf(move) !== -1) {\n                    return move;\n                }\n                console.log(`${move} isn't a valid move. Try again.`);\n                return askMove();\n            }\n\n            let move = askMove();\n            this.board.makeMove(move, player);\n            this.continueGame(player, this.cpuPlayer);\n        }\n\n        /**\n         * Start the Tic Tac Toe game.\n         * @param {String} [playerOne='cpu'] - Player one (starts the game).\n         * @param {String} [token='X'] - Token of the player one.\n         */\n        start(playerOne='cpu', token='X') {\n            if (playerOne === 'cpu') {\n                this.cpuPlayer(token);\n            } else {\n                this.humanPlayer(token);\n            }\n        }\n    }\n\n    /**\n     * Create and launch a Tic Tac Toe game.\n     */\n    function game(){\n        let ttt = new TicTacToe();\n        ttt.start();\n    }\n\n    game();\n})();"],"sourceRoot":"/source/"}