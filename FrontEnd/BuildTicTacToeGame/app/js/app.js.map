{"version":3,"sources":["app.js","node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/jbone/dist/jbone.js","src/js/app.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_typeof","Symbol","iterator","obj","constructor","e","t","n","r","s","o","u","a","require","f","Error","code","l","exports","call",1,"module","win","isArraylike","type","isFunction","nodeType","BoneEvent","data","setter","this","originalEvent","defaultPrevented","immediatePropagationStopped","jBone","extend","isImmediatePropagationStopped","fn","_$","$","_jBone","rquickSingleTag","rquickExpr","slice","splice","keys","doc","document","isString","el","isObject","toString","element","init","noConflict","elements","tag","wraper","fragment","exec","createElement","attr","createDocumentFragment","innerHTML","lastChild","appendChild","firstChild","childNodes","merge","isElement","find","querySelectorAll","makeArray","pop","push","reverse","shift","sort","indexOf","forEach","unshift","concat","join","every","some","filter","map","reduce","reduceRight","setId","jid","undefined","_cache","events","getData","HTMLElement","pushStack","elems","ret","first","second","j","contains","container","contained","tg","arguments","source","prop","results","unique","array","result","value","Event","event","namespace","eventType","split","createEvent","initEvent","isDefaultPrevented","add","types","handler","selector","eventHandler","dispatch","addEventListener","originfn","remove","eventsByType","removeListener","index","callback","removeEventListener","eventName","trigger","dispatchEvent","expectedTarget","eventOptions","handlers","handlerQueue","targets","currentTarget","on","one","addListener","args","oneArgs","$el","off","apply","finder","found","get","eq","parent","parentElement","toArray","is","tagName","toLowerCase","has","context","getAttribute","setAttribute","name","removeAttr","removeAttribute","val","css","getComputedStyle","style","setValue","jdata","dataset","getValue","removeData","addClass","className","classes","trim","classList","removeClass","toggleClass","force","method","hasClass","html","empty","append","appended","createTextNode","node","cloneNode","appendTo","to","removeChild","parentNode","define","amd","window",2,"threeInARow","row","token","EMPTY","newGame","ttt","TicTacToe","OptionsModal","TOP","Board","squares","fill","getReady","move","player","realMove","tokenAlt","makeMove","board","rival","O","X","turn","lines","cacheDom","bindEvents","$board","$square","$modal","handleMove","bind","Number","square","humanToken","continueGame","cpuPlayer","playerFunction","isGameOver","winner","getWinner","console","log","setTimeout","reset","emptySquare","getValidMoves","_this","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","next","done","line","err","depth","bestMove","currentMax","max","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","minValue","α","β","evalFinalState","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_move","Math","undoMove","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_move2","min","maxValue","time","disableBoard","minimax","floor","random","timeEnd","humanPlayer","enableBoard","playerOne","game","$tokens","$players","$start","handleTokenSelection","handlePlayerSelection","handleStart","$this","start","jbone"],"mappings":"AAAA,YAMA,SAASA,oBAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAOC,EAAKD,GAAKH,EAAIG,EAAM,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GAE1L,QAASO,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhH,GAAIC,cAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIX,GAAI,EAAGA,EAAIW,EAAMT,OAAQF,IAAK,CAAE,GAAIY,GAAaD,EAAMX,EAAIY,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeP,EAAQE,EAAWM,IAAKN,IAAiB,MAAO,UAAUN,EAAaa,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBH,EAAYe,UAAWF,GAAiBC,GAAaX,EAAiBH,EAAac,GAAqBd,MAE5hBgB,QAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,OAAS,eAAkBE,KCJ1O,QAAAE,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAhC,EAAA,MAAAA,GAAAgC,GAAA,EAAA,IAAAI,GAAA,GAAAC,OAAA,uBAAAL,EAAA,IAAA,MAAAI,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAV,EAAAG,IAAAQ,WAAAZ,GAAAI,GAAA,GAAAS,KAAAF,EAAAC,QAAA,SAAAb,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAY,EAAAA,EAAAC,QAAAb,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAQ,QAAA,IAAA,GAAAxC,GAAA,kBAAAmC,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAA5B,OAAA8B,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,EAAAQ,EAAAH,ICSA,SAAAI,GA0KA,QAAAC,GAAApB,GACA,GAAAvB,GAAAuB,EAAAvB,OACA4C,EAAA,mBAAArB,GAAA,YAAAH,QAAAG,EAEA,OAAAsB,GAAAD,IAAArB,IAAAmB,GACA,EAGA,IAAAnB,EAAAuB,UAAA9C,GACA,EAGAH,EAAA+C,IAAA,IAAA5C,GACA,gBAAAA,IAAAA,EAAA,GAAAA,EAAA,IAAAuB,GAyEA,QAAAwB,GAAAtB,EAAAuB,GACA,GAAAhC,GAAAiC,CAEAC,MAAAC,cAAA1B,EAEAwB,EAAA,SAAAjC,EAAAS,GACA,mBAAAT,EACAkC,KAAAlC,GAAA,WAEA,MADAkC,MAAAE,kBAAA,EACA3B,EAAAT,MAEA,6BAAAA,EACAkC,KAAAlC,GAAA,WAEA,MADAkC,MAAAG,6BAAA,EACA5B,EAAAT,MAEA6B,EAAApB,EAAAT,IACAkC,KAAAlC,GAAA,WACA,MAAAS,GAAAT,MAGAkC,KAAAlC,GAAAS,EAAAT,GAIA,KAAAA,IAAAS,IACAA,EAAAT,IAAA,kBAAAS,GAAAT,KACAiC,EAAAV,KAAAW,KAAAlC,EAAAS,EAIA6B,GAAAC,OAAAL,KAAAF,GACAQ,8BAAA,WACA,QAAAN,KAAAG,+BA/RA,GAmCAI,GAjCAC,EAAAhB,EAAAiB,EACAC,EAAAlB,EAAAY,MAGAO,EAAA,kBAIAC,EAAA,2CAGAC,KAAAA,MACAC,KAAAA,OACAC,EAAAnD,OAAAmD,KAGAC,EAAAC,SAEAC,EAAA,SAAAC,GACA,MAAA,gBAAAA,IAEAC,EAAA,SAAAD,GACA,MAAAA,aAAAvD,SAEA+B,EAAA,SAAAwB,GACA,MAAA,yBAAAE,SAAAhC,KAAA8B,IAEAxE,EAAA,SAAAwE,GACA,MAAAzE,OAAAC,QAAAwE,IAEAf,EAAA,SAAAkB,EAAAxB,GACA,MAAA,IAAAS,GAAAgB,KAAAD,EAAAxB,GAnCAM,GAwCAoB,WAAA,WAIA,MAHAhC,GAAAiB,EAAAD,EACAhB,EAAAY,MAAAM,EAEAN,GAGAG,EAAAH,EAAAG,GAAAH,EAAAnC,WACAsD,KAAA,SAAAD,EAAAxB,GACA,GAAA2B,GAAAC,EAAAC,EAAAC,CAEA,KAAAN,EACA,MAAAtB,KAEA,IAAAkB,EAAAI,GAAA,CAEA,GAAAI,EAAAf,EAAAkB,KAAAP,GAQA,MAPAtB,MAAA,GAAAgB,EAAAc,cAAAJ,EAAA,IACA1B,KAAAlD,OAAA,EAEAsE,EAAAtB,IACAE,KAAA+B,KAAAjC,GAGAE,IAVA,KAaA0B,EAAAd,EAAAiB,KAAAP,KAAAI,EAAA,GAAA,CAIA,IAHAE,EAAAZ,EAAAgB,yBACAL,EAAAX,EAAAc,cAAA,OACAH,EAAAM,UAAAX,EACAK,EAAAO,WACAN,EAAAO,YAAAR,EAAAS,WAIA,OAFAX,GAAAZ,EAAAxB,KAAAuC,EAAAS,YAEAjC,EAAAkC,MAAAtC,KAAAyB,GAtBA,GAyBArB,EAAAmC,UAAAzC,GACA,MAAAM,GAAAN,GAAA0C,KAAAlB,EAGA,KAGA,MAFAG,GAAAT,EAAAyB,iBAAAnB,GAEAlB,EAAAkC,MAAAtC,KAAAyB,GACA,MAAAlD,GACA,MAAAyB,OAxCA,MA4CAsB,GAAA1B,UACAI,KAAA,GAAAsB,EACAtB,KAAAlD,OAAA,EAEAkD,MAGAL,EAAA2B,GACAA,IAGAA,YAAAlB,GACAkB,EAIAlB,EAAAsC,UAAApB,EAAAtB,OAGA2C,OAAAA,IACAC,QAAAA,KACAC,WAAAA,QACAC,SAAAA,MACAC,QAAAA,KACAjC,UAAAA,OACAD,SAAAA,MACAmC,WAAAA,QACAC,WAAAA,QACAC,WAAAA,QACAC,UAAAA,OACAC,QAAAA,KACAC,SAAAA,MACAC,QAAAA,KACAC,UAAAA,OACAC,OAAAA,IACAC,UAAAA,OACAC,eAAAA,YACA5G,OAAA,GAGAyD,EAAAjC,YAAA8B,EAEAG,EAAAgB,KAAAtD,UAAAsC,EAEAH,EAAAuD,MAAA,SAAAxC,GACA,GAAAyC,GAAAzC,EAAAyC,GAEAzC,KAAA3B,EACAoE,EAAA,SACAC,SAAA1C,EAAAyC,MACAzC,EAAAyC,IAAAA,IAAAxD,EAAA0D,OAAAF,KAGAxD,EAAA0D,OAAAC,OAAAH,KACAxD,EAAA0D,OAAAC,OAAAH,QAIAxD,EAAA4D,QAAA,SAAA7C,GACAA,EAAAA,YAAAf,GAAAe,EAAA,GAAAA,CAEA,IAAAyC,GAAAzC,IAAA3B,EAAA,SAAA2B,EAAAyC,GAEA,QACAA,IAAAA,EACAG,OAAA3D,EAAA0D,OAAAC,OAAAH,KAIAxD,EAAAmC,UAAA,SAAApB,GACA,MAAAA,IAAAA,YAAAf,IAAAe,YAAA8C,cAAA/C,EAAAC,IAGAf,EAAA0D,QACAC,UACAH,IAAA,GAmBArD,EAAA2D,UAAA,SAAAC,GACA,GAAAC,GAAAhE,EAAAkC,MAAAtC,KAAA1B,cAAA6F,EAEA,OAAAC,IAGAhE,EAAAkC,MAAA,SAAA+B,EAAAC,GAKA,IAJA,GAAAnF,GAAAmF,EAAAxH,OACAF,EAAAyH,EAAAvH,OACAyH,EAAA,EAEApF,EAAAoF,GACAF,EAAAzH,KAAA0H,EAAAC,IAKA,OAFAF,GAAAvH,OAAAF,EAEAyH,GAGAjE,EAAAoE,SAAA,SAAAC,EAAAC,GACA,MAAAD,GAAAD,SAAAE,IAGAtE,EAAAC,OAAA,SAAA/C,GACA,GAAAqH,EAYA,OAVA7D,GAAAzB,KAAAuF,UAAA,GAAA3B,QAAA,SAAA4B,GAAA,GACAF,EAAArH,EAEAuH,EACA,IAAA,GAAAC,KAAAD,GACAF,EAAAG,GAAAD,EAAAC,KAKAxH,GAGA8C,EAAAsC,UAAA,SAAAjG,EAAAsI,GACA,GAAAX,GAAAW,KAUA,OARA,QAAAtI,IACAgD,EAAAhD,GACA2D,EAAAkC,MAAA8B,EAAAlD,EAAAzE,IAAAA,GAAAA,GAEA2H,EAAAxB,KAAAnG,IAIA2H,GAGAhE,EAAA4E,OAAA,SAAAC,GACA,GAAA,MAAAA,EACA,QAKA,KAAA,GAFAC,MAEAtI,EAAA,EAAAE,EAAAmI,EAAAnI,OAAAA,EAAAF,EAAAA,IAAA,CACA,GAAAuI,GAAAF,EAAArI,EACAsI,GAAAlC,QAAAmC,GAAA,GACAD,EAAAtC,KAAAuC,GAGA,MAAAD,IAyCA9E,EAAAgF,MAAA,SAAAC,EAAAvF,GACA,GAAAwF,GAAAC,CAaA,OAXAF,GAAA3F,OAAAI,IACAA,EAAAuF,EACAA,EAAAA,EAAA3F,MAGA4F,EAAAD,EAAAG,MAAA,KAAA1E,OAAA,GAAAsC,KAAA,KACAmC,EAAAF,EAAAG,MAAA,KAAA,GAEAH,EAAArE,EAAAyE,YAAA,SACAJ,EAAAK,UAAAH,GAAA,GAAA,GAEAnF,EAAAC,OAAAgF,GACAC,UAAAA,EACAK,mBAAA,WACA,MAAAN,GAAAnF,mBAEAJ,IAGAM,EAAAiF,OAUAO,IAAA,SAAAzE,EAAA0E,EAAAC,EAAAhG,EAAAiG,GACA3F,EAAAuD,MAAAxC,EAEA,IAIAoE,GAAA/G,EAAA6G,EAJAW,EAAA,SAAAzH,GACA6B,EAAAiF,MAAAY,SAAA5G,KAAA8B,EAAA5C,IAEAwF,EAAA3D,EAAA4D,QAAA7C,GAAA4C,MAKA,KAFA8B,EAAAA,EAAAL,MAAA,KACAhH,EAAAqH,EAAA/I,OACA0B,KACA6G,EAAAQ,EAAArH,GAEA+G,EAAAF,EAAAG,MAAA,KAAA,GACAzB,EAAAwB,GAAAxB,EAAAwB,OAEAxB,EAAAwB,GAAAzI,OAEAkJ,EAAAjC,EAAAwB,GAAA,GAAAhF,GAEAY,EAAA+E,kBAAA/E,EAAA+E,iBAAAX,EAAAS,GAAA,GAGAjC,EAAAwB,GAAA3C,MACA0C,UAAAD,EAAAG,MAAA,KAAA1E,OAAA,GAAAsC,KAAA,KACA7C,GAAAyF,EACAD,SAAAA,EACAjG,KAAAA,EACAqG,SAAAL,KAWAM,OAAA,SAAAjF,EAAA0E,EAAAC,GACA,GAkBA3G,GACAkH,EAnBAC,EAAA,SAAAvC,EAAAwB,EAAAgB,EAAApF,EAAA5C,GACA,GAAAiI,IAGAV,GAAAvH,EAAA4H,WAAAL,IAAAA,KACAU,EAAAjI,EAAAgC,IAGAwD,EAAAwB,GAAAgB,GAAAhG,KAAAiG,IAEAzC,EAAAwB,GAAAzE,OAAAyF,EAAA,GAEAxC,EAAAwB,GAAAzI,QACAqE,EAAAsF,oBAAAlB,EAAAiB,KAIAzC,EAAA3D,EAAA4D,QAAA7C,GAAA4C,MAIA,IAAAA,EAtBA,OA2BA8B,GAAA9B,EACAhD,EAAAgD,GAAAd,QAAA,SAAAsC,GAIA,IAHAc,EAAAtC,EAAAwB,GACApG,EAAAkH,EAAAvJ,OAEAqC,KACAmH,EAAAvC,EAAAwB,EAAApG,EAAAgC,EAAAkF,EAAAlH,UAKA0G,GAAAL,MAAA,KAAAvC,QAAA,SAAAyD,GACA,GAEAnI,GAFAgH,EAAAmB,EAAAlB,MAAA,KAAA,GACAF,EAAAoB,EAAAlB,MAAA,KAAA1E,OAAA,GAAAsC,KAAA,IAFA,IAMAW,EAAAwB,GAIA,IAHAc,EAAAtC,EAAAwB,GACApG,EAAAkH,EAAAvJ,OAEAqC,KACAZ,EAAA8H,EAAAlH,KACAmG,GAAAA,GAAA/G,EAAA+G,YAAAA,IACAgB,EAAAvC,EAAAwB,EAAApG,EAAAgC,EAAA5C,OAKA+G,IACAvE,EAAAgD,GAAAd,QAAA,SAAAsC,GAIA,IAHAc,EAAAtC,EAAAwB,GACApG,EAAAkH,EAAAvJ,OAEAqC,KACAZ,EAAA8H,EAAAlH,GACAZ,EAAA+G,UAAAE,MAAA,KAAA,KAAAF,EAAAE,MAAA,KAAA,IACAc,EAAAvC,EAAAwB,EAAApG,EAAAgC,EAAA5C,QAaAoI,QAAA,SAAAxF,EAAAkE,GACA,GAAAtB,KAEA7C,GAAAmE,GACAtB,EAAAsB,EAAAG,MAAA,KAAAhC,IAAA,SAAA6B,GACA,MAAAjF,GAAAgF,MAAAC,MAGAA,EAAAA,YAAAD,OAAAC,EAAAjF,EAAAgF,MAAAC,GACAtB,GAAAsB,IAGAtB,EAAAd,QAAA,SAAAoC,GACAA,EAAA3F,MAIAyB,EAAAyF,eAAAzF,EAAAyF,cAAAvB,MAIAY,SAAA,SAAA1H,GAAA,IACA,GAOAY,GACA0H,EACAf,EACAT,EACAyB,EAXAlK,EAAA,EACA2H,EAAA,EACApD,EAAAnB,KACA+G,EAAA3G,EAAA4D,QAAA7C,GAAA4C,OAAAxF,EAAAmB,MACA5C,EAAAiK,EAAAjK,OACAkK,KACAC,KAQAnK,EAAAF,EAAAA,IACAoK,EAAApE,KAAAmE,EAAAnK,GAMA,KAHAA,EAAA,EACAE,EAAAkK,EAAAlK,OAIAA,EAAAF,IAEAmK,EAAA/D,QAAAgE,EAAApK,OAEAyI,IAAAA,EAAA/E,iCACA1D,IAAA,GACAiK,EAAA,KACAC,KACAhB,EAAAkB,EAAApK,GACAkJ,EAAAhG,OAAAgH,EAAAhH,KAAAgG,EAAAhG,MAGAgG,EAAAC,UAQA,KAEAkB,EAAA7G,EAAAe,GAAAqB,KAAAsD,EAAAC,WAAA/C,QAAAzE,EAAAjB,UAAAuJ,EAAAtI,EAAAjB,SAEA6D,IAAA5C,EAAAjB,QAAA6D,EAAAqD,SAAAjG,EAAAjB,QACA,CAEA,IAAAuJ,EAIA,IAHA1H,EAAA8H,EAAAnK,OACAyH,EAAA,EAEApF,EAAAoF,EAAAA,IACA0C,EAAA1C,IAAA0C,EAAA1C,GAAAC,SAAAjG,EAAAjB,UACAuJ,EAAAI,EAAA1C,GAKA,KAAAsC,EACA,QAGAC,GAAAI,cAAAL,EACAxB,EAAA,GAAAxF,GAAAtB,EAAAuI,GAEAvI,EAAA+G,WAAA/G,EAAA+G,YAAAQ,EAAAR,WACAQ,EAAAK,SAAA9G,KAAAwH,EAAAxB,QAjCAA,GAAA,GAAAxF,GAAAtB,EAAAuI,GAEAvI,EAAA+G,WAAA/G,EAAA+G,YAAAQ,EAAAR,WACAQ,EAAAK,SAAA9G,KAAA8B,EAAAkE,KAqCA9E,EAAA4G,GAAA,SAAAtB,EAAAE,EAAAjG,EAAAS,GACA,GAAAzD,GAAAkD,KAAAlD,OACAF,EAAA,CAmBA,IAjBA,MAAAkD,GAAA,MAAAS,GAEAA,EAAAwF,EACAjG,EAAAiG,EAAAlC,QACA,MAAAtD,IACA,gBAAAwF,IAEAxF,EAAAT,EACAA,EAAA+D,SAGAtD,EAAAT,EACAA,EAAAiG,EACAA,EAAAlC,UAIAtD,EACA,MAAAP,KAGA,MAAAlD,EAAAF,EAAAA,IACAwD,EAAAiF,MAAAO,IAAA5F,KAAApD,GAAAiJ,EAAAtF,EAAAT,EAAAiG,EAGA,OAAA/F,OAGAO,EAAA6G,IAAA,SAAA/B,GACA,GAKAgC,GALAC,EAAA1C,UACAhI,EAAA,EACAE,EAAAkD,KAAAlD,OACAyK,EAAA1G,EAAAxB,KAAAiI,EAAA,EAAAA,EAAAxK,OAAA,GACA0J,EAAA3F,EAAAxB,KAAAiI,EAAA,IAAA,EAgBA,KAbAD,EAAA,SAAAlG,GACA,GAAAqG,GAAApH,EAAAe,EAEAkE,GAAAG,MAAA,KAAAvC,QAAA,SAAAoC,GACA,GAAA9E,GAAA,QAAAA,GAAAhC,GACAiJ,EAAAC,IAAApC,EAAA9E,GACAiG,EAAAnH,KAAA8B,EAAA5C,GAGAiJ,GAAAL,GAAAO,MAAAF,GAAAnC,GAAAlC,OAAAoE,EAAAhH,OAIAzD,EAAAF,EAAAA,IACAyK,EAAArH,KAAApD,GAGA,OAAAoD,OAGAO,EAAAoG,QAAA,SAAAtB,GACA,GAAAzI,GAAA,EACAE,EAAAkD,KAAAlD,MAEA,KAAAuI,EACA,MAAArF,KAGA,MAAAlD,EAAAF,EAAAA,IACAwD,EAAAiF,MAAAsB,QAAA3G,KAAApD,GAAAyI,EAGA,OAAArF,OAGAO,EAAAkH,IAAA,SAAA5B,EAAAC,GAIA,IAHA,GAAAlJ,GAAA,EACAE,EAAAkD,KAAAlD,OAEAA,EAAAF,EAAAA,IACAwD,EAAAiF,MAAAe,OAAApG,KAAApD,GAAAiJ,EAAAC,EAGA,OAAA9F,OAGAO,EAAAiC,KAAA,SAAAuD,GAYA,IAXA,GAAAhB,MACAnI,EAAA,EACAE,EAAAkD,KAAAlD,OACA6K,EAAA,SAAAxG,GACAxB,EAAAwB,EAAAsB,sBACAQ,QAAA5D,KAAA8B,EAAAsB,iBAAAsD,GAAA,SAAA6B,GACA7C,EAAAnC,KAAAgF,MAKA9K,EAAAF,EAAAA,IACA+K,EAAA3H,KAAApD,GAGA,OAAAwD,GAAA2E,IAGAxE,EAAAsH,IAAA,SAAAtB,GACA,MAAA,OAAAA,EAGA,EAAAA,EAAAvG,KAAAuG,EAAAvG,KAAAlD,QAAAkD,KAAAuG,GAGA1F,EAAAxB,KAAAW,OAGAO,EAAAuH,GAAA,SAAAvB,GACA,MAAAnG,GAAAJ,KAAAuG,KAGAhG,EAAAwH,OAAA,WAMA,IALA,GACAA,GADAhD,KAEAnI,EAAA,EACAE,EAAAkD,KAAAlD,OAEAA,EAAAF,EAAAA,MACAmI,EAAA/B,QAAA+E,EAAA/H,KAAApD,GAAAoL,gBAAAD,GACAhD,EAAAnC,KAAAmF,EAIA,OAAA3H,GAAA2E,IAGAxE,EAAA0H,QAAA,WACA,MAAApH,GAAAxB,KAAAW,OAGAO,EAAA2H,GAAA,WACA,GAAAZ,GAAA1C,SAEA,OAAA5E,MAAAsD,KAAA,SAAAnC,GACA,MAAAA,GAAAgH,QAAAC,gBAAAd,EAAA,MAIA/G,EAAA8H,IAAA,WACA,GAAAf,GAAA1C,SAEA,OAAA5E,MAAAsD,KAAA,SAAAnC,GACA,MAAAA,GAAAsB,iBAAA6E,EAAA,IAAAxK,UAIAyD,EAAAqF,IAAA,SAAAG,EAAAuC,GACA,MAAAtI,MAAAkE,UACA9D,EAAA4E,OACA5E,EAAAkC,MAAAtC,KAAA6H,MAAAzH,EAAA2F,EAAAuC,OAKA/H,EAAAwB,KAAA,SAAAjE,EAAAqH,GACA,GAGApF,GAHAuH,EAAA1C,UACAhI,EAAA,EACAE,EAAAkD,KAAAlD,MAGA,IAAAoE,EAAApD,IAAA,IAAAwJ,EAAAxK,OACA,MAAAkD,MAAA,IAAAA,KAAA,GAAAuI,aAAAzK,EAeA,KAZA,IAAAwJ,EAAAxK,OACAiD,EAAA,SAAAoB,GACAA,EAAAqH,aAAA1K,EAAAqH,IAEA/D,EAAAtD,KACAiC,EAAA,SAAAoB,GACAJ,EAAAjD,GAAAmF,QAAA,SAAAwF,GACAtH,EAAAqH,aAAAC,EAAA3K,EAAA2K,QAKA3L,EAAAF,EAAAA,IACAmD,EAAAC,KAAApD,GAGA,OAAAoD,OAGAO,EAAAmI,WAAA,SAAA5K,GAIA,IAHA,GAAAlB,GAAA,EACAE,EAAAkD,KAAAlD,OAEAA,EAAAF,EAAAA,IACAoD,KAAApD,GAAA+L,gBAAA7K,EAGA,OAAAkC,OAGAO,EAAAqI,IAAA,SAAAzD,GACA,GAAAvI,GAAA,EACAE,EAAAkD,KAAAlD,MAEA,IAAA,IAAA8H,UAAA9H,OACA,MAAAkD,MAAA,IAAAA,KAAA,GAAAmF,KAGA,MAAArI,EAAAF,EAAAA,IACAoD,KAAApD,GAAAuI,MAAAA,CAGA,OAAAnF,OAGAO,EAAAsI,IAAA,SAAA/K,EAAAqH,GACA,GAGApF,GAHAuH,EAAA1C,UACAhI,EAAA,EACAE,EAAAkD,KAAAlD,MAHA,IAOAoE,EAAApD,IAAA,IAAAwJ,EAAAxK,OACA,MAAAkD,MAAA,IAAAR,EAAAsJ,iBAAA9I,KAAA,IAAAlC,EAgBA,KAZA,IAAAwJ,EAAAxK,OACAiD,EAAA,SAAAoB,GACAA,EAAA4H,MAAAjL,GAAAqH,GAEA/D,EAAAtD,KACAiC,EAAA,SAAAoB,GACAJ,EAAAjD,GAAAmF,QAAA,SAAAwF,GACAtH,EAAA4H,MAAAN,GAAA3K,EAAA2K,OAKA3L,EAAAF,EAAAA,IACAmD,EAAAC,KAAApD,GAGA,OAAAoD,OAGAO,EAAAT,KAAA,SAAAhC,EAAAqH,GACA,GAGApF,GAHAuH,EAAA1C,UAAA9E,KACAlD,EAAA,EACAE,EAAAkD,KAAAlD,OAEAkM,EAAA,SAAA7H,EAAArD,EAAAqH,GACA/D,EAAA+D,IACAhE,EAAA8H,MAAA9H,EAAA8H,UACA9H,EAAA8H,MAAAnL,GAAAqH,GAEAhE,EAAA+H,QAAApL,GAAAqH,GAGAgE,EAAA,SAAAhE,GACA,MAAA,SAAAA,GACA,EACA,UAAAA,GACA,EAEAA,EAnBA,IAwBA,IAAAmC,EAAAxK,OAOA,MANAkD,MAAA,GAAAiJ,QAAAnJ,EAAAE,KAAA,GAAAiJ,OAEAlI,EAAAf,KAAA,GAAAkJ,SAAAjG,QAAA,SAAAnF,GACAgC,EAAAhC,GAAAqL,EAAAnJ,KAAA,GAAAkJ,QAAApL,KACAkC,MAEAF,CA/BA,IAkCA,IAAAwH,EAAAxK,QAAAoE,EAAApD,GACA,MAAAkC,MAAA,IAAAmJ,EAAAnJ,KAAA,GAAAkJ,QAAApL,IAAAkC,KAAA,GAAAiJ,OAAAjJ,KAAA,GAAAiJ,MAAAnL,GAgBA,KAZA,IAAAwJ,EAAAxK,QAAAsE,EAAAtD,GACAiC,EAAA,SAAAoB,GACAJ,EAAAjD,GAAAmF,QAAA,SAAAwF,GACAO,EAAA7H,EAAAsH,EAAA3K,EAAA2K,OAGA,IAAAnB,EAAAxK,SACAiD,EAAA,SAAAoB,GACA6H,EAAA7H,EAAArD,EAAAqH,KAIArI,EAAAF,EAAAA,IACAmD,EAAAC,KAAApD,GAGA,OAAAoD,OAGAO,EAAA6I,WAAA,SAAAtL,GAKA,IAJA,GAEAmL,GAAAC,EAFAtM,EAAA,EACAE,EAAAkD,KAAAlD,OAGAA,EAAAF,EAAAA,IAIA,GAHAqM,EAAAjJ,KAAApD,GAAAqM,MACAC,EAAAlJ,KAAApD,GAAAsM,QAEApL,EACAmL,GAAAA,EAAAnL,UAAAmL,GAAAnL,SACAoL,GAAApL,OACA,CACA,IAAAA,IAAAmL,SACAA,GAAAnL,EAGA,KAAAA,IAAAoL,SACAA,GAAApL,GAKA,MAAAkC,OAGAO,EAAA8I,SAAA,SAAAC,GAMA,IALA,GAAA1M,GAAA,EACA2H,EAAA,EACAzH,EAAAkD,KAAAlD,OACAyM,EAAAD,EAAAA,EAAAE,OAAAhE,MAAA,UAEA1I,EAAAF,EAAAA,IAGA,IAFA2H,EAAA,EAEAA,EAAA,EAAAA,EAAAgF,EAAAzM,OAAAyH,IACAvE,KAAApD,GAAA6M,UAAA7D,IAAA2D,EAAAhF,GAIA,OAAAvE,OAGAO,EAAAmJ,YAAA,SAAAJ,GAMA,IALA,GAAA1M,GAAA,EACA2H,EAAA,EACAzH,EAAAkD,KAAAlD,OACAyM,EAAAD,EAAAA,EAAAE,OAAAhE,MAAA,UAEA1I,EAAAF,EAAAA,IAGA,IAFA2H,EAAA,EAEAA,EAAA,EAAAA,EAAAgF,EAAAzM,OAAAyH,IACAvE,KAAApD,GAAA6M,UAAArD,OAAAmD,EAAAhF,GAIA,OAAAvE,OAGAO,EAAAoJ,YAAA,SAAAL,EAAAM,GACA,GAAAhN,GAAA,EACAE,EAAAkD,KAAAlD,OACA+M,EAAA,QAIA,IAFAD,KAAA,IAAAC,EAAA,QAAAD,KAAA,IAAAC,EAAA,UAEAP,EACA,KAAAxM,EAAAF,EAAAA,IACAoD,KAAApD,GAAA6M,UAAAI,GAAAP,EAIA,OAAAtJ,OAGAO,EAAAuJ,SAAA,SAAAR,GACA,GAAA1M,GAAA,EAAAE,EAAAkD,KAAAlD,MAEA,IAAAwM,EACA,KAAAxM,EAAAF,EAAAA,IACA,GAAAoD,KAAApD,GAAA6M,UAAAjF,SAAA8E,GACA,OAAA,CAKA,QAAA,GAGA/I,EAAAwJ,KAAA,SAAA5E,GACA,GACAhE,GADAmG,EAAA1C,SADA,OAKA,KAAA0C,EAAAxK,QAAA+G,SAAAsB,EACAnF,KAAAgK,QAAAC,OAAA9E,GAGA,IAAAmC,EAAAxK,SAAAqE,EAAAnB,KAAA,IACAmB,EAAAc,UAGAjC,MAGAO,EAAA0J,OAAA,SAAAC,GACA,GAEAnK,GAFAnD,EAAA,EACAE,EAAAkD,KAAAlD,MAwBA,KApBAoE,EAAAgJ,IAAAtJ,EAAAiB,KAAAqI,GACAA,EAAA9J,EAAA8J,GAGA9I,EAAA8I,KACAA,EAAAjJ,SAAAkJ,eAAAD,IAGAA,EAAAA,YAAA9J,GAAA8J,EAAA9J,EAAA8J,GAEAnK,EAAA,SAAAoB,EAAAvE,GACAsN,EAAAjH,QAAA,SAAAmH,GACAxN,EACAuE,EAAAgB,YAAAiI,EAAAC,WAAA,IAEAlJ,EAAAgB,YAAAiI,MAKAtN,EAAAF,EAAAA,IACAmD,EAAAC,KAAApD,GAAAA,EAGA,OAAAoD,OAGAO,EAAA+J,SAAA,SAAAC,GAGA,MAFAnK,GAAAmK,GAAAN,OAAAjK,MAEAA,MAGAO,EAAAyJ,MAAA,WAKA,IAJA,GAEA7I,GAFAvE,EAAA,EACAE,EAAAkD,KAAAlD,OAGAA,EAAAF,EAAAA,IAGA,IAFAuE,EAAAnB,KAAApD,GAEAuE,EAAAe,WACAf,EAAAqJ,YAAArJ,EAAAe,UAIA,OAAAlC,OAGAO,EAAA6F,OAAA,WACA,GAEAjF,GAFAvE,EAAA,EACAE,EAAAkD,KAAAlD,MAMA,KARAkD,KAMAyH,MAEA3K,EAAAF,EAAAA,IACAuE,EAAAnB,KAAApD,SAGAuE,GAAA8H,MACA9H,EAAAsJ,YAAAtJ,EAAAsJ,WAAAD,YAAArJ,EAGA,OAAAnB,OAGA,YAAA,mBAAAT,GAAA,YAAArB,QAAAqB,KAAAA,GAAA,WAAArB,QAAAqB,EAAAH,SAKAG,EAAAH,QAAAgB,EAGA,kBAAAsK,SAAAA,OAAAC,KACAD,OAAA,WACA,MAAAtK,KAGAZ,EAAAY,MAAAZ,EAAAiB,EAAAL,GACA,YAAA,mBAAAZ,GAAA,YAAAtB,QAAAsB,KAAA,WAAAtB,QAAAsB,EAAAyB,YACAzB,EAAAY,MAAAZ,EAAAiB,EAAAL,IAGAwK,aFGMC,GAAG,SAAS9L,EAAQQ,EAAOH,IGjiCjC,WAAA,QA2BA0L,GAAAC,GACA,GAAAC,GAAAD,EAAA,EACA,OAAAC,KAAAC,EACAF,EAAA1H,MAAA,SAAA/B,GHwjCwB,MGxjCxBA,KAAA0J,IADA,OAoYA,QAAAE,KACA,GAAAC,GAAA,GAAAC,EACA,IAAAC,GAAAF,GAjaA,GAAA1K,GAAA1B,EAAA,SAGAkM,EAAA,IASAK,EAAA,IAqBAC,EAAA,WAEA,QAFAA,KH8jCoBvO,gBAAgBgD,KG9jCpCuL,GAGAvL,KAAAwL,QAAA9O,MAAA,GAAA+O,KAAAR,GACAjL,KAAA0L,WH6mCgB,MA1CAtO,cGvkChBmO,IHwkCoBzN,IAAK,WACLqH,MAAO,WGhkC3B,IAAA,GAAAvI,GAAA,EAAA,EAAAA,EAAAA,IACAoD,KAAA,UAAApD,GAAA6D,EAAA,UAAA7D,GACAoD,KAAA,UAAApD,GAAAmN,KAAA,IAAArB,WAAA,eH8kCoB5K,IAAK,WACLqH,MAAO,SGpkC3BwG,EAAAC,GHqkCwB,GGrkCxBC,GAAAjH,UAAA9H,QAAA,GAAA+G,SAAAe,UAAA,IAAA,EAAAA,UAAA,EAEA,IADA5E,KAAAwL,QAAAG,GAAAC,EACAC,EAAA,CACA,GAAAC,GAAA,MAAAF,EAAA,QAAA,SACAZ,EAAA,6CAAAY,EAAA,cAAAE,EAAA,IACA9L,MAAA,UAAA2L,GAAA5B,KAAAiB,GAAAjJ,KAAA,WAAA,QHglCoBjE,IAAK,WACLqH,MAAO,SGzkC3BwG,GACA3L,KAAA+L,SAAAJ,EAAAV,OApCAM,KAyCAH,EAAA,WAUA,QAVAA,KH0lCoBpO,gBAAgBgD,KG1lCpCoL,GAWApL,KAAAgM,MAAA,GAAAT,GACAvL,KAAAiM,OAAAC,EAAA,IAAAC,EAAA,KACAnM,KAAAoM,KAAA,EACApM,KAAAqM,QAAA,EAAA,EAAA,IAAA,EAAA,EAAA,IAAA,EAAA,EAAA,IACA,EAAA,EAAA,IAAA,EAAA,EAAA,IAAA,EAAA,EAAA,IACA,EAAA,EAAA,IAAA,EAAA,EAAA,IANArM,KAQAsM,WACAtM,KAAAuM,aHw9CgB,MAjYAnP,cG1mChBgO,IH2mCoBtN,IAAK,WACLqH,MAAO,WGplC3BnF,KAAAwM,OAAA/L,EAAA,UACAT,KAAAyM,QAAAhM,EAAA,WACAT,KAAA0M,OAAAjM,EAAA,aH2lCoB3C,IAAK,aACLqH,MAAO,WGvlC3BnF,KAAAyM,QAAAtF,GAAA,QAAAnH,KAAA2M,WAAAC,KAAA5M,UH8lCoBlC,IAAK,cACLqH,MAAO,WG1lC3BnF,KAAAwM,OAAA9C,YAAA,eHimCoB5L,IAAK,eACLqH,MAAO,WG7lC3BnF,KAAAwM,OAAAnD,SAAA,eHwmCoBvL,IAAK,aACLqH,MAAO,SGjmC3BE,GACA,GAAAsG,GAAAkB,OAAAxH,EAAA6B,cAAAgC,QAAA4D,OACA9M,MAAAgM,MAAAD,SAAAa,KAAA5M,KAAAgM,OAAAL,EAAA3L,KAAA+M,YAAA,GACA/M,KAAAgN,aAAAhN,KAAA+M,WAAA/M,KAAAiN,cH8mCoBnP,IAAK,eACLqH,MAAO,SGpmC3ByG,EAAAsB,GACA,GAAAlN,KAAAmN,aAAA,CACA,GAAAC,GAAApN,KAAAqN,WACAC,SAAAC,IAAAH,EAAA,UAAAA,EAAA,QAAA,iBACAxC,OAAA4C,WAAAxN,KAAAyN,MAAAb,KAAA5M,MAAA,SAEAkN,GAAAN,KAAA5M,MAAAA,KAAAiM,MAAAL,OH6mCoB9N,IAAK,QACLqH,MAAO,WGtmC3BnF,KAAAgM,MAAA,GAAAT,GACAvL,KAAAoM,KAAA,EACApM,KAAA0M,OAAAhD,YAAA,aHgnCoB5L,IAAK,gBACLqH,MAAO,WGzmC3B,GAAAqG,GAAAxL,KAAAgM,MAAAR,QACAkC,EAAA,SAAApM,EAAAiF,GACA,MAAAiF,GAAAjF,KAAA0E,EAEA,UAAA9H,OAAA3G,mBAAAgP,EAAAzK,SAAAwC,OAAAmK,EAAAd,KAAA5M,UHmnCoBlC,IAAK,aACLqH,MAAO,WG5mC3B,MAAAnF,MAAAqN,cAAArN,KAAA2N,gBAAA7Q,UHsnCoBgB,IAAK,YACLqH,MAAO,WACH,GAAIyI,GAAQ5N,KAER6N,GAA4B,EAC5BC,GAAoB,EACpBC,EAAiBlK,MAErB,KGtnCxB,IAAA,GAAAmK,GAAAC,EAAAjO,KAAAqM,MAAAlO,OAAAC,cAAAyP,GAAAG,EAAAC,EAAAC,QAAAC,MAAAN,GAAA,EAAA,CHwnCgC,GGxnChCO,GAAAJ,EAAA7I,MACA4F,EAAAqD,EAAA5K,IAAA,SAAAlC,GH0nCoC,MG1nCpCsM,GAAA5B,MAAAR,QAAAlK,IACA,IAAAwJ,EAAAC,GACA,MAAAA,GAAA,IH8nC0B,MAAOsD,GACLP,GAAoB,EACpBC,EAAiBM,EACnB,QACE,KACSR,GAA6BI,EAAAA,WAC9BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IGroC1C,MAAA,SH8pCoBjQ,IAAK,iBACLqH,MAAO,SG7oC3ByG,EAAA0C,GACA,GAAAlB,GAAApN,KAAAqN,WACA,OAAAD,KAAAxB,EACAN,EAAAgD,EACAlB,IAAApN,KAAAiM,MAAAL,IACAN,EAAAgD,EAEA,KHupCoBxQ,IAAK,UACLqH,MAAO,SGhpC3ByG,EAAA0C,GACA,GAAAC,GAAA1K,OACA2K,EAAA3K,OACA4K,GAAAnD,EHipC4BoD,GAA6B,EAC7BC,GAAqB,EACrBC,EAAkB/K,MAEtB,KGppCxB,IAAA,GAAAgL,GAAAC,EAAA9O,KAAA2N,gBAAAxP,OAAAC,cAAAsQ,GAAAG,EAAAC,EAAAZ,QAAAC,MAAAO,GAAA,EAAA,CHspCgC,GGtpChC/C,GAAAkD,EAAA1J,KACAqJ,GAAAxO,KAAA+O,SAAApD,EAAA2C,EAAAtO,KAAAiM,MAAAL,IACAN,EAAAA,GACAkD,EAAAC,IACAA,EAAAD,EACAD,EAAA5C,IHypC0B,MAAO0C,GACLM,GAAqB,EACrBC,EAAkBP,EACpB,QACE,KACSK,GAA8BI,EAAAA,WAC/BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IGhqC1C,MAAAL,MHyrCoBzQ,IAAK,WACLqH,MAAO,SGxqC3BwG,EAAA2C,EAAA1C,EAAAoD,EAAAC,GACA,IAEA,GADAjP,KAAAgM,MAAAD,SAAAJ,EAAAC,GACA5L,KAAAmN,aACA,MAAAnN,MAAAkP,eAAAtD,EAAA0C,EH0qC4B,IAAIa,IAA6B,EAC7BC,GAAqB,EACrBC,EAAkBxL,MAEtB,KG5qC5B,IAAA,GAAAyL,GAAAC,EAAAvP,KAAA2N,gBAAAxP,OAAAC,cAAA+Q,GAAAG,EAAAC,EAAArB,QAAAC,MAAAgB,GAAA,EAAA,CH8qCoC,GG9qCpCK,GAAAF,EAAAnK,KAIA,IAHA6J,EAAAS,KAAAhB,IAAAO,EACAhP,KAAA+O,SAAAS,EAAAlB,EAAA,EACAtO,KAAAiM,MAAAL,GAAAoD,EAAAC,IACAD,GAAAC,EACA,MAAAA,IHgrC8B,MAAOZ,GACLe,GAAqB,EACrBC,EAAkBhB,EACpB,QACE,KACSc,GAA8BI,EAAAA,WAC/BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IGvrC9C,MAAAL,GAbA,QAgBAhP,KAAAgM,MAAA0D,SAAA/D,OHgtCoB7N,IAAK,WACLqH,MAAO,SG9rC3BwG,EAAA2C,EAAA1C,EAAAoD,EAAAC,GACA,IAEA,GADAjP,KAAAgM,MAAAD,SAAAJ,EAAAC,GACA5L,KAAAmN,aACA,MAAAnN,MAAAkP,eAAAtD,EAAA0C,EHgsC4B,IAAIqB,IAA6B,EAC7BC,GAAqB,EACrBC,EAAkBhM,MAEtB,KGlsC5B,IAAA,GAAAiM,GAAAC,EAAA/P,KAAA2N,gBAAAxP,OAAAC,cAAAuR,GAAAG,EAAAC,EAAA7B,QAAAC,MAAAwB,GAAA,EAAA,CHosCoC,GGpsCpCK,GAAAF,EAAA3K,KAIA,IAHA8J,EAAAQ,KAAAQ,IAAAhB,EACAjP,KAAAkQ,SAAAF,EAAA1B,EAAA,EACAtO,KAAAiM,MAAAL,GAAAoD,EAAAC,IACAD,GAAAC,EACA,MAAAD,IHssC8B,MAAOX,GACLuB,GAAqB,EACrBC,EAAkBxB,EACpB,QACE,KACSsB,GAA8BI,EAAAA,WAC/BA,EAAAA,YAEN,QACE,GAAIH,EACA,KAAMC,IG7sC9C,MAAAZ,GAbA,QAgBAjP,KAAAgM,MAAA0D,SAAA/D,OH2tCoB7N,IAAK,YACLqH,MAAO,SGptC3ByG,GACA0B,QAAA6C,KAAA,YACAnQ,KAAAoQ,cACA,IAAAzE,GAAA9H,MAEA8H,GADA3L,KAAAoM,KACApM,KAAAqQ,QAAAzE,EAAA5L,KAAAoM,MAEAqD,KAAAa,MAAAb,KAAAc,SAAAvQ,KAAA2N,gBAAA7Q,QAEAkD,KAAAgM,MAAAD,SAAAJ,EAAAC,GAAA,GACA0B,QAAAkD,QAAA,YACAxQ,KAAAgN,aAAApB,EAAA5L,KAAAyQ,gBH6tCoB3S,IAAK,cACLqH,MAAO,SGvtC3ByG,GACA5L,KAAAoM,OACApM,KAAA0Q,iBHguCoB5S,IAAK,QACLqH,MAAO,WGztC3B,UAAAnF,KAAA2Q,UACA3Q,KAAAyQ,YAAAzQ,KAAA+M,YAEA/M,KAAAiN,UAAAjN,KAAAiM,MAAAjM,KAAA+M,iBA5QA3B,KAkRAC,EAAA,WAKA,QALAA,GAKAuF,GHiuCoB5T,gBAAgBgD,KGtuCpCqL,GAMArL,KAAA4Q,KAAAA,EACA5Q,KAAAsM,WACAtM,KAAAuM,aH4yCgB,MApEAnP,cGhvChBiO,IHivCoBvN,IAAK,WACLqH,MAAO,WGruC3BnF,KAAA6Q,QAAApQ,EAAA,UACAT,KAAA8Q,SAAArQ,EAAA,WACAT,KAAA+Q,OAAAtQ,EAAA,cACAT,KAAA0M,OAAAjM,EAAA,aH4uCoB3C,IAAK,aACLqH,MAAO,WGxuC3BnF,KAAA6Q,QAAA1J,GAAA,QAAAnH,KAAAgR,qBAAApE,KAAA5M,OACAA,KAAA8Q,SAAA3J,GAAA,QAAAnH,KAAAiR,sBAAArE,KAAA5M,OACAA,KAAA+Q,OAAA5J,GAAA,QAAAnH,KAAAkR,YAAAtE,KAAA5M,UHmvCoBlC,IAAK,uBACLqH,MAAO,SG5uC3BE,GACA,GAAA8L,GAAA1Q,EAAA4E,EAAA6B,cACAiK,GAAArH,SAAA,gBACA9J,KAAA6Q,QAAAlH,YAAA,cACA3J,KAAAgL,MAAAmG,EAAApP,KAAA,kBHwvCoBjE,IAAK,wBACLqH,MAAO,SG/uC3BE,GACA,GAAA8L,GAAA1Q,EAAA4E,EAAA6B,cACAiK,GAAArH,SAAA,gBACA9J,KAAA8Q,SAAAnH,YAAA,cACA3J,KAAA2Q,UAAAQ,EAAApP,KAAA,sBH0vCoBjE,IAAK,cACLqH,MAAO,SGlvC3BE,GACArF,KAAA4Q,KAAAD,UAAA3Q,KAAA2Q,WAAA,QACA3Q,KAAA4Q,KAAA7D,WAAA/M,KAAAgL,OAAA,IACAhL,KAAA0M,OAAArD,SAAA,UACArJ,KAAA4Q,KAAAQ,YA9DA/F,IAwEAH,UHoiCGmG,MAAQ,SAAS","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*!\n * jBone v1.1.2 - 2015-10-09 - Library for DOM manipulation\n *\n * http://jbone.js.org\n *\n * Copyright 2015 Alexey Kupriyanenko\n * Released under the MIT license.\n */\n\n(function (win) {\n\nvar\n// cache previous versions\n_$ = win.$,\n_jBone = win.jBone,\n\n// Quick match a standalone tag\nrquickSingleTag = /^<(\\w+)\\s*\\/?>$/,\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash\nrquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n\n// Alias for function\nslice = [].slice,\nsplice = [].splice,\nkeys = Object.keys,\n\n// Alias for global variables\ndoc = document,\n\nisString = function(el) {\n    return typeof el === \"string\";\n},\nisObject = function(el) {\n    return el instanceof Object;\n},\nisFunction = function(el) {\n    return ({}).toString.call(el) === \"[object Function]\";\n},\nisArray = function(el) {\n    return Array.isArray(el);\n},\njBone = function(element, data) {\n    return new fn.init(element, data);\n},\nfn;\n\n// set previous values and return the instance upon calling the no-conflict mode\njBone.noConflict = function() {\n    win.$ = _$;\n    win.jBone = _jBone;\n\n    return jBone;\n};\n\nfn = jBone.fn = jBone.prototype = {\n    init: function(element, data) {\n        var elements, tag, wraper, fragment;\n\n        if (!element) {\n            return this;\n        }\n        if (isString(element)) {\n            // Create single DOM element\n            if (tag = rquickSingleTag.exec(element)) {\n                this[0] = doc.createElement(tag[1]);\n                this.length = 1;\n\n                if (isObject(data)) {\n                    this.attr(data);\n                }\n\n                return this;\n            }\n            // Create DOM collection\n            if ((tag = rquickExpr.exec(element)) && tag[1]) {\n                fragment = doc.createDocumentFragment();\n                wraper = doc.createElement(\"div\");\n                wraper.innerHTML = element;\n                while (wraper.lastChild) {\n                    fragment.appendChild(wraper.firstChild);\n                }\n                elements = slice.call(fragment.childNodes);\n\n                return jBone.merge(this, elements);\n            }\n            // Find DOM elements with querySelectorAll\n            if (jBone.isElement(data)) {\n                return jBone(data).find(element);\n            }\n\n            try {\n                elements = doc.querySelectorAll(element);\n\n                return jBone.merge(this, elements);\n            } catch (e) {\n                return this;\n            }\n        }\n        // Wrap DOMElement\n        if (element.nodeType) {\n            this[0] = element;\n            this.length = 1;\n\n            return this;\n        }\n        // Run function\n        if (isFunction(element)) {\n            return element();\n        }\n        // Return jBone element as is\n        if (element instanceof jBone) {\n            return element;\n        }\n\n        // Return element wrapped by jBone\n        return jBone.makeArray(element, this);\n    },\n\n    pop: [].pop,\n    push: [].push,\n    reverse: [].reverse,\n    shift: [].shift,\n    sort: [].sort,\n    splice: [].splice,\n    slice: [].slice,\n    indexOf: [].indexOf,\n    forEach: [].forEach,\n    unshift: [].unshift,\n    concat: [].concat,\n    join: [].join,\n    every: [].every,\n    some: [].some,\n    filter: [].filter,\n    map: [].map,\n    reduce: [].reduce,\n    reduceRight: [].reduceRight,\n    length: 0\n};\n\nfn.constructor = jBone;\n\nfn.init.prototype = fn;\n\njBone.setId = function(el) {\n    var jid = el.jid;\n\n    if (el === win) {\n        jid = \"window\";\n    } else if (el.jid === undefined) {\n        el.jid = jid = ++jBone._cache.jid;\n    }\n\n    if (!jBone._cache.events[jid]) {\n        jBone._cache.events[jid] = {};\n    }\n};\n\njBone.getData = function(el) {\n    el = el instanceof jBone ? el[0] : el;\n\n    var jid = el === win ? \"window\" : el.jid;\n\n    return {\n        jid: jid,\n        events: jBone._cache.events[jid]\n    };\n};\n\njBone.isElement = function(el) {\n    return el && el instanceof jBone || el instanceof HTMLElement || isString(el);\n};\n\njBone._cache = {\n    events: {},\n    jid: 0\n};\n\nfunction isArraylike(obj) {\n    var length = obj.length,\n        type = typeof obj;\n\n    if (isFunction(type) || obj === win) {\n        return false;\n    }\n\n    if (obj.nodeType === 1 && length) {\n        return true;\n    }\n\n    return isArray(type) || length === 0 ||\n        typeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n\nfn.pushStack = function(elems) {\n    var ret = jBone.merge(this.constructor(), elems);\n\n    return ret;\n};\n\njBone.merge = function(first, second) {\n    var l = second.length,\n        i = first.length,\n        j = 0;\n\n    while (j < l) {\n        first[i++] = second[j++];\n    }\n\n    first.length = i;\n\n    return first;\n};\n\njBone.contains = function(container, contained) {\n    return container.contains(contained);\n};\n\njBone.extend = function(target) {\n    var tg;\n\n    splice.call(arguments, 1).forEach(function(source) {\n        tg = target; //caching target for perf improvement\n\n        if (source) {\n            for (var prop in source) {\n                tg[prop] = source[prop];\n            }\n        }\n    });\n\n    return target;\n};\n\njBone.makeArray = function(arr, results) {\n    var ret = results || [];\n\n    if (arr !== null) {\n        if (isArraylike(arr)) {\n            jBone.merge(ret, isString(arr) ? [arr] : arr);\n        } else {\n            ret.push(arr);\n        }\n    }\n\n    return ret;\n};\n\njBone.unique = function(array) {\n    if (array == null) {\n        return [];\n    }\n\n    var result = [];\n\n    for (var i = 0, length = array.length; i < length; i++) {\n        var value = array[i];\n        if (result.indexOf(value) < 0) {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nfunction BoneEvent(e, data) {\n    var key, setter;\n\n    this.originalEvent = e;\n\n    setter = function(key, e) {\n        if (key === \"preventDefault\") {\n            this[key] = function() {\n                this.defaultPrevented = true;\n                return e[key]();\n            };\n        } else if (key === \"stopImmediatePropagation\") {\n            this[key] = function() {\n                this.immediatePropagationStopped = true;\n                return e[key]();\n            };\n        } else if (isFunction(e[key])) {\n            this[key] = function() {\n                return e[key]();\n            };\n        } else {\n            this[key] = e[key];\n        }\n    };\n\n    for (key in e) {\n        if (e[key] || typeof e[key] === \"function\") {\n            setter.call(this, key, e);\n        }\n    }\n\n    jBone.extend(this, data, {\n        isImmediatePropagationStopped: function() {\n            return !!this.immediatePropagationStopped;\n        }\n    });\n}\n\njBone.Event = function(event, data) {\n    var namespace, eventType;\n\n    if (event.type && !data) {\n        data = event;\n        event = event.type;\n    }\n\n    namespace = event.split(\".\").splice(1).join(\".\");\n    eventType = event.split(\".\")[0];\n\n    event = doc.createEvent(\"Event\");\n    event.initEvent(eventType, true, true);\n\n    return jBone.extend(event, {\n        namespace: namespace,\n        isDefaultPrevented: function() {\n            return event.defaultPrevented;\n        }\n    }, data);\n};\n\njBone.event = {\n\n    /**\n     * Attach a handler to an event for the elements\n     * @param {Node}        el         - Events will be attached to this DOM Node\n     * @param {String}      types      - One or more space-separated event types and optional namespaces\n     * @param {Function}    handler    - A function to execute when the event is triggered\n     * @param {Object}      [data]     - Data to be passed to the handler in event.data\n     * @param {String}      [selector] - A selector string to filter the descendants of the selected elements\n     */\n    add: function(el, types, handler, data, selector) {\n        jBone.setId(el);\n\n        var eventHandler = function(e) {\n                jBone.event.dispatch.call(el, e);\n            },\n            events = jBone.getData(el).events,\n            eventType, t, event;\n\n        types = types.split(\" \");\n        t = types.length;\n        while (t--) {\n            event = types[t];\n\n            eventType = event.split(\".\")[0];\n            events[eventType] = events[eventType] || [];\n\n            if (events[eventType].length) {\n                // override with previous event handler\n                eventHandler = events[eventType][0].fn;\n            } else {\n                el.addEventListener && el.addEventListener(eventType, eventHandler, false);\n            }\n\n            events[eventType].push({\n                namespace: event.split(\".\").splice(1).join(\".\"),\n                fn: eventHandler,\n                selector: selector,\n                data: data,\n                originfn: handler\n            });\n        }\n    },\n\n    /**\n     * Remove an event handler\n     * @param  {Node}       el        - Events will be deattached from this DOM Node\n     * @param  {String}     types     - One or more space-separated event types and optional namespaces\n     * @param  {Function}   handler   - A handler function previously attached for the event(s)\n     */\n    remove: function(el, types, handler) {\n        var removeListener = function(events, eventType, index, el, e) {\n                var callback;\n\n                // get callback\n                if ((handler && e.originfn === handler) || !handler) {\n                    callback = e.fn;\n                }\n\n                if (events[eventType][index].fn === callback) {\n                    // remove handler from cache\n                    events[eventType].splice(index, 1);\n\n                    if (!events[eventType].length) {\n                        el.removeEventListener(eventType, callback);\n                    }\n                }\n            },\n            events = jBone.getData(el).events,\n            l,\n            eventsByType;\n\n        if (!events) {\n            return;\n        }\n\n        // remove all events\n        if (!types && events) {\n            return keys(events).forEach(function(eventType) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    removeListener(events, eventType, l, el, eventsByType[l]);\n                }\n            });\n        }\n\n        types.split(\" \").forEach(function(eventName) {\n            var eventType = eventName.split(\".\")[0],\n                namespace = eventName.split(\".\").splice(1).join(\".\"),\n                e;\n\n            // remove named events\n            if (events[eventType]) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    e = eventsByType[l];\n                    if (!namespace || (namespace && e.namespace === namespace)) {\n                        removeListener(events, eventType, l, el, e);\n                    }\n                }\n            }\n            // remove all namespaced events\n            else if (namespace) {\n                keys(events).forEach(function(eventType) {\n                    eventsByType = events[eventType];\n                    l = eventsByType.length;\n\n                    while(l--) {\n                        e = eventsByType[l];\n                        if (e.namespace.split(\".\")[0] === namespace.split(\".\")[0]) {\n                            removeListener(events, eventType, l, el, e);\n                        }\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Execute all handlers and behaviors attached to the matched elements for the given event type.\n     * @param  {Node}       el       - Events will be triggered for thie DOM Node\n     * @param  {String}     event    - One or more space-separated event types and optional namespaces\n     */\n    trigger: function(el, event) {\n        var events = [];\n\n        if (isString(event)) {\n            events = event.split(\" \").map(function(event) {\n                return jBone.Event(event);\n            });\n        } else {\n            event = event instanceof Event ? event : jBone.Event(event);\n            events = [event];\n        }\n\n        events.forEach(function(event) {\n            if (!event.type) {\n                return;\n            }\n\n            el.dispatchEvent && el.dispatchEvent(event);\n        });\n    },\n\n    dispatch: function(e) {\n        var i = 0,\n            j = 0,\n            el = this,\n            handlers = jBone.getData(el).events[e.type],\n            length = handlers.length,\n            handlerQueue = [],\n            targets = [],\n            l,\n            expectedTarget,\n            handler,\n            event,\n            eventOptions;\n\n        // cache all events handlers, fix issue with multiple handlers (issue #45)\n        for (; i < length; i++) {\n            handlerQueue.push(handlers[i]);\n        }\n\n        i = 0;\n        length = handlerQueue.length;\n\n        for (;\n            // if event exists\n            i < length &&\n            // if handler is not removed from stack\n            ~handlers.indexOf(handlerQueue[i]) &&\n            // if propagation is not stopped\n            !(event && event.isImmediatePropagationStopped());\n        i++) {\n            expectedTarget = null;\n            eventOptions = {};\n            handler = handlerQueue[i];\n            handler.data && (eventOptions.data = handler.data);\n\n            // event handler without selector\n            if (!handler.selector) {\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(el, event);\n                }\n            }\n            // event handler with selector\n            else if (\n                // if target and selected element the same\n                ~(targets = jBone(el).find(handler.selector)).indexOf(e.target) && (expectedTarget = e.target) ||\n                // if one of element matched with selector contains target\n                (el !== e.target && el.contains(e.target))\n            ) {\n                // get element matched with selector\n                if (!expectedTarget) {\n                    l = targets.length;\n                    j = 0;\n\n                    for (; j < l; j++) {\n                        if (targets[j] && targets[j].contains(e.target)) {\n                            expectedTarget = targets[j];\n                        }\n                    }\n                }\n\n                if (!expectedTarget) {\n                    continue;\n                }\n\n                eventOptions.currentTarget = expectedTarget;\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(expectedTarget, event);\n                }\n            }\n        }\n    }\n};\n\nfn.on = function(types, selector, data, fn) {\n    var length = this.length,\n        i = 0;\n\n    if (data == null && fn == null) {\n        // (types, fn)\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === \"string\") {\n            // (types, selector, fn)\n            fn = data;\n            data = undefined;\n        } else {\n            // (types, data, fn)\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n\n    if (!fn) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.add(this[i], types, fn, data, selector);\n    }\n\n    return this;\n};\n\nfn.one = function(event) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        oneArgs = slice.call(args, 1, args.length - 1),\n        callback = slice.call(args, -1)[0],\n        addListener;\n\n    addListener = function(el) {\n        var $el = jBone(el);\n\n        event.split(\" \").forEach(function(event) {\n            var fn = function(e) {\n                $el.off(event, fn);\n                callback.call(el, e);\n            };\n\n            $el.on.apply($el, [event].concat(oneArgs, fn));\n        });\n    };\n\n    for (; i < length; i++) {\n        addListener(this[i]);\n    }\n\n    return this;\n};\n\nfn.trigger = function(event) {\n    var i = 0,\n        length = this.length;\n\n    if (!event) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.trigger(this[i], event);\n    }\n\n    return this;\n};\n\nfn.off = function(types, handler) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        jBone.event.remove(this[i], types, handler);\n    }\n\n    return this;\n};\n\nfn.find = function(selector) {\n    var results = [],\n        i = 0,\n        length = this.length,\n        finder = function(el) {\n            if (isFunction(el.querySelectorAll)) {\n                [].forEach.call(el.querySelectorAll(selector), function(found) {\n                    results.push(found);\n                });\n            }\n        };\n\n    for (; i < length; i++) {\n        finder(this[i]);\n    }\n\n    return jBone(results);\n};\n\nfn.get = function(index) {\n    return index != null ?\n\n        // Return just one element from the set\n        (index < 0 ? this[index + this.length] : this[index]) :\n\n        // Return all the elements in a clean array\n        slice.call(this);\n};\n\nfn.eq = function(index) {\n    return jBone(this[index]);\n};\n\nfn.parent = function() {\n    var results = [],\n        parent,\n        i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        if (!~results.indexOf(parent = this[i].parentElement) && parent) {\n            results.push(parent);\n        }\n    }\n\n    return jBone(results);\n};\n\nfn.toArray = function() {\n    return slice.call(this);\n};\n\nfn.is = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.tagName.toLowerCase() === args[0];\n    });\n};\n\nfn.has = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.querySelectorAll(args[0]).length;\n    });\n};\n\nfn.add = function(selector, context) {\n    return this.pushStack(\n        jBone.unique(\n            jBone.merge(this.get(), jBone(selector, context))\n        )\n    );\n};\n\nfn.attr = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    if (isString(key) && args.length === 1) {\n        return this[0] && this[0].getAttribute(key);\n    }\n\n    if (args.length === 2) {\n        setter = function(el) {\n            el.setAttribute(key, value);\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.setAttribute(name, key[name]);\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeAttr = function(key) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        this[i].removeAttribute(key);\n    }\n\n    return this;\n};\n\nfn.val = function(value) {\n    var i = 0,\n        length = this.length;\n\n    if (arguments.length === 0) {\n        return this[0] && this[0].value;\n    }\n\n    for (; i < length; i++) {\n        this[i].value = value;\n    }\n\n    return this;\n};\n\nfn.css = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    // Get attribute\n    if (isString(key) && args.length === 1) {\n        return this[0] && win.getComputedStyle(this[0])[key];\n    }\n\n    // Set attributes\n    if (args.length === 2) {\n        setter = function(el) {\n            el.style[key] = value;\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.style[name] = key[name];\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.data = function(key, value) {\n    var args = arguments, data = {},\n        i = 0,\n        length = this.length,\n        setter,\n        setValue = function(el, key, value) {\n            if (isObject(value)) {\n                el.jdata = el.jdata || {};\n                el.jdata[key] = value;\n            } else {\n                el.dataset[key] = value;\n            }\n        },\n        getValue = function(value) {\n            if (value === \"true\") {\n                return true;\n            } else if (value === \"false\") {\n                return false;\n            } else {\n                return value;\n            }\n        };\n\n    // Get all data\n    if (args.length === 0) {\n        this[0].jdata && (data = this[0].jdata);\n\n        keys(this[0].dataset).forEach(function(key) {\n            data[key] = getValue(this[0].dataset[key]);\n        }, this);\n\n        return data;\n    }\n    // Get data by name\n    if (args.length === 1 && isString(key)) {\n        return this[0] && getValue(this[0].dataset[key] || this[0].jdata && this[0].jdata[key]);\n    }\n\n    // Set data\n    if (args.length === 1 && isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                setValue(el, name, key[name]);\n            });\n        };\n    } else if (args.length === 2) {\n        setter = function(el) {\n            setValue(el, key, value);\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeData = function(key) {\n    var i = 0,\n        length = this.length,\n        jdata, dataset;\n\n    for (; i < length; i++) {\n        jdata = this[i].jdata;\n        dataset = this[i].dataset;\n\n        if (key) {\n            jdata && jdata[key] && delete jdata[key];\n            delete dataset[key];\n        } else {\n            for (key in jdata) {\n                delete jdata[key];\n            }\n\n            for (key in dataset) {\n                delete dataset[key];\n            }\n        }\n    }\n\n    return this;\n};\n\nfn.addClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.add(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.removeClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.remove(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.toggleClass = function(className, force) {\n    var i = 0,\n        length = this.length,\n        method = \"toggle\";\n\n    force === true && (method = \"add\") || force === false && (method = \"remove\");\n\n    if (className) {\n        for (; i < length; i++) {\n            this[i].classList[method](className);\n        }\n    }\n\n    return this;\n};\n\nfn.hasClass = function(className) {\n    var i = 0, length = this.length;\n\n    if (className) {\n        for (; i < length; i++) {\n            if (this[i].classList.contains(className)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\nfn.html = function(value) {\n    var args = arguments,\n        el;\n\n    // add HTML into elements\n    if (args.length === 1 && value !== undefined) {\n        return this.empty().append(value);\n    }\n    // get HTML from element\n    else if (args.length === 0 && (el = this[0])) {\n        return el.innerHTML;\n    }\n\n    return this;\n};\n\nfn.append = function(appended) {\n    var i = 0,\n        length = this.length,\n        setter;\n\n    // create jBone object and then append\n    if (isString(appended) && rquickExpr.exec(appended)) {\n        appended = jBone(appended);\n    }\n    // create text node for insertion\n    else if (!isObject(appended)) {\n        appended = document.createTextNode(appended);\n    }\n\n    appended = appended instanceof jBone ? appended : jBone(appended);\n\n    setter = function(el, i) {\n        appended.forEach(function(node) {\n            if (i) {\n                el.appendChild(node.cloneNode(true));\n            } else {\n                el.appendChild(node);\n            }\n        });\n    };\n\n    for (; i < length; i++) {\n        setter(this[i], i);\n    }\n\n    return this;\n};\n\nfn.appendTo = function(to) {\n    jBone(to).append(this);\n\n    return this;\n};\n\nfn.empty = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        while (el.lastChild) {\n            el.removeChild(el.lastChild);\n        }\n    }\n\n    return this;\n};\n\nfn.remove = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    // remove all listeners\n    this.off();\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        // remove data and nodes\n        delete el.jdata;\n        el.parentNode && el.parentNode.removeChild(el);\n    }\n\n    return this;\n};\n\nif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\n    // Expose jBone as module.exports in loaders that implement the Node\n    // module pattern (including browserify). Do not create the global, since\n    // the user will be storing it themselves locally, and globals are frowned\n    // upon in the Node module world.\n    module.exports = jBone;\n}\n// Register as a AMD module\nelse if (typeof define === \"function\" && define.amd) {\n    define(function() {\n        return jBone;\n    });\n\n    win.jBone = win.$ = jBone;\n} else if (typeof win === \"object\" && typeof win.document === \"object\") {\n    win.jBone = win.$ = jBone;\n}\n\n}(window));\n\n},{}],2:[function(require,module,exports){\n(function(){\n    /** Library imports for Browserify */\n    let $ = require('jbone');\n\n    /** @constant {String} EMPTY - Represent an EMPTY square in the board */\n    const EMPTY = '*';\n    /** @constant {String} X - The X token for the board*/\n    const X = 'X';\n    /** @constant {String} O - The O token for the board */\n    const O = 'O';\n    /**\n     * @constant {Number} TOP - The maximum value to be used by the search\n     * tree algorithm.\n     */\n    const TOP = 100;\n    /**\n     * @constant {picoModal} MODAL - Modal for choose token and player one of\n     * the game.\n     */\n    // const MODAL = ;\n\n    /**\n     * Answer if the row isn't empty and all their elements are equal.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @returns {Boolean} True if all line elements are equal and not the\n     * empty token, false otherwise.\n     */\n    function threeInARow(row) {\n        let token = row[0];\n        if (token !== EMPTY) {\n            return row.every(element => element === token);\n        }\n    }\n\n    /** Class representing a board. */\n    class Board {\n        /** Create a board. */\n        constructor() {\n            this.squares = Array(9).fill(EMPTY);\n            this.getReady();\n        }\n\n        /** Clear and prepare the board for a new game */\n        getReady() {\n            for (let i = 0; i < 9; i++) {\n                this[`$square${i}`] = $(`#square${i}`);\n                this[`$square${i}`].html('').removeAttr('disabled');\n            }\n        }\n\n        /**\n         * Place the token of a player in the board.\n         * @param {Number} move - The position where the token will be placed.\n         * @param {String} player - The token of the player.\n         * @param {Boolean} [realMove=false] - If the move is a real move in\n         * the board, not a move done by the search tree algorithm.\n         */\n        makeMove(move, player, realMove=false) {\n            this.squares[move] = player;\n            if (realMove) {\n                let tokenAlt = (player === 'X')? 'Cross': 'Circle';\n                let token = `<img class=\"token-img\" src=\"assets/images/${player}.svg\" alt=\"${tokenAlt}\">`;\n                this[`$square${move}`].html(token).attr('disabled', '');\n            }\n        }\n\n        /**\n         * Remove the player token in the given position of the board.\n         * @param {Number} move - The position of the token to be erased.\n         */\n        undoMove(move) {\n            this.makeMove(move, EMPTY);\n        }\n    }\n\n    /** Class representing a Tic Tac Toe game */\n    class TicTacToe {\n        /**\n         * Create a Tic Tac Toe game.\n         * @property {Board} board - The board where the game is played.\n         * @property {Object.<String, String>} - Pairs each token with their\n         * opposite, for easy switching between player tokens.\n         * @property {Number} turn - The actual turn of the game.\n         * @property {Array[]} lines - Array of winning lines in a Tic Tac Toe\n         * game.\n         */\n        constructor() {\n            this.board = new Board();\n            this.rival = {'O': 'X', 'X': 'O'};\n            this.turn = 0;\n            this.lines= [[0,1,2], [3,4,5], [6,7,8], // vertical\n                        [0,3,6], [1,4,7], [2,5,8], // horizontal\n                        [0,4,8],[2,4,6]];          // diagonal\n\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the board */\n        cacheDom() {\n            this.$board = $('#board');\n            this.$square = $('.square');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$square.on('click', this.handleMove.bind(this));\n        }\n\n        /** Enable the board, making it clickable. */\n        enableBoard() {\n            this.$board.removeClass('disabled');\n        }\n\n        /** Disable the board, making it unclickable. */\n        disableBoard() {\n            this.$board.addClass('disabled');\n        }\n\n        /**\n         * Handle an user move try.\n         * @param {Object} event - The event associated to a click\n         * in a board square (a move) made by the user.\n         */\n        handleMove(event) {\n            let move = Number(event.currentTarget.dataset.square);\n            this.board.makeMove.bind(this.board)(move, this.humanToken, true);\n            this.continueGame(this.humanToken, this.cpuPlayer);\n        }\n\n        /**\n         * Check if the game can continue or not and act according to that.\n         * If game can continue, run the next player turn.\n         * If not, announce the result, reset the game and show the modal.\n         * @param {String} player - The token of the actual player.\n         * @param {Function} playerFunction - The function to execute if the\n         * game should continue.\n         */\n        continueGame(player, playerFunction) {\n            if (this.isGameOver()) {\n                let winner = this.getWinner();\n                console.log((winner)? `Player ${winner} won.`:'It was a tie.');\n                window.setTimeout(this.reset.bind(this), 800);\n            } else {\n                playerFunction.bind(this)(this.rival[player]);\n            }\n        }\n\n        /**\n         * Reset a Tic Tac Toe Game.\n         */\n        reset() {\n            this.board = new Board();\n            this.turn = 0;\n            this.$modal.removeClass('hidden');\n        }\n\n        /**\n         * Get squares still available (empty) in the board.\n         * @returns {Number[]} List of empty squares in the board.\n         */\n        getValidMoves() {\n            let squares = this.board.squares;\n            let emptySquare = function(element, index) {\n                return squares[index] === EMPTY;\n            };\n            return [...squares.keys()].filter(emptySquare.bind(this));\n        }\n\n        /**\n         * Answer if the game has come to an end.\n         * @returns {Boolean} True or false if game has come to an end or not.\n         */\n        isGameOver() {\n            return this.getWinner() || !this.getValidMoves().length;\n        }\n\n        /**\n         * Get the token of the winner player.\n         * @returns {?String} The token of the actual winner. null means a tie.\n         */\n        getWinner() {\n            for (let line of this.lines) {\n                let row = line.map(element => this.board.squares[element]);\n                if (threeInARow(row)) {\n                    return row[0];\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Evaluate (score) the state of the player at the end of a game.\n         * The possible states are: «Win» (a positive number),\n         * «Lose» (a negative) or «Tie» (zero).\n         * Take the number of moves done (depth) into account. Not taking that\n         * into account leads to a CPU playing awfully: a win in 4 moves is\n         * more valuable that one achieved in 6.\n         * @param {String} player - The token of the player which state is\n         * being evaluated.\n         * @param {Number} depth - The number of moves done to reach the actual\n         * state of the game.\n         *\n         * @returns {Number} The score of the actual state from the player\n         * perspective.\n         */\n        evalFinalState(player, depth) {\n            let winner = this.getWinner();\n            if (winner === player) {\n                return TOP - depth;\n            } else if (winner === this.rival[player]) {\n                return -TOP + depth;\n            }\n            return 0;\n        }\n\n        /**\n         * Implement search of the best move to execute next in the game.\n         * Use MiniMax algorithm enhanced with alpha-beta pruning.\n         * @returns {Number} bestMove - Best move to do next to play perfectly.\n         */\n        minimax(player, depth) {\n            let bestMove,\n                currentMax,\n                max = -TOP;\n            for (let move of this.getValidMoves()) {\n                currentMax = this.minValue(move, depth, this.rival[player],\n                                           -TOP, TOP);\n                if (currentMax > max) {\n                    max = currentMax;\n                    bestMove = move;\n                }\n            }\n            return bestMove;\n        }\n\n        /**\n         * Evaluate the given position and get the best result the player could\n         * achieve from that.\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Best situation the player could achieve from the\n         * given position.\n         */\n        maxValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    α = Math.max(α,\n                                 this.minValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return β;\n                    }\n                }\n                return α;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Evaluate the given position and get the worst result for the player\n         * opponent (the best for the player).\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Worst situation the opponent player could achieve\n         * from the given position.\n         */\n        minValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    β = Math.min(β,\n                                 this.maxValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return α;\n                    }\n                }\n                return β;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Run cpu player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        cpuPlayer(player) {\n            console.time('cpu move');\n            this.disableBoard();\n            let move;\n            if (this.turn) {\n                move = this.minimax(player, this.turn);\n            } else {\n                move = Math.floor(Math.random() * this.getValidMoves().length);\n            }\n            this.board.makeMove(move, player, true);\n            console.timeEnd('cpu move');\n            this.continueGame(player, this.humanPlayer);\n        }\n\n        /**\n         * Run human player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        humanPlayer(player) {\n            this.turn++;\n            this.enableBoard();\n        }\n\n        /**\n         * Start the Tic Tac Toe game.\n         * An OptionsModal should be instantiated for this to work.\n         */\n        start() {\n            if (this.playerOne === 'human') {\n                this.humanPlayer(this.humanToken);\n            } else {\n                this.cpuPlayer(this.rival[this.humanToken]);\n            }\n        }\n    }\n\n    /** Class representing an options modal window for the game. */\n    class OptionsModal {\n        /**\n         * Create a modal for a Tic Tac Toe game.\n         * @param {Object} game - A TicTacToe instance.\n         */\n        constructor(game) {\n            this.game = game;\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the modal */\n        cacheDom() {\n            this.$tokens = $('.token');\n            this.$players = $('.player');\n            this.$start = $('#start-btn');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$tokens.on('click', this.handleTokenSelection.bind(this));\n            this.$players.on('click', this.handlePlayerSelection.bind(this));\n            this.$start.on('click', this.handleStart.bind(this));\n        }\n\n        /**\n         * Handle the token selection by the user.\n         * @param {Object} event - The event associated to a click\n         * in a token button made by the user, choosing their token.\n         */\n        handleTokenSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$tokens.toggleClass('unselected');\n                this.token = $this.attr('data-token');\n            }\n        }\n\n        /**\n         * Handle the selection of player one by the user.\n         * @param {Object} event - The event associated to a click\n         * in a player button made by the user, choosing which player\n         * will start the game.\n         */\n        handlePlayerSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$players.toggleClass('unselected');\n                this.playerOne = $this.attr('data-playerone');\n            }\n        }\n\n        /**\n         * Handle the click in the modal start button by the user.\n         * @param {Object} event - The event associated to a click\n         * in the start button made by the user, for starting the game.\n         */\n        handleStart(event) {\n            this.game.playerOne = this.playerOne || 'human';\n            this.game.humanToken = this.token || 'X';\n            this.$modal.addClass('hidden');\n            this.game.start();\n        }\n    }\n\n    /** Create and launch a Tic Tac Toe game. */\n    function newGame(){\n        let ttt = new TicTacToe();\n        let modal = new OptionsModal(ttt);\n    }\n\n    newGame();\n})();\n},{\"jbone\":1}]},{},[2])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * jBone v1.1.2 - 2015-10-09 - Library for DOM manipulation\n *\n * http://jbone.js.org\n *\n * Copyright 2015 Alexey Kupriyanenko\n * Released under the MIT license.\n */\n\n(function (win) {\n\nvar\n// cache previous versions\n_$ = win.$,\n_jBone = win.jBone,\n\n// Quick match a standalone tag\nrquickSingleTag = /^<(\\w+)\\s*\\/?>$/,\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash\nrquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n\n// Alias for function\nslice = [].slice,\nsplice = [].splice,\nkeys = Object.keys,\n\n// Alias for global variables\ndoc = document,\n\nisString = function(el) {\n    return typeof el === \"string\";\n},\nisObject = function(el) {\n    return el instanceof Object;\n},\nisFunction = function(el) {\n    return ({}).toString.call(el) === \"[object Function]\";\n},\nisArray = function(el) {\n    return Array.isArray(el);\n},\njBone = function(element, data) {\n    return new fn.init(element, data);\n},\nfn;\n\n// set previous values and return the instance upon calling the no-conflict mode\njBone.noConflict = function() {\n    win.$ = _$;\n    win.jBone = _jBone;\n\n    return jBone;\n};\n\nfn = jBone.fn = jBone.prototype = {\n    init: function(element, data) {\n        var elements, tag, wraper, fragment;\n\n        if (!element) {\n            return this;\n        }\n        if (isString(element)) {\n            // Create single DOM element\n            if (tag = rquickSingleTag.exec(element)) {\n                this[0] = doc.createElement(tag[1]);\n                this.length = 1;\n\n                if (isObject(data)) {\n                    this.attr(data);\n                }\n\n                return this;\n            }\n            // Create DOM collection\n            if ((tag = rquickExpr.exec(element)) && tag[1]) {\n                fragment = doc.createDocumentFragment();\n                wraper = doc.createElement(\"div\");\n                wraper.innerHTML = element;\n                while (wraper.lastChild) {\n                    fragment.appendChild(wraper.firstChild);\n                }\n                elements = slice.call(fragment.childNodes);\n\n                return jBone.merge(this, elements);\n            }\n            // Find DOM elements with querySelectorAll\n            if (jBone.isElement(data)) {\n                return jBone(data).find(element);\n            }\n\n            try {\n                elements = doc.querySelectorAll(element);\n\n                return jBone.merge(this, elements);\n            } catch (e) {\n                return this;\n            }\n        }\n        // Wrap DOMElement\n        if (element.nodeType) {\n            this[0] = element;\n            this.length = 1;\n\n            return this;\n        }\n        // Run function\n        if (isFunction(element)) {\n            return element();\n        }\n        // Return jBone element as is\n        if (element instanceof jBone) {\n            return element;\n        }\n\n        // Return element wrapped by jBone\n        return jBone.makeArray(element, this);\n    },\n\n    pop: [].pop,\n    push: [].push,\n    reverse: [].reverse,\n    shift: [].shift,\n    sort: [].sort,\n    splice: [].splice,\n    slice: [].slice,\n    indexOf: [].indexOf,\n    forEach: [].forEach,\n    unshift: [].unshift,\n    concat: [].concat,\n    join: [].join,\n    every: [].every,\n    some: [].some,\n    filter: [].filter,\n    map: [].map,\n    reduce: [].reduce,\n    reduceRight: [].reduceRight,\n    length: 0\n};\n\nfn.constructor = jBone;\n\nfn.init.prototype = fn;\n\njBone.setId = function(el) {\n    var jid = el.jid;\n\n    if (el === win) {\n        jid = \"window\";\n    } else if (el.jid === undefined) {\n        el.jid = jid = ++jBone._cache.jid;\n    }\n\n    if (!jBone._cache.events[jid]) {\n        jBone._cache.events[jid] = {};\n    }\n};\n\njBone.getData = function(el) {\n    el = el instanceof jBone ? el[0] : el;\n\n    var jid = el === win ? \"window\" : el.jid;\n\n    return {\n        jid: jid,\n        events: jBone._cache.events[jid]\n    };\n};\n\njBone.isElement = function(el) {\n    return el && el instanceof jBone || el instanceof HTMLElement || isString(el);\n};\n\njBone._cache = {\n    events: {},\n    jid: 0\n};\n\nfunction isArraylike(obj) {\n    var length = obj.length,\n        type = typeof obj;\n\n    if (isFunction(type) || obj === win) {\n        return false;\n    }\n\n    if (obj.nodeType === 1 && length) {\n        return true;\n    }\n\n    return isArray(type) || length === 0 ||\n        typeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n\nfn.pushStack = function(elems) {\n    var ret = jBone.merge(this.constructor(), elems);\n\n    return ret;\n};\n\njBone.merge = function(first, second) {\n    var l = second.length,\n        i = first.length,\n        j = 0;\n\n    while (j < l) {\n        first[i++] = second[j++];\n    }\n\n    first.length = i;\n\n    return first;\n};\n\njBone.contains = function(container, contained) {\n    return container.contains(contained);\n};\n\njBone.extend = function(target) {\n    var tg;\n\n    splice.call(arguments, 1).forEach(function(source) {\n        tg = target; //caching target for perf improvement\n\n        if (source) {\n            for (var prop in source) {\n                tg[prop] = source[prop];\n            }\n        }\n    });\n\n    return target;\n};\n\njBone.makeArray = function(arr, results) {\n    var ret = results || [];\n\n    if (arr !== null) {\n        if (isArraylike(arr)) {\n            jBone.merge(ret, isString(arr) ? [arr] : arr);\n        } else {\n            ret.push(arr);\n        }\n    }\n\n    return ret;\n};\n\njBone.unique = function(array) {\n    if (array == null) {\n        return [];\n    }\n\n    var result = [];\n\n    for (var i = 0, length = array.length; i < length; i++) {\n        var value = array[i];\n        if (result.indexOf(value) < 0) {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nfunction BoneEvent(e, data) {\n    var key, setter;\n\n    this.originalEvent = e;\n\n    setter = function(key, e) {\n        if (key === \"preventDefault\") {\n            this[key] = function() {\n                this.defaultPrevented = true;\n                return e[key]();\n            };\n        } else if (key === \"stopImmediatePropagation\") {\n            this[key] = function() {\n                this.immediatePropagationStopped = true;\n                return e[key]();\n            };\n        } else if (isFunction(e[key])) {\n            this[key] = function() {\n                return e[key]();\n            };\n        } else {\n            this[key] = e[key];\n        }\n    };\n\n    for (key in e) {\n        if (e[key] || typeof e[key] === \"function\") {\n            setter.call(this, key, e);\n        }\n    }\n\n    jBone.extend(this, data, {\n        isImmediatePropagationStopped: function() {\n            return !!this.immediatePropagationStopped;\n        }\n    });\n}\n\njBone.Event = function(event, data) {\n    var namespace, eventType;\n\n    if (event.type && !data) {\n        data = event;\n        event = event.type;\n    }\n\n    namespace = event.split(\".\").splice(1).join(\".\");\n    eventType = event.split(\".\")[0];\n\n    event = doc.createEvent(\"Event\");\n    event.initEvent(eventType, true, true);\n\n    return jBone.extend(event, {\n        namespace: namespace,\n        isDefaultPrevented: function() {\n            return event.defaultPrevented;\n        }\n    }, data);\n};\n\njBone.event = {\n\n    /**\n     * Attach a handler to an event for the elements\n     * @param {Node}        el         - Events will be attached to this DOM Node\n     * @param {String}      types      - One or more space-separated event types and optional namespaces\n     * @param {Function}    handler    - A function to execute when the event is triggered\n     * @param {Object}      [data]     - Data to be passed to the handler in event.data\n     * @param {String}      [selector] - A selector string to filter the descendants of the selected elements\n     */\n    add: function(el, types, handler, data, selector) {\n        jBone.setId(el);\n\n        var eventHandler = function(e) {\n                jBone.event.dispatch.call(el, e);\n            },\n            events = jBone.getData(el).events,\n            eventType, t, event;\n\n        types = types.split(\" \");\n        t = types.length;\n        while (t--) {\n            event = types[t];\n\n            eventType = event.split(\".\")[0];\n            events[eventType] = events[eventType] || [];\n\n            if (events[eventType].length) {\n                // override with previous event handler\n                eventHandler = events[eventType][0].fn;\n            } else {\n                el.addEventListener && el.addEventListener(eventType, eventHandler, false);\n            }\n\n            events[eventType].push({\n                namespace: event.split(\".\").splice(1).join(\".\"),\n                fn: eventHandler,\n                selector: selector,\n                data: data,\n                originfn: handler\n            });\n        }\n    },\n\n    /**\n     * Remove an event handler\n     * @param  {Node}       el        - Events will be deattached from this DOM Node\n     * @param  {String}     types     - One or more space-separated event types and optional namespaces\n     * @param  {Function}   handler   - A handler function previously attached for the event(s)\n     */\n    remove: function(el, types, handler) {\n        var removeListener = function(events, eventType, index, el, e) {\n                var callback;\n\n                // get callback\n                if ((handler && e.originfn === handler) || !handler) {\n                    callback = e.fn;\n                }\n\n                if (events[eventType][index].fn === callback) {\n                    // remove handler from cache\n                    events[eventType].splice(index, 1);\n\n                    if (!events[eventType].length) {\n                        el.removeEventListener(eventType, callback);\n                    }\n                }\n            },\n            events = jBone.getData(el).events,\n            l,\n            eventsByType;\n\n        if (!events) {\n            return;\n        }\n\n        // remove all events\n        if (!types && events) {\n            return keys(events).forEach(function(eventType) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    removeListener(events, eventType, l, el, eventsByType[l]);\n                }\n            });\n        }\n\n        types.split(\" \").forEach(function(eventName) {\n            var eventType = eventName.split(\".\")[0],\n                namespace = eventName.split(\".\").splice(1).join(\".\"),\n                e;\n\n            // remove named events\n            if (events[eventType]) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    e = eventsByType[l];\n                    if (!namespace || (namespace && e.namespace === namespace)) {\n                        removeListener(events, eventType, l, el, e);\n                    }\n                }\n            }\n            // remove all namespaced events\n            else if (namespace) {\n                keys(events).forEach(function(eventType) {\n                    eventsByType = events[eventType];\n                    l = eventsByType.length;\n\n                    while(l--) {\n                        e = eventsByType[l];\n                        if (e.namespace.split(\".\")[0] === namespace.split(\".\")[0]) {\n                            removeListener(events, eventType, l, el, e);\n                        }\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Execute all handlers and behaviors attached to the matched elements for the given event type.\n     * @param  {Node}       el       - Events will be triggered for thie DOM Node\n     * @param  {String}     event    - One or more space-separated event types and optional namespaces\n     */\n    trigger: function(el, event) {\n        var events = [];\n\n        if (isString(event)) {\n            events = event.split(\" \").map(function(event) {\n                return jBone.Event(event);\n            });\n        } else {\n            event = event instanceof Event ? event : jBone.Event(event);\n            events = [event];\n        }\n\n        events.forEach(function(event) {\n            if (!event.type) {\n                return;\n            }\n\n            el.dispatchEvent && el.dispatchEvent(event);\n        });\n    },\n\n    dispatch: function(e) {\n        var i = 0,\n            j = 0,\n            el = this,\n            handlers = jBone.getData(el).events[e.type],\n            length = handlers.length,\n            handlerQueue = [],\n            targets = [],\n            l,\n            expectedTarget,\n            handler,\n            event,\n            eventOptions;\n\n        // cache all events handlers, fix issue with multiple handlers (issue #45)\n        for (; i < length; i++) {\n            handlerQueue.push(handlers[i]);\n        }\n\n        i = 0;\n        length = handlerQueue.length;\n\n        for (;\n            // if event exists\n            i < length &&\n            // if handler is not removed from stack\n            ~handlers.indexOf(handlerQueue[i]) &&\n            // if propagation is not stopped\n            !(event && event.isImmediatePropagationStopped());\n        i++) {\n            expectedTarget = null;\n            eventOptions = {};\n            handler = handlerQueue[i];\n            handler.data && (eventOptions.data = handler.data);\n\n            // event handler without selector\n            if (!handler.selector) {\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(el, event);\n                }\n            }\n            // event handler with selector\n            else if (\n                // if target and selected element the same\n                ~(targets = jBone(el).find(handler.selector)).indexOf(e.target) && (expectedTarget = e.target) ||\n                // if one of element matched with selector contains target\n                (el !== e.target && el.contains(e.target))\n            ) {\n                // get element matched with selector\n                if (!expectedTarget) {\n                    l = targets.length;\n                    j = 0;\n\n                    for (; j < l; j++) {\n                        if (targets[j] && targets[j].contains(e.target)) {\n                            expectedTarget = targets[j];\n                        }\n                    }\n                }\n\n                if (!expectedTarget) {\n                    continue;\n                }\n\n                eventOptions.currentTarget = expectedTarget;\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(expectedTarget, event);\n                }\n            }\n        }\n    }\n};\n\nfn.on = function(types, selector, data, fn) {\n    var length = this.length,\n        i = 0;\n\n    if (data == null && fn == null) {\n        // (types, fn)\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === \"string\") {\n            // (types, selector, fn)\n            fn = data;\n            data = undefined;\n        } else {\n            // (types, data, fn)\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n\n    if (!fn) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.add(this[i], types, fn, data, selector);\n    }\n\n    return this;\n};\n\nfn.one = function(event) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        oneArgs = slice.call(args, 1, args.length - 1),\n        callback = slice.call(args, -1)[0],\n        addListener;\n\n    addListener = function(el) {\n        var $el = jBone(el);\n\n        event.split(\" \").forEach(function(event) {\n            var fn = function(e) {\n                $el.off(event, fn);\n                callback.call(el, e);\n            };\n\n            $el.on.apply($el, [event].concat(oneArgs, fn));\n        });\n    };\n\n    for (; i < length; i++) {\n        addListener(this[i]);\n    }\n\n    return this;\n};\n\nfn.trigger = function(event) {\n    var i = 0,\n        length = this.length;\n\n    if (!event) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.trigger(this[i], event);\n    }\n\n    return this;\n};\n\nfn.off = function(types, handler) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        jBone.event.remove(this[i], types, handler);\n    }\n\n    return this;\n};\n\nfn.find = function(selector) {\n    var results = [],\n        i = 0,\n        length = this.length,\n        finder = function(el) {\n            if (isFunction(el.querySelectorAll)) {\n                [].forEach.call(el.querySelectorAll(selector), function(found) {\n                    results.push(found);\n                });\n            }\n        };\n\n    for (; i < length; i++) {\n        finder(this[i]);\n    }\n\n    return jBone(results);\n};\n\nfn.get = function(index) {\n    return index != null ?\n\n        // Return just one element from the set\n        (index < 0 ? this[index + this.length] : this[index]) :\n\n        // Return all the elements in a clean array\n        slice.call(this);\n};\n\nfn.eq = function(index) {\n    return jBone(this[index]);\n};\n\nfn.parent = function() {\n    var results = [],\n        parent,\n        i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        if (!~results.indexOf(parent = this[i].parentElement) && parent) {\n            results.push(parent);\n        }\n    }\n\n    return jBone(results);\n};\n\nfn.toArray = function() {\n    return slice.call(this);\n};\n\nfn.is = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.tagName.toLowerCase() === args[0];\n    });\n};\n\nfn.has = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.querySelectorAll(args[0]).length;\n    });\n};\n\nfn.add = function(selector, context) {\n    return this.pushStack(\n        jBone.unique(\n            jBone.merge(this.get(), jBone(selector, context))\n        )\n    );\n};\n\nfn.attr = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    if (isString(key) && args.length === 1) {\n        return this[0] && this[0].getAttribute(key);\n    }\n\n    if (args.length === 2) {\n        setter = function(el) {\n            el.setAttribute(key, value);\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.setAttribute(name, key[name]);\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeAttr = function(key) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        this[i].removeAttribute(key);\n    }\n\n    return this;\n};\n\nfn.val = function(value) {\n    var i = 0,\n        length = this.length;\n\n    if (arguments.length === 0) {\n        return this[0] && this[0].value;\n    }\n\n    for (; i < length; i++) {\n        this[i].value = value;\n    }\n\n    return this;\n};\n\nfn.css = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    // Get attribute\n    if (isString(key) && args.length === 1) {\n        return this[0] && win.getComputedStyle(this[0])[key];\n    }\n\n    // Set attributes\n    if (args.length === 2) {\n        setter = function(el) {\n            el.style[key] = value;\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.style[name] = key[name];\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.data = function(key, value) {\n    var args = arguments, data = {},\n        i = 0,\n        length = this.length,\n        setter,\n        setValue = function(el, key, value) {\n            if (isObject(value)) {\n                el.jdata = el.jdata || {};\n                el.jdata[key] = value;\n            } else {\n                el.dataset[key] = value;\n            }\n        },\n        getValue = function(value) {\n            if (value === \"true\") {\n                return true;\n            } else if (value === \"false\") {\n                return false;\n            } else {\n                return value;\n            }\n        };\n\n    // Get all data\n    if (args.length === 0) {\n        this[0].jdata && (data = this[0].jdata);\n\n        keys(this[0].dataset).forEach(function(key) {\n            data[key] = getValue(this[0].dataset[key]);\n        }, this);\n\n        return data;\n    }\n    // Get data by name\n    if (args.length === 1 && isString(key)) {\n        return this[0] && getValue(this[0].dataset[key] || this[0].jdata && this[0].jdata[key]);\n    }\n\n    // Set data\n    if (args.length === 1 && isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                setValue(el, name, key[name]);\n            });\n        };\n    } else if (args.length === 2) {\n        setter = function(el) {\n            setValue(el, key, value);\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeData = function(key) {\n    var i = 0,\n        length = this.length,\n        jdata, dataset;\n\n    for (; i < length; i++) {\n        jdata = this[i].jdata;\n        dataset = this[i].dataset;\n\n        if (key) {\n            jdata && jdata[key] && delete jdata[key];\n            delete dataset[key];\n        } else {\n            for (key in jdata) {\n                delete jdata[key];\n            }\n\n            for (key in dataset) {\n                delete dataset[key];\n            }\n        }\n    }\n\n    return this;\n};\n\nfn.addClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.add(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.removeClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.remove(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.toggleClass = function(className, force) {\n    var i = 0,\n        length = this.length,\n        method = \"toggle\";\n\n    force === true && (method = \"add\") || force === false && (method = \"remove\");\n\n    if (className) {\n        for (; i < length; i++) {\n            this[i].classList[method](className);\n        }\n    }\n\n    return this;\n};\n\nfn.hasClass = function(className) {\n    var i = 0, length = this.length;\n\n    if (className) {\n        for (; i < length; i++) {\n            if (this[i].classList.contains(className)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\nfn.html = function(value) {\n    var args = arguments,\n        el;\n\n    // add HTML into elements\n    if (args.length === 1 && value !== undefined) {\n        return this.empty().append(value);\n    }\n    // get HTML from element\n    else if (args.length === 0 && (el = this[0])) {\n        return el.innerHTML;\n    }\n\n    return this;\n};\n\nfn.append = function(appended) {\n    var i = 0,\n        length = this.length,\n        setter;\n\n    // create jBone object and then append\n    if (isString(appended) && rquickExpr.exec(appended)) {\n        appended = jBone(appended);\n    }\n    // create text node for insertion\n    else if (!isObject(appended)) {\n        appended = document.createTextNode(appended);\n    }\n\n    appended = appended instanceof jBone ? appended : jBone(appended);\n\n    setter = function(el, i) {\n        appended.forEach(function(node) {\n            if (i) {\n                el.appendChild(node.cloneNode(true));\n            } else {\n                el.appendChild(node);\n            }\n        });\n    };\n\n    for (; i < length; i++) {\n        setter(this[i], i);\n    }\n\n    return this;\n};\n\nfn.appendTo = function(to) {\n    jBone(to).append(this);\n\n    return this;\n};\n\nfn.empty = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        while (el.lastChild) {\n            el.removeChild(el.lastChild);\n        }\n    }\n\n    return this;\n};\n\nfn.remove = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    // remove all listeners\n    this.off();\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        // remove data and nodes\n        delete el.jdata;\n        el.parentNode && el.parentNode.removeChild(el);\n    }\n\n    return this;\n};\n\nif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\n    // Expose jBone as module.exports in loaders that implement the Node\n    // module pattern (including browserify). Do not create the global, since\n    // the user will be storing it themselves locally, and globals are frowned\n    // upon in the Node module world.\n    module.exports = jBone;\n}\n// Register as a AMD module\nelse if (typeof define === \"function\" && define.amd) {\n    define(function() {\n        return jBone;\n    });\n\n    win.jBone = win.$ = jBone;\n} else if (typeof win === \"object\" && typeof win.document === \"object\") {\n    win.jBone = win.$ = jBone;\n}\n\n}(window));\n","(function(){\n    /** Library imports for Browserify */\n    let $ = require('jbone');\n\n    /** @constant {String} EMPTY - Represent an EMPTY square in the board */\n    const EMPTY = '*';\n    /** @constant {String} X - The X token for the board*/\n    const X = 'X';\n    /** @constant {String} O - The O token for the board */\n    const O = 'O';\n    /**\n     * @constant {Number} TOP - The maximum value to be used by the search\n     * tree algorithm.\n     */\n    const TOP = 100;\n    /**\n     * @constant {picoModal} MODAL - Modal for choose token and player one of\n     * the game.\n     */\n    // const MODAL = ;\n\n    /**\n     * Answer if the row isn't empty and all their elements are equal.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @returns {Boolean} True if all line elements are equal and not the\n     * empty token, false otherwise.\n     */\n    function threeInARow(row) {\n        let token = row[0];\n        if (token !== EMPTY) {\n            return row.every(element => element === token);\n        }\n    }\n\n    /** Class representing a board. */\n    class Board {\n        /** Create a board. */\n        constructor() {\n            this.squares = Array(9).fill(EMPTY);\n            this.getReady();\n        }\n\n        /** Clear and prepare the board for a new game */\n        getReady() {\n            for (let i = 0; i < 9; i++) {\n                this[`$square${i}`] = $(`#square${i}`);\n                this[`$square${i}`].html('').removeAttr('disabled');\n            }\n        }\n\n        /**\n         * Place the token of a player in the board.\n         * @param {Number} move - The position where the token will be placed.\n         * @param {String} player - The token of the player.\n         * @param {Boolean} [realMove=false] - If the move is a real move in\n         * the board, not a move done by the search tree algorithm.\n         */\n        makeMove(move, player, realMove=false) {\n            this.squares[move] = player;\n            if (realMove) {\n                let tokenAlt = (player === 'X')? 'Cross': 'Circle';\n                let token = `<img class=\"token-img\" src=\"assets/images/${player}.svg\" alt=\"${tokenAlt}\">`;\n                this[`$square${move}`].html(token).attr('disabled', '');\n            }\n        }\n\n        /**\n         * Remove the player token in the given position of the board.\n         * @param {Number} move - The position of the token to be erased.\n         */\n        undoMove(move) {\n            this.makeMove(move, EMPTY);\n        }\n    }\n\n    /** Class representing a Tic Tac Toe game */\n    class TicTacToe {\n        /**\n         * Create a Tic Tac Toe game.\n         * @property {Board} board - The board where the game is played.\n         * @property {Object.<String, String>} - Pairs each token with their\n         * opposite, for easy switching between player tokens.\n         * @property {Number} turn - The actual turn of the game.\n         * @property {Array[]} lines - Array of winning lines in a Tic Tac Toe\n         * game.\n         */\n        constructor() {\n            this.board = new Board();\n            this.rival = {'O': 'X', 'X': 'O'};\n            this.turn = 0;\n            this.lines= [[0,1,2], [3,4,5], [6,7,8], // vertical\n                        [0,3,6], [1,4,7], [2,5,8], // horizontal\n                        [0,4,8],[2,4,6]];          // diagonal\n\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the board */\n        cacheDom() {\n            this.$board = $('#board');\n            this.$square = $('.square');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$square.on('click', this.handleMove.bind(this));\n        }\n\n        /** Enable the board, making it clickable. */\n        enableBoard() {\n            this.$board.removeClass('disabled');\n        }\n\n        /** Disable the board, making it unclickable. */\n        disableBoard() {\n            this.$board.addClass('disabled');\n        }\n\n        /**\n         * Handle an user move try.\n         * @param {Object} event - The event associated to a click\n         * in a board square (a move) made by the user.\n         */\n        handleMove(event) {\n            let move = Number(event.currentTarget.dataset.square);\n            this.board.makeMove.bind(this.board)(move, this.humanToken, true);\n            this.continueGame(this.humanToken, this.cpuPlayer);\n        }\n\n        /**\n         * Check if the game can continue or not and act according to that.\n         * If game can continue, run the next player turn.\n         * If not, announce the result, reset the game and show the modal.\n         * @param {String} player - The token of the actual player.\n         * @param {Function} playerFunction - The function to execute if the\n         * game should continue.\n         */\n        continueGame(player, playerFunction) {\n            if (this.isGameOver()) {\n                let winner = this.getWinner();\n                console.log((winner)? `Player ${winner} won.`:'It was a tie.');\n                window.setTimeout(this.reset.bind(this), 800);\n            } else {\n                playerFunction.bind(this)(this.rival[player]);\n            }\n        }\n\n        /**\n         * Reset a Tic Tac Toe Game.\n         */\n        reset() {\n            this.board = new Board();\n            this.turn = 0;\n            this.$modal.removeClass('hidden');\n        }\n\n        /**\n         * Get squares still available (empty) in the board.\n         * @returns {Number[]} List of empty squares in the board.\n         */\n        getValidMoves() {\n            let squares = this.board.squares;\n            let emptySquare = function(element, index) {\n                return squares[index] === EMPTY;\n            };\n            return [...squares.keys()].filter(emptySquare.bind(this));\n        }\n\n        /**\n         * Answer if the game has come to an end.\n         * @returns {Boolean} True or false if game has come to an end or not.\n         */\n        isGameOver() {\n            return this.getWinner() || !this.getValidMoves().length;\n        }\n\n        /**\n         * Get the token of the winner player.\n         * @returns {?String} The token of the actual winner. null means a tie.\n         */\n        getWinner() {\n            for (let line of this.lines) {\n                let row = line.map(element => this.board.squares[element]);\n                if (threeInARow(row)) {\n                    return row[0];\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Evaluate (score) the state of the player at the end of a game.\n         * The possible states are: «Win» (a positive number),\n         * «Lose» (a negative) or «Tie» (zero).\n         * Take the number of moves done (depth) into account. Not taking that\n         * into account leads to a CPU playing awfully: a win in 4 moves is\n         * more valuable that one achieved in 6.\n         * @param {String} player - The token of the player which state is\n         * being evaluated.\n         * @param {Number} depth - The number of moves done to reach the actual\n         * state of the game.\n         *\n         * @returns {Number} The score of the actual state from the player\n         * perspective.\n         */\n        evalFinalState(player, depth) {\n            let winner = this.getWinner();\n            if (winner === player) {\n                return TOP - depth;\n            } else if (winner === this.rival[player]) {\n                return -TOP + depth;\n            }\n            return 0;\n        }\n\n        /**\n         * Implement search of the best move to execute next in the game.\n         * Use MiniMax algorithm enhanced with alpha-beta pruning.\n         * @returns {Number} bestMove - Best move to do next to play perfectly.\n         */\n        minimax(player, depth) {\n            let bestMove,\n                currentMax,\n                max = -TOP;\n            for (let move of this.getValidMoves()) {\n                currentMax = this.minValue(move, depth, this.rival[player],\n                                           -TOP, TOP);\n                if (currentMax > max) {\n                    max = currentMax;\n                    bestMove = move;\n                }\n            }\n            return bestMove;\n        }\n\n        /**\n         * Evaluate the given position and get the best result the player could\n         * achieve from that.\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Best situation the player could achieve from the\n         * given position.\n         */\n        maxValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    α = Math.max(α,\n                                 this.minValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return β;\n                    }\n                }\n                return α;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Evaluate the given position and get the worst result for the player\n         * opponent (the best for the player).\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Worst situation the opponent player could achieve\n         * from the given position.\n         */\n        minValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    β = Math.min(β,\n                                 this.maxValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return α;\n                    }\n                }\n                return β;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Run cpu player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        cpuPlayer(player) {\n            console.time('cpu move');\n            this.disableBoard();\n            let move;\n            if (this.turn) {\n                move = this.minimax(player, this.turn);\n            } else {\n                move = Math.floor(Math.random() * this.getValidMoves().length);\n            }\n            this.board.makeMove(move, player, true);\n            console.timeEnd('cpu move');\n            this.continueGame(player, this.humanPlayer);\n        }\n\n        /**\n         * Run human player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        humanPlayer(player) {\n            this.turn++;\n            this.enableBoard();\n        }\n\n        /**\n         * Start the Tic Tac Toe game.\n         * An OptionsModal should be instantiated for this to work.\n         */\n        start() {\n            if (this.playerOne === 'human') {\n                this.humanPlayer(this.humanToken);\n            } else {\n                this.cpuPlayer(this.rival[this.humanToken]);\n            }\n        }\n    }\n\n    /** Class representing an options modal window for the game. */\n    class OptionsModal {\n        /**\n         * Create a modal for a Tic Tac Toe game.\n         * @param {Object} game - A TicTacToe instance.\n         */\n        constructor(game) {\n            this.game = game;\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the modal */\n        cacheDom() {\n            this.$tokens = $('.token');\n            this.$players = $('.player');\n            this.$start = $('#start-btn');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$tokens.on('click', this.handleTokenSelection.bind(this));\n            this.$players.on('click', this.handlePlayerSelection.bind(this));\n            this.$start.on('click', this.handleStart.bind(this));\n        }\n\n        /**\n         * Handle the token selection by the user.\n         * @param {Object} event - The event associated to a click\n         * in a token button made by the user, choosing their token.\n         */\n        handleTokenSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$tokens.toggleClass('unselected');\n                this.token = $this.attr('data-token');\n            }\n        }\n\n        /**\n         * Handle the selection of player one by the user.\n         * @param {Object} event - The event associated to a click\n         * in a player button made by the user, choosing which player\n         * will start the game.\n         */\n        handlePlayerSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$players.toggleClass('unselected');\n                this.playerOne = $this.attr('data-playerone');\n            }\n        }\n\n        /**\n         * Handle the click in the modal start button by the user.\n         * @param {Object} event - The event associated to a click\n         * in the start button made by the user, for starting the game.\n         */\n        handleStart(event) {\n            this.game.playerOne = this.playerOne || 'human';\n            this.game.humanToken = this.token || 'X';\n            this.$modal.addClass('hidden');\n            this.game.start();\n        }\n    }\n\n    /** Create and launch a Tic Tac Toe game. */\n    function newGame(){\n        let ttt = new TicTacToe();\n        let modal = new OptionsModal(ttt);\n    }\n\n    newGame();\n})();"],"sourceRoot":"/source/"}