{"version":3,"sources":["app.js","node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/jbone/dist/jbone.js","src/js/app.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_typeof","Symbol","iterator","obj","constructor","e","t","n","r","s","o","u","a","require","f","Error","code","l","exports","call",1,"module","win","isArraylike","type","isFunction","nodeType","BoneEvent","data","setter","this","originalEvent","defaultPrevented","immediatePropagationStopped","jBone","extend","isImmediatePropagationStopped","fn","_$","$","_jBone","rquickSingleTag","rquickExpr","slice","splice","keys","doc","document","isString","el","isObject","toString","element","init","noConflict","elements","tag","wraper","fragment","exec","createElement","attr","createDocumentFragment","innerHTML","lastChild","appendChild","firstChild","childNodes","merge","isElement","find","querySelectorAll","makeArray","pop","push","reverse","shift","sort","indexOf","forEach","unshift","concat","join","every","some","filter","map","reduce","reduceRight","setId","jid","undefined","_cache","events","getData","HTMLElement","pushStack","elems","ret","first","second","j","contains","container","contained","tg","arguments","source","prop","results","unique","array","result","value","Event","event","namespace","eventType","split","createEvent","initEvent","isDefaultPrevented","add","types","handler","selector","eventHandler","dispatch","addEventListener","originfn","remove","eventsByType","removeListener","index","callback","removeEventListener","eventName","trigger","dispatchEvent","expectedTarget","eventOptions","handlers","handlerQueue","targets","currentTarget","on","one","addListener","args","oneArgs","$el","off","apply","finder","found","get","eq","parent","parentElement","toArray","is","tagName","toLowerCase","has","context","getAttribute","setAttribute","name","removeAttr","removeAttribute","val","css","getComputedStyle","style","setValue","jdata","dataset","getValue","removeData","addClass","className","classes","trim","classList","removeClass","toggleClass","force","method","hasClass","html","empty","append","appended","createTextNode","node","cloneNode","appendTo","to","removeChild","parentNode","define","amd","window",2,"threeInARow","row","repeats","Set","size","EMPTY","twoInARow","player","uniques","playerTokens","oneInARow","newGame","ttt","TicTacToe","OptionsModal","Board","squares","fill","lines","crossLines",0,3,4,5,6,7,8,"center","corners","Map","middles","getReady","move","tokenAlt","token","board","rival","O","X","turn","cacheDom","bindEvents","$board","$square","$modal","handleMove","bind","Number","square","makeMove","humanToken","continueGame","cpuPlayer","playerFunction","isGameOver","winner","getWinner","console","log","setTimeout","reset","emptySquare","getValidMoves","indexArr","_this","forkCandidate","isForkLine","crossline","tokens","toTokenArray","forkLines","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","next","done","line","err","_this2","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","validMoves","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","isForkMove","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","entries","oppositeCorners","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","corner","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","middle","time","disableBoard","bestMove","Math","floor","random","timeEnd","humanPlayer","enableBoard","playerOne","game","$tokens","$players","$start","handleTokenSelection","handlePlayerSelection","handleStart","$this","start","jbone"],"mappings":"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","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*!\n * jBone v1.1.2 - 2015-10-09 - Library for DOM manipulation\n *\n * http://jbone.js.org\n *\n * Copyright 2015 Alexey Kupriyanenko\n * Released under the MIT license.\n */\n\n(function (win) {\n\nvar\n// cache previous versions\n_$ = win.$,\n_jBone = win.jBone,\n\n// Quick match a standalone tag\nrquickSingleTag = /^<(\\w+)\\s*\\/?>$/,\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash\nrquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n\n// Alias for function\nslice = [].slice,\nsplice = [].splice,\nkeys = Object.keys,\n\n// Alias for global variables\ndoc = document,\n\nisString = function(el) {\n    return typeof el === \"string\";\n},\nisObject = function(el) {\n    return el instanceof Object;\n},\nisFunction = function(el) {\n    return ({}).toString.call(el) === \"[object Function]\";\n},\nisArray = function(el) {\n    return Array.isArray(el);\n},\njBone = function(element, data) {\n    return new fn.init(element, data);\n},\nfn;\n\n// set previous values and return the instance upon calling the no-conflict mode\njBone.noConflict = function() {\n    win.$ = _$;\n    win.jBone = _jBone;\n\n    return jBone;\n};\n\nfn = jBone.fn = jBone.prototype = {\n    init: function(element, data) {\n        var elements, tag, wraper, fragment;\n\n        if (!element) {\n            return this;\n        }\n        if (isString(element)) {\n            // Create single DOM element\n            if (tag = rquickSingleTag.exec(element)) {\n                this[0] = doc.createElement(tag[1]);\n                this.length = 1;\n\n                if (isObject(data)) {\n                    this.attr(data);\n                }\n\n                return this;\n            }\n            // Create DOM collection\n            if ((tag = rquickExpr.exec(element)) && tag[1]) {\n                fragment = doc.createDocumentFragment();\n                wraper = doc.createElement(\"div\");\n                wraper.innerHTML = element;\n                while (wraper.lastChild) {\n                    fragment.appendChild(wraper.firstChild);\n                }\n                elements = slice.call(fragment.childNodes);\n\n                return jBone.merge(this, elements);\n            }\n            // Find DOM elements with querySelectorAll\n            if (jBone.isElement(data)) {\n                return jBone(data).find(element);\n            }\n\n            try {\n                elements = doc.querySelectorAll(element);\n\n                return jBone.merge(this, elements);\n            } catch (e) {\n                return this;\n            }\n        }\n        // Wrap DOMElement\n        if (element.nodeType) {\n            this[0] = element;\n            this.length = 1;\n\n            return this;\n        }\n        // Run function\n        if (isFunction(element)) {\n            return element();\n        }\n        // Return jBone element as is\n        if (element instanceof jBone) {\n            return element;\n        }\n\n        // Return element wrapped by jBone\n        return jBone.makeArray(element, this);\n    },\n\n    pop: [].pop,\n    push: [].push,\n    reverse: [].reverse,\n    shift: [].shift,\n    sort: [].sort,\n    splice: [].splice,\n    slice: [].slice,\n    indexOf: [].indexOf,\n    forEach: [].forEach,\n    unshift: [].unshift,\n    concat: [].concat,\n    join: [].join,\n    every: [].every,\n    some: [].some,\n    filter: [].filter,\n    map: [].map,\n    reduce: [].reduce,\n    reduceRight: [].reduceRight,\n    length: 0\n};\n\nfn.constructor = jBone;\n\nfn.init.prototype = fn;\n\njBone.setId = function(el) {\n    var jid = el.jid;\n\n    if (el === win) {\n        jid = \"window\";\n    } else if (el.jid === undefined) {\n        el.jid = jid = ++jBone._cache.jid;\n    }\n\n    if (!jBone._cache.events[jid]) {\n        jBone._cache.events[jid] = {};\n    }\n};\n\njBone.getData = function(el) {\n    el = el instanceof jBone ? el[0] : el;\n\n    var jid = el === win ? \"window\" : el.jid;\n\n    return {\n        jid: jid,\n        events: jBone._cache.events[jid]\n    };\n};\n\njBone.isElement = function(el) {\n    return el && el instanceof jBone || el instanceof HTMLElement || isString(el);\n};\n\njBone._cache = {\n    events: {},\n    jid: 0\n};\n\nfunction isArraylike(obj) {\n    var length = obj.length,\n        type = typeof obj;\n\n    if (isFunction(type) || obj === win) {\n        return false;\n    }\n\n    if (obj.nodeType === 1 && length) {\n        return true;\n    }\n\n    return isArray(type) || length === 0 ||\n        typeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n\nfn.pushStack = function(elems) {\n    var ret = jBone.merge(this.constructor(), elems);\n\n    return ret;\n};\n\njBone.merge = function(first, second) {\n    var l = second.length,\n        i = first.length,\n        j = 0;\n\n    while (j < l) {\n        first[i++] = second[j++];\n    }\n\n    first.length = i;\n\n    return first;\n};\n\njBone.contains = function(container, contained) {\n    return container.contains(contained);\n};\n\njBone.extend = function(target) {\n    var tg;\n\n    splice.call(arguments, 1).forEach(function(source) {\n        tg = target; //caching target for perf improvement\n\n        if (source) {\n            for (var prop in source) {\n                tg[prop] = source[prop];\n            }\n        }\n    });\n\n    return target;\n};\n\njBone.makeArray = function(arr, results) {\n    var ret = results || [];\n\n    if (arr !== null) {\n        if (isArraylike(arr)) {\n            jBone.merge(ret, isString(arr) ? [arr] : arr);\n        } else {\n            ret.push(arr);\n        }\n    }\n\n    return ret;\n};\n\njBone.unique = function(array) {\n    if (array == null) {\n        return [];\n    }\n\n    var result = [];\n\n    for (var i = 0, length = array.length; i < length; i++) {\n        var value = array[i];\n        if (result.indexOf(value) < 0) {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nfunction BoneEvent(e, data) {\n    var key, setter;\n\n    this.originalEvent = e;\n\n    setter = function(key, e) {\n        if (key === \"preventDefault\") {\n            this[key] = function() {\n                this.defaultPrevented = true;\n                return e[key]();\n            };\n        } else if (key === \"stopImmediatePropagation\") {\n            this[key] = function() {\n                this.immediatePropagationStopped = true;\n                return e[key]();\n            };\n        } else if (isFunction(e[key])) {\n            this[key] = function() {\n                return e[key]();\n            };\n        } else {\n            this[key] = e[key];\n        }\n    };\n\n    for (key in e) {\n        if (e[key] || typeof e[key] === \"function\") {\n            setter.call(this, key, e);\n        }\n    }\n\n    jBone.extend(this, data, {\n        isImmediatePropagationStopped: function() {\n            return !!this.immediatePropagationStopped;\n        }\n    });\n}\n\njBone.Event = function(event, data) {\n    var namespace, eventType;\n\n    if (event.type && !data) {\n        data = event;\n        event = event.type;\n    }\n\n    namespace = event.split(\".\").splice(1).join(\".\");\n    eventType = event.split(\".\")[0];\n\n    event = doc.createEvent(\"Event\");\n    event.initEvent(eventType, true, true);\n\n    return jBone.extend(event, {\n        namespace: namespace,\n        isDefaultPrevented: function() {\n            return event.defaultPrevented;\n        }\n    }, data);\n};\n\njBone.event = {\n\n    /**\n     * Attach a handler to an event for the elements\n     * @param {Node}        el         - Events will be attached to this DOM Node\n     * @param {String}      types      - One or more space-separated event types and optional namespaces\n     * @param {Function}    handler    - A function to execute when the event is triggered\n     * @param {Object}      [data]     - Data to be passed to the handler in event.data\n     * @param {String}      [selector] - A selector string to filter the descendants of the selected elements\n     */\n    add: function(el, types, handler, data, selector) {\n        jBone.setId(el);\n\n        var eventHandler = function(e) {\n                jBone.event.dispatch.call(el, e);\n            },\n            events = jBone.getData(el).events,\n            eventType, t, event;\n\n        types = types.split(\" \");\n        t = types.length;\n        while (t--) {\n            event = types[t];\n\n            eventType = event.split(\".\")[0];\n            events[eventType] = events[eventType] || [];\n\n            if (events[eventType].length) {\n                // override with previous event handler\n                eventHandler = events[eventType][0].fn;\n            } else {\n                el.addEventListener && el.addEventListener(eventType, eventHandler, false);\n            }\n\n            events[eventType].push({\n                namespace: event.split(\".\").splice(1).join(\".\"),\n                fn: eventHandler,\n                selector: selector,\n                data: data,\n                originfn: handler\n            });\n        }\n    },\n\n    /**\n     * Remove an event handler\n     * @param  {Node}       el        - Events will be deattached from this DOM Node\n     * @param  {String}     types     - One or more space-separated event types and optional namespaces\n     * @param  {Function}   handler   - A handler function previously attached for the event(s)\n     */\n    remove: function(el, types, handler) {\n        var removeListener = function(events, eventType, index, el, e) {\n                var callback;\n\n                // get callback\n                if ((handler && e.originfn === handler) || !handler) {\n                    callback = e.fn;\n                }\n\n                if (events[eventType][index].fn === callback) {\n                    // remove handler from cache\n                    events[eventType].splice(index, 1);\n\n                    if (!events[eventType].length) {\n                        el.removeEventListener(eventType, callback);\n                    }\n                }\n            },\n            events = jBone.getData(el).events,\n            l,\n            eventsByType;\n\n        if (!events) {\n            return;\n        }\n\n        // remove all events\n        if (!types && events) {\n            return keys(events).forEach(function(eventType) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    removeListener(events, eventType, l, el, eventsByType[l]);\n                }\n            });\n        }\n\n        types.split(\" \").forEach(function(eventName) {\n            var eventType = eventName.split(\".\")[0],\n                namespace = eventName.split(\".\").splice(1).join(\".\"),\n                e;\n\n            // remove named events\n            if (events[eventType]) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    e = eventsByType[l];\n                    if (!namespace || (namespace && e.namespace === namespace)) {\n                        removeListener(events, eventType, l, el, e);\n                    }\n                }\n            }\n            // remove all namespaced events\n            else if (namespace) {\n                keys(events).forEach(function(eventType) {\n                    eventsByType = events[eventType];\n                    l = eventsByType.length;\n\n                    while(l--) {\n                        e = eventsByType[l];\n                        if (e.namespace.split(\".\")[0] === namespace.split(\".\")[0]) {\n                            removeListener(events, eventType, l, el, e);\n                        }\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Execute all handlers and behaviors attached to the matched elements for the given event type.\n     * @param  {Node}       el       - Events will be triggered for thie DOM Node\n     * @param  {String}     event    - One or more space-separated event types and optional namespaces\n     */\n    trigger: function(el, event) {\n        var events = [];\n\n        if (isString(event)) {\n            events = event.split(\" \").map(function(event) {\n                return jBone.Event(event);\n            });\n        } else {\n            event = event instanceof Event ? event : jBone.Event(event);\n            events = [event];\n        }\n\n        events.forEach(function(event) {\n            if (!event.type) {\n                return;\n            }\n\n            el.dispatchEvent && el.dispatchEvent(event);\n        });\n    },\n\n    dispatch: function(e) {\n        var i = 0,\n            j = 0,\n            el = this,\n            handlers = jBone.getData(el).events[e.type],\n            length = handlers.length,\n            handlerQueue = [],\n            targets = [],\n            l,\n            expectedTarget,\n            handler,\n            event,\n            eventOptions;\n\n        // cache all events handlers, fix issue with multiple handlers (issue #45)\n        for (; i < length; i++) {\n            handlerQueue.push(handlers[i]);\n        }\n\n        i = 0;\n        length = handlerQueue.length;\n\n        for (;\n            // if event exists\n            i < length &&\n            // if handler is not removed from stack\n            ~handlers.indexOf(handlerQueue[i]) &&\n            // if propagation is not stopped\n            !(event && event.isImmediatePropagationStopped());\n        i++) {\n            expectedTarget = null;\n            eventOptions = {};\n            handler = handlerQueue[i];\n            handler.data && (eventOptions.data = handler.data);\n\n            // event handler without selector\n            if (!handler.selector) {\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(el, event);\n                }\n            }\n            // event handler with selector\n            else if (\n                // if target and selected element the same\n                ~(targets = jBone(el).find(handler.selector)).indexOf(e.target) && (expectedTarget = e.target) ||\n                // if one of element matched with selector contains target\n                (el !== e.target && el.contains(e.target))\n            ) {\n                // get element matched with selector\n                if (!expectedTarget) {\n                    l = targets.length;\n                    j = 0;\n\n                    for (; j < l; j++) {\n                        if (targets[j] && targets[j].contains(e.target)) {\n                            expectedTarget = targets[j];\n                        }\n                    }\n                }\n\n                if (!expectedTarget) {\n                    continue;\n                }\n\n                eventOptions.currentTarget = expectedTarget;\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(expectedTarget, event);\n                }\n            }\n        }\n    }\n};\n\nfn.on = function(types, selector, data, fn) {\n    var length = this.length,\n        i = 0;\n\n    if (data == null && fn == null) {\n        // (types, fn)\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === \"string\") {\n            // (types, selector, fn)\n            fn = data;\n            data = undefined;\n        } else {\n            // (types, data, fn)\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n\n    if (!fn) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.add(this[i], types, fn, data, selector);\n    }\n\n    return this;\n};\n\nfn.one = function(event) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        oneArgs = slice.call(args, 1, args.length - 1),\n        callback = slice.call(args, -1)[0],\n        addListener;\n\n    addListener = function(el) {\n        var $el = jBone(el);\n\n        event.split(\" \").forEach(function(event) {\n            var fn = function(e) {\n                $el.off(event, fn);\n                callback.call(el, e);\n            };\n\n            $el.on.apply($el, [event].concat(oneArgs, fn));\n        });\n    };\n\n    for (; i < length; i++) {\n        addListener(this[i]);\n    }\n\n    return this;\n};\n\nfn.trigger = function(event) {\n    var i = 0,\n        length = this.length;\n\n    if (!event) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.trigger(this[i], event);\n    }\n\n    return this;\n};\n\nfn.off = function(types, handler) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        jBone.event.remove(this[i], types, handler);\n    }\n\n    return this;\n};\n\nfn.find = function(selector) {\n    var results = [],\n        i = 0,\n        length = this.length,\n        finder = function(el) {\n            if (isFunction(el.querySelectorAll)) {\n                [].forEach.call(el.querySelectorAll(selector), function(found) {\n                    results.push(found);\n                });\n            }\n        };\n\n    for (; i < length; i++) {\n        finder(this[i]);\n    }\n\n    return jBone(results);\n};\n\nfn.get = function(index) {\n    return index != null ?\n\n        // Return just one element from the set\n        (index < 0 ? this[index + this.length] : this[index]) :\n\n        // Return all the elements in a clean array\n        slice.call(this);\n};\n\nfn.eq = function(index) {\n    return jBone(this[index]);\n};\n\nfn.parent = function() {\n    var results = [],\n        parent,\n        i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        if (!~results.indexOf(parent = this[i].parentElement) && parent) {\n            results.push(parent);\n        }\n    }\n\n    return jBone(results);\n};\n\nfn.toArray = function() {\n    return slice.call(this);\n};\n\nfn.is = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.tagName.toLowerCase() === args[0];\n    });\n};\n\nfn.has = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.querySelectorAll(args[0]).length;\n    });\n};\n\nfn.add = function(selector, context) {\n    return this.pushStack(\n        jBone.unique(\n            jBone.merge(this.get(), jBone(selector, context))\n        )\n    );\n};\n\nfn.attr = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    if (isString(key) && args.length === 1) {\n        return this[0] && this[0].getAttribute(key);\n    }\n\n    if (args.length === 2) {\n        setter = function(el) {\n            el.setAttribute(key, value);\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.setAttribute(name, key[name]);\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeAttr = function(key) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        this[i].removeAttribute(key);\n    }\n\n    return this;\n};\n\nfn.val = function(value) {\n    var i = 0,\n        length = this.length;\n\n    if (arguments.length === 0) {\n        return this[0] && this[0].value;\n    }\n\n    for (; i < length; i++) {\n        this[i].value = value;\n    }\n\n    return this;\n};\n\nfn.css = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    // Get attribute\n    if (isString(key) && args.length === 1) {\n        return this[0] && win.getComputedStyle(this[0])[key];\n    }\n\n    // Set attributes\n    if (args.length === 2) {\n        setter = function(el) {\n            el.style[key] = value;\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.style[name] = key[name];\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.data = function(key, value) {\n    var args = arguments, data = {},\n        i = 0,\n        length = this.length,\n        setter,\n        setValue = function(el, key, value) {\n            if (isObject(value)) {\n                el.jdata = el.jdata || {};\n                el.jdata[key] = value;\n            } else {\n                el.dataset[key] = value;\n            }\n        },\n        getValue = function(value) {\n            if (value === \"true\") {\n                return true;\n            } else if (value === \"false\") {\n                return false;\n            } else {\n                return value;\n            }\n        };\n\n    // Get all data\n    if (args.length === 0) {\n        this[0].jdata && (data = this[0].jdata);\n\n        keys(this[0].dataset).forEach(function(key) {\n            data[key] = getValue(this[0].dataset[key]);\n        }, this);\n\n        return data;\n    }\n    // Get data by name\n    if (args.length === 1 && isString(key)) {\n        return this[0] && getValue(this[0].dataset[key] || this[0].jdata && this[0].jdata[key]);\n    }\n\n    // Set data\n    if (args.length === 1 && isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                setValue(el, name, key[name]);\n            });\n        };\n    } else if (args.length === 2) {\n        setter = function(el) {\n            setValue(el, key, value);\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeData = function(key) {\n    var i = 0,\n        length = this.length,\n        jdata, dataset;\n\n    for (; i < length; i++) {\n        jdata = this[i].jdata;\n        dataset = this[i].dataset;\n\n        if (key) {\n            jdata && jdata[key] && delete jdata[key];\n            delete dataset[key];\n        } else {\n            for (key in jdata) {\n                delete jdata[key];\n            }\n\n            for (key in dataset) {\n                delete dataset[key];\n            }\n        }\n    }\n\n    return this;\n};\n\nfn.addClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.add(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.removeClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.remove(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.toggleClass = function(className, force) {\n    var i = 0,\n        length = this.length,\n        method = \"toggle\";\n\n    force === true && (method = \"add\") || force === false && (method = \"remove\");\n\n    if (className) {\n        for (; i < length; i++) {\n            this[i].classList[method](className);\n        }\n    }\n\n    return this;\n};\n\nfn.hasClass = function(className) {\n    var i = 0, length = this.length;\n\n    if (className) {\n        for (; i < length; i++) {\n            if (this[i].classList.contains(className)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\nfn.html = function(value) {\n    var args = arguments,\n        el;\n\n    // add HTML into elements\n    if (args.length === 1 && value !== undefined) {\n        return this.empty().append(value);\n    }\n    // get HTML from element\n    else if (args.length === 0 && (el = this[0])) {\n        return el.innerHTML;\n    }\n\n    return this;\n};\n\nfn.append = function(appended) {\n    var i = 0,\n        length = this.length,\n        setter;\n\n    // create jBone object and then append\n    if (isString(appended) && rquickExpr.exec(appended)) {\n        appended = jBone(appended);\n    }\n    // create text node for insertion\n    else if (!isObject(appended)) {\n        appended = document.createTextNode(appended);\n    }\n\n    appended = appended instanceof jBone ? appended : jBone(appended);\n\n    setter = function(el, i) {\n        appended.forEach(function(node) {\n            if (i) {\n                el.appendChild(node.cloneNode(true));\n            } else {\n                el.appendChild(node);\n            }\n        });\n    };\n\n    for (; i < length; i++) {\n        setter(this[i], i);\n    }\n\n    return this;\n};\n\nfn.appendTo = function(to) {\n    jBone(to).append(this);\n\n    return this;\n};\n\nfn.empty = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        while (el.lastChild) {\n            el.removeChild(el.lastChild);\n        }\n    }\n\n    return this;\n};\n\nfn.remove = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    // remove all listeners\n    this.off();\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        // remove data and nodes\n        delete el.jdata;\n        el.parentNode && el.parentNode.removeChild(el);\n    }\n\n    return this;\n};\n\nif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\n    // Expose jBone as module.exports in loaders that implement the Node\n    // module pattern (including browserify). Do not create the global, since\n    // the user will be storing it themselves locally, and globals are frowned\n    // upon in the Node module world.\n    module.exports = jBone;\n}\n// Register as a AMD module\nelse if (typeof define === \"function\" && define.amd) {\n    define(function() {\n        return jBone;\n    });\n\n    win.jBone = win.$ = jBone;\n} else if (typeof win === \"object\" && typeof win.document === \"object\") {\n    win.jBone = win.$ = jBone;\n}\n\n}(window));\n\n},{}],2:[function(require,module,exports){\n(function(){\n    /** Library imports for Browserify */\n    let $ = require('jbone');\n\n    /** @constant {String} EMPTY - Represent an EMPTY square in the board */\n    const EMPTY = '*';\n    /** @constant {String} X - The X token for the board*/\n    const X = 'X';\n    /** @constant {String} O - The O token for the board */\n    const O = 'O';\n    /**\n     * @constant {Number} TOP - The maximum value to be used by the search\n     * tree algorithm.\n     */\n    const TOP = 100;\n\n    /**\n     * Answer if the row isn't empty and all their elements are equal.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @returns {Boolean} True if all line elements are equal and not the\n     * empty token, false otherwise.\n     */\n    function threeInARow(row) {\n        let repeats = new Set(row);\n        return (repeats.size === 1) && (!repeats.has(EMPTY));\n    }\n\n    /**\n     * Answer if the given player has two tokens in the row, so a direct\n     * win situation.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @param {String} player - The token of the player to check.\n     * @returns {Boolean} True if there is two player tokens and any rival\n     * tokens, false otherwise.\n     */\n    function twoInARow(row, player) {\n        let uniques = new Set(row);\n        if ((uniques.size === 3) || !uniques.has(EMPTY)) {\n            return false;\n        }\n        let playerTokens = row.filter(element => element === player);\n        return playerTokens.length === 2;\n    }\n\n    /**\n     * Answer if the given player has placed the only token placed in the\n     * current row.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @param {String} player - The token of the player to check.\n     * @returns {Boolean} True if there is one player token and any rival\n     * tokens, false otherwise.\n     */\n    function oneInARow(row, player) {\n        return (twoInARow(row, EMPTY) && (row.indexOf(player) !== -1));\n    }\n\n    /** Class representing a board. */\n    class Board {\n        /** Create a board. */\n        constructor() {\n            this.squares = Array(9).fill(EMPTY);\n            this.lines= [[0,1,2], [3,4,5], [6,7,8], // horizontal\n                         [0,3,6], [1,4,7], [2,5,8], // vertical\n                         [0,4,8],[2,4,6]];          // diagonal\n            this.crossLines = {\n                0: [[0, 1, 2], [0, 3, 6], [0, 4, 8]],\n                1: [[0, 1, 2], [1, 4, 7]],\n                2: [[0, 1, 2], [2, 5, 8]],\n                3: [[3, 4, 5], [0, 3, 6]],\n                4: [[3, 4, 5], [1, 4, 5], [0, 4, 8]],\n                5: [[3, 4, 5], [2, 5, 8]],\n                6: [[6, 7, 8], [0, 3, 6], [2, 4, 6]],\n                7: [[6, 7, 8], [1, 4, 7]],\n                8: [[6, 7, 8], [2, 5, 8], [0, 4, 8]]\n            };\n            this.center = 4;\n            this.corners = new Map([[0, 8], [2, 6], [6, 2], [8, 0]]);\n            this.middles = [1, 7, 3, 5];\n\n            this.getReady();\n        }\n\n        /** Clear and prepare the board for a new game */\n        getReady() {\n            for (let i = 0; i < 9; i++) {\n                this[`$square${i}`] = $(`#square${i}`);\n                this[`$square${i}`].html('').removeAttr('disabled');\n            }\n        }\n\n        /**\n         * Place the token of a player in the board.\n         * @param {Number} move - The position where the token will be placed.\n         * @param {String} player - The token of the player.\n         */\n        makeMove(move, player) {\n            this.squares[move] = player;\n            let tokenAlt = (player === 'X')? 'Cross': 'Circle';\n            let token = `<img class=\"token-img\" src=\"assets/images/${player}.svg\" alt=\"${tokenAlt}\">`;\n            this[`$square${move}`].html(token).attr('disabled', '');\n        }\n    }\n\n    /** Class representing a Tic Tac Toe game */\n    class TicTacToe {\n        /**\n         * Create a Tic Tac Toe game.\n         * @property {Board} board - The board where the game is played.\n         * @property {Object.<String, String>} - Pairs each token with their\n         * opposite, for easy switching between player tokens.\n         * @property {Number} turn - The actual turn of the game.\n         * @property {Array[]} lines - Array of winning lines in a Tic Tac Toe\n         * game.\n         */\n        constructor() {\n            this.board = new Board();\n            this.rival = {'O': 'X', 'X': 'O'};\n            this.turn = 0;\n\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the board */\n        cacheDom() {\n            this.$board = $('#board');\n            this.$square = $('.square');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$square.on('click', this.handleMove.bind(this));\n        }\n\n        /** Enable the board, making it clickable. */\n        enableBoard() {\n            this.$board.removeClass('disabled');\n        }\n\n        /** Disable the board, making it unclickable. */\n        disableBoard() {\n            this.$board.addClass('disabled');\n        }\n\n        /**\n         * Handle an user move try.\n         * @param {Object} event - The event associated to a click\n         * in a board square (a move) made by the user.\n         */\n        handleMove(event) {\n            let move = Number(event.currentTarget.dataset.square);\n            this.board.makeMove.bind(this.board)(move, this.humanToken);\n            this.continueGame(this.humanToken, this.cpuPlayer);\n        }\n\n        /**\n         * Check if the game can continue or not and act according to that.\n         * If game can continue, run the next player turn.\n         * If not, announce the result, reset the game and show the modal.\n         * @param {String} player - The token of the actual player.\n         * @param {Function} playerFunction - The function to execute if the\n         * game should continue.\n         */\n        continueGame(player, playerFunction) {\n            if (this.isGameOver()) {\n                let winner = this.getWinner();\n                console.log((winner)? `Player ${winner} won.`:'It was a tie.');\n                window.setTimeout(this.reset.bind(this), 800);\n            } else {\n                playerFunction.bind(this)(this.rival[player]);\n            }\n        }\n\n        /**\n         * Reset a Tic Tac Toe Game.\n         */\n        reset() {\n            this.board = new Board();\n            this.turn = 0;\n            this.$modal.removeClass('hidden');\n        }\n\n        /**\n         * Get squares still available (empty) in the board.\n         * @returns {Number[]} List of empty squares in the board.\n         */\n        getValidMoves() {\n            let squares = this.board.squares;\n            let emptySquare = function(element, index) {\n                return squares[index] === EMPTY;\n            };\n            return [...squares.keys()].filter(emptySquare.bind(this));\n        }\n\n        /**\n         * Answer if the game has come to an end.\n         * @returns {Boolean} True or false if game has come to an end or not.\n         */\n        isGameOver() {\n            return this.getWinner() || !this.getValidMoves().length;\n        }\n\n        /**\n         * Convert a board positions array to a board tokens array.\n         * @param {Number[]} indexArr - The array of board positions.\n         */\n        toTokenArray(indexArr) {\n            return indexArr.map(element => this.board.squares[element]);\n        }\n\n        /**\n         * Check if a move is a fork move.\n         * @param {Number} forkCandidate - The position to check.\n         * @player {String} player - The player for whom the check is being done.\n         * @returns {Boolean} true if it's a fork move, false otherwise.\n         */\n        isForkMove(forkCandidate, player) {\n\n            let isForkLine = function (crossline) {\n                let tokens = this.toTokenArray(crossline);\n                return oneInARow(tokens, player);\n            };\n            let forkLines = this.board.crossLines[forkCandidate]\n                            .filter(isForkLine.bind(this));\n            return forkLines.length > 1;\n        }\n\n        /**\n         * Get the token of the winner player.\n         * @returns {?String} The token of the actual winner. null means a tie.\n         */\n        getWinner() {\n            for (let line of this.board.lines) {\n                let row = this.toTokenArray(line);\n                if (threeInARow(row)) {\n                    return row[0];\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Get the best move to do for CPU to never lose.\n         * @param {String} player - The CPU player token.\n         * @returns {Number} The best move to do for not lose.\n         */\n        bestMove(player) {\n            // if cpu has two in a row, win\n            for (let line of this.board.lines) {\n                let row = this.toTokenArray(line);\n                if (twoInARow(row, player)) {\n                    return line[row.indexOf(EMPTY)];\n                }\n            }\n            // if human has two in a row, block him\n            for (let line of this.board.lines) {\n                let row = this.toTokenArray(line);\n                if (twoInARow(row, this.humanToken)) {\n                    return line[row.indexOf(EMPTY)];\n                }\n            }\n            // if there's a chance to create a fork create it\n            let validMoves = this.getValidMoves();\n            for (let square of validMoves) {\n                if (this.isForkMove(square, player)) {\n                    return square;\n                }\n            }\n            // if there's a chance to the opponent to create a fork, block it\n            for (let square of validMoves) {\n                if (this.isForkMove(square, this.humanToken)) {\n                    return square;\n                }\n            }\n            // if center is free, taken it\n            if (validMoves.indexOf(this.board.center) !== -1) {\n                return this.board.center;\n            }\n            // if the opponent takes a corner, play the opposite corner\n            let corners = [...this.board.corners.entries()];\n            let oppositeCorners = corners\n                               .filter((key, value) =>\n                               (this.board.squares[key] === this.humanToken)\n                               && (this.board.squares[value] === EMPTY));\n            if (oppositeCorners.length) {\n                let value = this.board.corners.get(oppositeCorners[0][0]);\n                return value;\n            }\n            // if there's a empty corner, take it\n            for (let corner of this.board.corners.keys()) {\n                if (this.board.squares[corner] === EMPTY) {\n                    return corner;\n                }\n            }\n            // if there's an empty middle square, take it\n            for (let middle of this.board.middles) {\n                if (this.board.squares[middle] === EMPTY) {\n                    return middle;\n                }\n            }\n        }\n\n        /**\n         * Run cpu player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        cpuPlayer(player) {\n            console.time('cpu move');\n            this.disableBoard();\n            let move;\n            if (this.turn) {\n                move = this.bestMove(player);\n            } else {\n                move = Math.floor(Math.random() * this.getValidMoves().length);\n            }\n            this.board.makeMove.bind(this.board)(move, player);\n            console.timeEnd('cpu move');\n            this.continueGame(player, this.humanPlayer);\n        }\n\n        /**\n         * Run human player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        humanPlayer(player) {\n            this.turn++;\n            this.enableBoard();\n        }\n\n        /**\n         * Start the Tic Tac Toe game.\n         * An OptionsModal should be instantiated for this to work.\n         */\n        start() {\n            if (this.playerOne === 'human') {\n                this.humanPlayer(this.humanToken);\n            } else {\n                this.cpuPlayer(this.rival[this.humanToken]);\n            }\n        }\n    }\n\n    /** Class representing an options modal window for the game. */\n    class OptionsModal {\n        /**\n         * Create a modal for a Tic Tac Toe game.\n         * @param {Object} game - A TicTacToe instance.\n         */\n        constructor(game) {\n            this.game = game;\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the modal */\n        cacheDom() {\n            this.$tokens = $('.token');\n            this.$players = $('.player');\n            this.$start = $('#start-btn');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$tokens.on('click', this.handleTokenSelection.bind(this));\n            this.$players.on('click', this.handlePlayerSelection.bind(this));\n            this.$start.on('click', this.handleStart.bind(this));\n        }\n\n        /**\n         * Handle the token selection by the user.\n         * @param {Object} event - The event associated to a click\n         * in a token button made by the user, choosing their token.\n         */\n        handleTokenSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$tokens.toggleClass('unselected');\n                this.token = $this.attr('data-token');\n            }\n        }\n\n        /**\n         * Handle the selection of player one by the user.\n         * @param {Object} event - The event associated to a click\n         * in a player button made by the user, choosing which player\n         * will start the game.\n         */\n        handlePlayerSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$players.toggleClass('unselected');\n                this.playerOne = $this.attr('data-playerone');\n            }\n        }\n\n        /**\n         * Handle the click in the modal start button by the user.\n         * @param {Object} event - The event associated to a click\n         * in the start button made by the user, for starting the game.\n         */\n        handleStart(event) {\n            this.game.playerOne = this.playerOne || 'human';\n            this.game.humanToken = this.token || 'X';\n            this.$modal.addClass('hidden');\n            this.game.start();\n        }\n    }\n\n    /** Create and launch a Tic Tac Toe game. */\n    function newGame(){\n        let ttt = new TicTacToe();\n        let modal = new OptionsModal(ttt);\n    }\n\n    newGame();\n})();\n},{\"jbone\":1}]},{},[2])\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * jBone v1.1.2 - 2015-10-09 - Library for DOM manipulation\n *\n * http://jbone.js.org\n *\n * Copyright 2015 Alexey Kupriyanenko\n * Released under the MIT license.\n */\n\n(function (win) {\n\nvar\n// cache previous versions\n_$ = win.$,\n_jBone = win.jBone,\n\n// Quick match a standalone tag\nrquickSingleTag = /^<(\\w+)\\s*\\/?>$/,\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash\nrquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n\n// Alias for function\nslice = [].slice,\nsplice = [].splice,\nkeys = Object.keys,\n\n// Alias for global variables\ndoc = document,\n\nisString = function(el) {\n    return typeof el === \"string\";\n},\nisObject = function(el) {\n    return el instanceof Object;\n},\nisFunction = function(el) {\n    return ({}).toString.call(el) === \"[object Function]\";\n},\nisArray = function(el) {\n    return Array.isArray(el);\n},\njBone = function(element, data) {\n    return new fn.init(element, data);\n},\nfn;\n\n// set previous values and return the instance upon calling the no-conflict mode\njBone.noConflict = function() {\n    win.$ = _$;\n    win.jBone = _jBone;\n\n    return jBone;\n};\n\nfn = jBone.fn = jBone.prototype = {\n    init: function(element, data) {\n        var elements, tag, wraper, fragment;\n\n        if (!element) {\n            return this;\n        }\n        if (isString(element)) {\n            // Create single DOM element\n            if (tag = rquickSingleTag.exec(element)) {\n                this[0] = doc.createElement(tag[1]);\n                this.length = 1;\n\n                if (isObject(data)) {\n                    this.attr(data);\n                }\n\n                return this;\n            }\n            // Create DOM collection\n            if ((tag = rquickExpr.exec(element)) && tag[1]) {\n                fragment = doc.createDocumentFragment();\n                wraper = doc.createElement(\"div\");\n                wraper.innerHTML = element;\n                while (wraper.lastChild) {\n                    fragment.appendChild(wraper.firstChild);\n                }\n                elements = slice.call(fragment.childNodes);\n\n                return jBone.merge(this, elements);\n            }\n            // Find DOM elements with querySelectorAll\n            if (jBone.isElement(data)) {\n                return jBone(data).find(element);\n            }\n\n            try {\n                elements = doc.querySelectorAll(element);\n\n                return jBone.merge(this, elements);\n            } catch (e) {\n                return this;\n            }\n        }\n        // Wrap DOMElement\n        if (element.nodeType) {\n            this[0] = element;\n            this.length = 1;\n\n            return this;\n        }\n        // Run function\n        if (isFunction(element)) {\n            return element();\n        }\n        // Return jBone element as is\n        if (element instanceof jBone) {\n            return element;\n        }\n\n        // Return element wrapped by jBone\n        return jBone.makeArray(element, this);\n    },\n\n    pop: [].pop,\n    push: [].push,\n    reverse: [].reverse,\n    shift: [].shift,\n    sort: [].sort,\n    splice: [].splice,\n    slice: [].slice,\n    indexOf: [].indexOf,\n    forEach: [].forEach,\n    unshift: [].unshift,\n    concat: [].concat,\n    join: [].join,\n    every: [].every,\n    some: [].some,\n    filter: [].filter,\n    map: [].map,\n    reduce: [].reduce,\n    reduceRight: [].reduceRight,\n    length: 0\n};\n\nfn.constructor = jBone;\n\nfn.init.prototype = fn;\n\njBone.setId = function(el) {\n    var jid = el.jid;\n\n    if (el === win) {\n        jid = \"window\";\n    } else if (el.jid === undefined) {\n        el.jid = jid = ++jBone._cache.jid;\n    }\n\n    if (!jBone._cache.events[jid]) {\n        jBone._cache.events[jid] = {};\n    }\n};\n\njBone.getData = function(el) {\n    el = el instanceof jBone ? el[0] : el;\n\n    var jid = el === win ? \"window\" : el.jid;\n\n    return {\n        jid: jid,\n        events: jBone._cache.events[jid]\n    };\n};\n\njBone.isElement = function(el) {\n    return el && el instanceof jBone || el instanceof HTMLElement || isString(el);\n};\n\njBone._cache = {\n    events: {},\n    jid: 0\n};\n\nfunction isArraylike(obj) {\n    var length = obj.length,\n        type = typeof obj;\n\n    if (isFunction(type) || obj === win) {\n        return false;\n    }\n\n    if (obj.nodeType === 1 && length) {\n        return true;\n    }\n\n    return isArray(type) || length === 0 ||\n        typeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n\nfn.pushStack = function(elems) {\n    var ret = jBone.merge(this.constructor(), elems);\n\n    return ret;\n};\n\njBone.merge = function(first, second) {\n    var l = second.length,\n        i = first.length,\n        j = 0;\n\n    while (j < l) {\n        first[i++] = second[j++];\n    }\n\n    first.length = i;\n\n    return first;\n};\n\njBone.contains = function(container, contained) {\n    return container.contains(contained);\n};\n\njBone.extend = function(target) {\n    var tg;\n\n    splice.call(arguments, 1).forEach(function(source) {\n        tg = target; //caching target for perf improvement\n\n        if (source) {\n            for (var prop in source) {\n                tg[prop] = source[prop];\n            }\n        }\n    });\n\n    return target;\n};\n\njBone.makeArray = function(arr, results) {\n    var ret = results || [];\n\n    if (arr !== null) {\n        if (isArraylike(arr)) {\n            jBone.merge(ret, isString(arr) ? [arr] : arr);\n        } else {\n            ret.push(arr);\n        }\n    }\n\n    return ret;\n};\n\njBone.unique = function(array) {\n    if (array == null) {\n        return [];\n    }\n\n    var result = [];\n\n    for (var i = 0, length = array.length; i < length; i++) {\n        var value = array[i];\n        if (result.indexOf(value) < 0) {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nfunction BoneEvent(e, data) {\n    var key, setter;\n\n    this.originalEvent = e;\n\n    setter = function(key, e) {\n        if (key === \"preventDefault\") {\n            this[key] = function() {\n                this.defaultPrevented = true;\n                return e[key]();\n            };\n        } else if (key === \"stopImmediatePropagation\") {\n            this[key] = function() {\n                this.immediatePropagationStopped = true;\n                return e[key]();\n            };\n        } else if (isFunction(e[key])) {\n            this[key] = function() {\n                return e[key]();\n            };\n        } else {\n            this[key] = e[key];\n        }\n    };\n\n    for (key in e) {\n        if (e[key] || typeof e[key] === \"function\") {\n            setter.call(this, key, e);\n        }\n    }\n\n    jBone.extend(this, data, {\n        isImmediatePropagationStopped: function() {\n            return !!this.immediatePropagationStopped;\n        }\n    });\n}\n\njBone.Event = function(event, data) {\n    var namespace, eventType;\n\n    if (event.type && !data) {\n        data = event;\n        event = event.type;\n    }\n\n    namespace = event.split(\".\").splice(1).join(\".\");\n    eventType = event.split(\".\")[0];\n\n    event = doc.createEvent(\"Event\");\n    event.initEvent(eventType, true, true);\n\n    return jBone.extend(event, {\n        namespace: namespace,\n        isDefaultPrevented: function() {\n            return event.defaultPrevented;\n        }\n    }, data);\n};\n\njBone.event = {\n\n    /**\n     * Attach a handler to an event for the elements\n     * @param {Node}        el         - Events will be attached to this DOM Node\n     * @param {String}      types      - One or more space-separated event types and optional namespaces\n     * @param {Function}    handler    - A function to execute when the event is triggered\n     * @param {Object}      [data]     - Data to be passed to the handler in event.data\n     * @param {String}      [selector] - A selector string to filter the descendants of the selected elements\n     */\n    add: function(el, types, handler, data, selector) {\n        jBone.setId(el);\n\n        var eventHandler = function(e) {\n                jBone.event.dispatch.call(el, e);\n            },\n            events = jBone.getData(el).events,\n            eventType, t, event;\n\n        types = types.split(\" \");\n        t = types.length;\n        while (t--) {\n            event = types[t];\n\n            eventType = event.split(\".\")[0];\n            events[eventType] = events[eventType] || [];\n\n            if (events[eventType].length) {\n                // override with previous event handler\n                eventHandler = events[eventType][0].fn;\n            } else {\n                el.addEventListener && el.addEventListener(eventType, eventHandler, false);\n            }\n\n            events[eventType].push({\n                namespace: event.split(\".\").splice(1).join(\".\"),\n                fn: eventHandler,\n                selector: selector,\n                data: data,\n                originfn: handler\n            });\n        }\n    },\n\n    /**\n     * Remove an event handler\n     * @param  {Node}       el        - Events will be deattached from this DOM Node\n     * @param  {String}     types     - One or more space-separated event types and optional namespaces\n     * @param  {Function}   handler   - A handler function previously attached for the event(s)\n     */\n    remove: function(el, types, handler) {\n        var removeListener = function(events, eventType, index, el, e) {\n                var callback;\n\n                // get callback\n                if ((handler && e.originfn === handler) || !handler) {\n                    callback = e.fn;\n                }\n\n                if (events[eventType][index].fn === callback) {\n                    // remove handler from cache\n                    events[eventType].splice(index, 1);\n\n                    if (!events[eventType].length) {\n                        el.removeEventListener(eventType, callback);\n                    }\n                }\n            },\n            events = jBone.getData(el).events,\n            l,\n            eventsByType;\n\n        if (!events) {\n            return;\n        }\n\n        // remove all events\n        if (!types && events) {\n            return keys(events).forEach(function(eventType) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    removeListener(events, eventType, l, el, eventsByType[l]);\n                }\n            });\n        }\n\n        types.split(\" \").forEach(function(eventName) {\n            var eventType = eventName.split(\".\")[0],\n                namespace = eventName.split(\".\").splice(1).join(\".\"),\n                e;\n\n            // remove named events\n            if (events[eventType]) {\n                eventsByType = events[eventType];\n                l = eventsByType.length;\n\n                while(l--) {\n                    e = eventsByType[l];\n                    if (!namespace || (namespace && e.namespace === namespace)) {\n                        removeListener(events, eventType, l, el, e);\n                    }\n                }\n            }\n            // remove all namespaced events\n            else if (namespace) {\n                keys(events).forEach(function(eventType) {\n                    eventsByType = events[eventType];\n                    l = eventsByType.length;\n\n                    while(l--) {\n                        e = eventsByType[l];\n                        if (e.namespace.split(\".\")[0] === namespace.split(\".\")[0]) {\n                            removeListener(events, eventType, l, el, e);\n                        }\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Execute all handlers and behaviors attached to the matched elements for the given event type.\n     * @param  {Node}       el       - Events will be triggered for thie DOM Node\n     * @param  {String}     event    - One or more space-separated event types and optional namespaces\n     */\n    trigger: function(el, event) {\n        var events = [];\n\n        if (isString(event)) {\n            events = event.split(\" \").map(function(event) {\n                return jBone.Event(event);\n            });\n        } else {\n            event = event instanceof Event ? event : jBone.Event(event);\n            events = [event];\n        }\n\n        events.forEach(function(event) {\n            if (!event.type) {\n                return;\n            }\n\n            el.dispatchEvent && el.dispatchEvent(event);\n        });\n    },\n\n    dispatch: function(e) {\n        var i = 0,\n            j = 0,\n            el = this,\n            handlers = jBone.getData(el).events[e.type],\n            length = handlers.length,\n            handlerQueue = [],\n            targets = [],\n            l,\n            expectedTarget,\n            handler,\n            event,\n            eventOptions;\n\n        // cache all events handlers, fix issue with multiple handlers (issue #45)\n        for (; i < length; i++) {\n            handlerQueue.push(handlers[i]);\n        }\n\n        i = 0;\n        length = handlerQueue.length;\n\n        for (;\n            // if event exists\n            i < length &&\n            // if handler is not removed from stack\n            ~handlers.indexOf(handlerQueue[i]) &&\n            // if propagation is not stopped\n            !(event && event.isImmediatePropagationStopped());\n        i++) {\n            expectedTarget = null;\n            eventOptions = {};\n            handler = handlerQueue[i];\n            handler.data && (eventOptions.data = handler.data);\n\n            // event handler without selector\n            if (!handler.selector) {\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(el, event);\n                }\n            }\n            // event handler with selector\n            else if (\n                // if target and selected element the same\n                ~(targets = jBone(el).find(handler.selector)).indexOf(e.target) && (expectedTarget = e.target) ||\n                // if one of element matched with selector contains target\n                (el !== e.target && el.contains(e.target))\n            ) {\n                // get element matched with selector\n                if (!expectedTarget) {\n                    l = targets.length;\n                    j = 0;\n\n                    for (; j < l; j++) {\n                        if (targets[j] && targets[j].contains(e.target)) {\n                            expectedTarget = targets[j];\n                        }\n                    }\n                }\n\n                if (!expectedTarget) {\n                    continue;\n                }\n\n                eventOptions.currentTarget = expectedTarget;\n                event = new BoneEvent(e, eventOptions);\n\n                if (!(e.namespace && e.namespace !== handler.namespace)) {\n                    handler.originfn.call(expectedTarget, event);\n                }\n            }\n        }\n    }\n};\n\nfn.on = function(types, selector, data, fn) {\n    var length = this.length,\n        i = 0;\n\n    if (data == null && fn == null) {\n        // (types, fn)\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === \"string\") {\n            // (types, selector, fn)\n            fn = data;\n            data = undefined;\n        } else {\n            // (types, data, fn)\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n\n    if (!fn) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.add(this[i], types, fn, data, selector);\n    }\n\n    return this;\n};\n\nfn.one = function(event) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        oneArgs = slice.call(args, 1, args.length - 1),\n        callback = slice.call(args, -1)[0],\n        addListener;\n\n    addListener = function(el) {\n        var $el = jBone(el);\n\n        event.split(\" \").forEach(function(event) {\n            var fn = function(e) {\n                $el.off(event, fn);\n                callback.call(el, e);\n            };\n\n            $el.on.apply($el, [event].concat(oneArgs, fn));\n        });\n    };\n\n    for (; i < length; i++) {\n        addListener(this[i]);\n    }\n\n    return this;\n};\n\nfn.trigger = function(event) {\n    var i = 0,\n        length = this.length;\n\n    if (!event) {\n        return this;\n    }\n\n    for (; i < length; i++) {\n        jBone.event.trigger(this[i], event);\n    }\n\n    return this;\n};\n\nfn.off = function(types, handler) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        jBone.event.remove(this[i], types, handler);\n    }\n\n    return this;\n};\n\nfn.find = function(selector) {\n    var results = [],\n        i = 0,\n        length = this.length,\n        finder = function(el) {\n            if (isFunction(el.querySelectorAll)) {\n                [].forEach.call(el.querySelectorAll(selector), function(found) {\n                    results.push(found);\n                });\n            }\n        };\n\n    for (; i < length; i++) {\n        finder(this[i]);\n    }\n\n    return jBone(results);\n};\n\nfn.get = function(index) {\n    return index != null ?\n\n        // Return just one element from the set\n        (index < 0 ? this[index + this.length] : this[index]) :\n\n        // Return all the elements in a clean array\n        slice.call(this);\n};\n\nfn.eq = function(index) {\n    return jBone(this[index]);\n};\n\nfn.parent = function() {\n    var results = [],\n        parent,\n        i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        if (!~results.indexOf(parent = this[i].parentElement) && parent) {\n            results.push(parent);\n        }\n    }\n\n    return jBone(results);\n};\n\nfn.toArray = function() {\n    return slice.call(this);\n};\n\nfn.is = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.tagName.toLowerCase() === args[0];\n    });\n};\n\nfn.has = function() {\n    var args = arguments;\n\n    return this.some(function(el) {\n        return el.querySelectorAll(args[0]).length;\n    });\n};\n\nfn.add = function(selector, context) {\n    return this.pushStack(\n        jBone.unique(\n            jBone.merge(this.get(), jBone(selector, context))\n        )\n    );\n};\n\nfn.attr = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    if (isString(key) && args.length === 1) {\n        return this[0] && this[0].getAttribute(key);\n    }\n\n    if (args.length === 2) {\n        setter = function(el) {\n            el.setAttribute(key, value);\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.setAttribute(name, key[name]);\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeAttr = function(key) {\n    var i = 0,\n        length = this.length;\n\n    for (; i < length; i++) {\n        this[i].removeAttribute(key);\n    }\n\n    return this;\n};\n\nfn.val = function(value) {\n    var i = 0,\n        length = this.length;\n\n    if (arguments.length === 0) {\n        return this[0] && this[0].value;\n    }\n\n    for (; i < length; i++) {\n        this[i].value = value;\n    }\n\n    return this;\n};\n\nfn.css = function(key, value) {\n    var args = arguments,\n        i = 0,\n        length = this.length,\n        setter;\n\n    // Get attribute\n    if (isString(key) && args.length === 1) {\n        return this[0] && win.getComputedStyle(this[0])[key];\n    }\n\n    // Set attributes\n    if (args.length === 2) {\n        setter = function(el) {\n            el.style[key] = value;\n        };\n    } else if (isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                el.style[name] = key[name];\n            });\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.data = function(key, value) {\n    var args = arguments, data = {},\n        i = 0,\n        length = this.length,\n        setter,\n        setValue = function(el, key, value) {\n            if (isObject(value)) {\n                el.jdata = el.jdata || {};\n                el.jdata[key] = value;\n            } else {\n                el.dataset[key] = value;\n            }\n        },\n        getValue = function(value) {\n            if (value === \"true\") {\n                return true;\n            } else if (value === \"false\") {\n                return false;\n            } else {\n                return value;\n            }\n        };\n\n    // Get all data\n    if (args.length === 0) {\n        this[0].jdata && (data = this[0].jdata);\n\n        keys(this[0].dataset).forEach(function(key) {\n            data[key] = getValue(this[0].dataset[key]);\n        }, this);\n\n        return data;\n    }\n    // Get data by name\n    if (args.length === 1 && isString(key)) {\n        return this[0] && getValue(this[0].dataset[key] || this[0].jdata && this[0].jdata[key]);\n    }\n\n    // Set data\n    if (args.length === 1 && isObject(key)) {\n        setter = function(el) {\n            keys(key).forEach(function(name) {\n                setValue(el, name, key[name]);\n            });\n        };\n    } else if (args.length === 2) {\n        setter = function(el) {\n            setValue(el, key, value);\n        };\n    }\n\n    for (; i < length; i++) {\n        setter(this[i]);\n    }\n\n    return this;\n};\n\nfn.removeData = function(key) {\n    var i = 0,\n        length = this.length,\n        jdata, dataset;\n\n    for (; i < length; i++) {\n        jdata = this[i].jdata;\n        dataset = this[i].dataset;\n\n        if (key) {\n            jdata && jdata[key] && delete jdata[key];\n            delete dataset[key];\n        } else {\n            for (key in jdata) {\n                delete jdata[key];\n            }\n\n            for (key in dataset) {\n                delete dataset[key];\n            }\n        }\n    }\n\n    return this;\n};\n\nfn.addClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.add(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.removeClass = function(className) {\n    var i = 0,\n        j = 0,\n        length = this.length,\n        classes = className ? className.trim().split(/\\s+/) : [];\n\n    for (; i < length; i++) {\n        j = 0;\n\n        for (j = 0; j < classes.length; j++) {\n            this[i].classList.remove(classes[j]);\n        }\n    }\n\n    return this;\n};\n\nfn.toggleClass = function(className, force) {\n    var i = 0,\n        length = this.length,\n        method = \"toggle\";\n\n    force === true && (method = \"add\") || force === false && (method = \"remove\");\n\n    if (className) {\n        for (; i < length; i++) {\n            this[i].classList[method](className);\n        }\n    }\n\n    return this;\n};\n\nfn.hasClass = function(className) {\n    var i = 0, length = this.length;\n\n    if (className) {\n        for (; i < length; i++) {\n            if (this[i].classList.contains(className)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\nfn.html = function(value) {\n    var args = arguments,\n        el;\n\n    // add HTML into elements\n    if (args.length === 1 && value !== undefined) {\n        return this.empty().append(value);\n    }\n    // get HTML from element\n    else if (args.length === 0 && (el = this[0])) {\n        return el.innerHTML;\n    }\n\n    return this;\n};\n\nfn.append = function(appended) {\n    var i = 0,\n        length = this.length,\n        setter;\n\n    // create jBone object and then append\n    if (isString(appended) && rquickExpr.exec(appended)) {\n        appended = jBone(appended);\n    }\n    // create text node for insertion\n    else if (!isObject(appended)) {\n        appended = document.createTextNode(appended);\n    }\n\n    appended = appended instanceof jBone ? appended : jBone(appended);\n\n    setter = function(el, i) {\n        appended.forEach(function(node) {\n            if (i) {\n                el.appendChild(node.cloneNode(true));\n            } else {\n                el.appendChild(node);\n            }\n        });\n    };\n\n    for (; i < length; i++) {\n        setter(this[i], i);\n    }\n\n    return this;\n};\n\nfn.appendTo = function(to) {\n    jBone(to).append(this);\n\n    return this;\n};\n\nfn.empty = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        while (el.lastChild) {\n            el.removeChild(el.lastChild);\n        }\n    }\n\n    return this;\n};\n\nfn.remove = function() {\n    var i = 0,\n        length = this.length,\n        el;\n\n    // remove all listeners\n    this.off();\n\n    for (; i < length; i++) {\n        el = this[i];\n\n        // remove data and nodes\n        delete el.jdata;\n        el.parentNode && el.parentNode.removeChild(el);\n    }\n\n    return this;\n};\n\nif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\n    // Expose jBone as module.exports in loaders that implement the Node\n    // module pattern (including browserify). Do not create the global, since\n    // the user will be storing it themselves locally, and globals are frowned\n    // upon in the Node module world.\n    module.exports = jBone;\n}\n// Register as a AMD module\nelse if (typeof define === \"function\" && define.amd) {\n    define(function() {\n        return jBone;\n    });\n\n    win.jBone = win.$ = jBone;\n} else if (typeof win === \"object\" && typeof win.document === \"object\") {\n    win.jBone = win.$ = jBone;\n}\n\n}(window));\n","(function(){\n    /** Library imports for Browserify */\n    let $ = require('jbone');\n\n    /** @constant {String} EMPTY - Represent an EMPTY square in the board */\n    const EMPTY = '*';\n    /** @constant {String} X - The X token for the board*/\n    const X = 'X';\n    /** @constant {String} O - The O token for the board */\n    const O = 'O';\n    /**\n     * @constant {Number} TOP - The maximum value to be used by the search\n     * tree algorithm.\n     */\n    const TOP = 100;\n\n    /**\n     * Answer if the row isn't empty and all their elements are equal.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @returns {Boolean} True if all line elements are equal and not the\n     * empty token, false otherwise.\n     */\n    function threeInARow(row) {\n        let repeats = new Set(row);\n        return (repeats.size === 1) && (!repeats.has(EMPTY));\n    }\n\n    /**\n     * Answer if the given player has two tokens in the row, so a direct\n     * win situation.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @param {String} player - The token of the player to check.\n     * @returns {Boolean} True if there is two player tokens and any rival\n     * tokens, false otherwise.\n     */\n    function twoInARow(row, player) {\n        let uniques = new Set(row);\n        if ((uniques.size === 3) || !uniques.has(EMPTY)) {\n            return false;\n        }\n        let playerTokens = row.filter(element => element === player);\n        return playerTokens.length === 2;\n    }\n\n    /**\n     * Answer if the given player has placed the only token placed in the\n     * current row.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @param {String} player - The token of the player to check.\n     * @returns {Boolean} True if there is one player token and any rival\n     * tokens, false otherwise.\n     */\n    function oneInARow(row, player) {\n        return (twoInARow(row, EMPTY) && (row.indexOf(player) !== -1));\n    }\n\n    /** Class representing a board. */\n    class Board {\n        /** Create a board. */\n        constructor() {\n            this.squares = Array(9).fill(EMPTY);\n            this.lines= [[0,1,2], [3,4,5], [6,7,8], // horizontal\n                         [0,3,6], [1,4,7], [2,5,8], // vertical\n                         [0,4,8],[2,4,6]];          // diagonal\n            this.crossLines = {\n                0: [[0, 1, 2], [0, 3, 6], [0, 4, 8]],\n                1: [[0, 1, 2], [1, 4, 7]],\n                2: [[0, 1, 2], [2, 5, 8]],\n                3: [[3, 4, 5], [0, 3, 6]],\n                4: [[3, 4, 5], [1, 4, 5], [0, 4, 8]],\n                5: [[3, 4, 5], [2, 5, 8]],\n                6: [[6, 7, 8], [0, 3, 6], [2, 4, 6]],\n                7: [[6, 7, 8], [1, 4, 7]],\n                8: [[6, 7, 8], [2, 5, 8], [0, 4, 8]]\n            };\n            this.center = 4;\n            this.corners = new Map([[0, 8], [2, 6], [6, 2], [8, 0]]);\n            this.middles = [1, 7, 3, 5];\n\n            this.getReady();\n        }\n\n        /** Clear and prepare the board for a new game */\n        getReady() {\n            for (let i = 0; i < 9; i++) {\n                this[`$square${i}`] = $(`#square${i}`);\n                this[`$square${i}`].html('').removeAttr('disabled');\n            }\n        }\n\n        /**\n         * Place the token of a player in the board.\n         * @param {Number} move - The position where the token will be placed.\n         * @param {String} player - The token of the player.\n         */\n        makeMove(move, player) {\n            this.squares[move] = player;\n            let tokenAlt = (player === 'X')? 'Cross': 'Circle';\n            let token = `<img class=\"token-img\" src=\"assets/images/${player}.svg\" alt=\"${tokenAlt}\">`;\n            this[`$square${move}`].html(token).attr('disabled', '');\n        }\n    }\n\n    /** Class representing a Tic Tac Toe game */\n    class TicTacToe {\n        /**\n         * Create a Tic Tac Toe game.\n         * @property {Board} board - The board where the game is played.\n         * @property {Object.<String, String>} - Pairs each token with their\n         * opposite, for easy switching between player tokens.\n         * @property {Number} turn - The actual turn of the game.\n         * @property {Array[]} lines - Array of winning lines in a Tic Tac Toe\n         * game.\n         */\n        constructor() {\n            this.board = new Board();\n            this.rival = {'O': 'X', 'X': 'O'};\n            this.turn = 0;\n\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the board */\n        cacheDom() {\n            this.$board = $('#board');\n            this.$square = $('.square');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$square.on('click', this.handleMove.bind(this));\n        }\n\n        /** Enable the board, making it clickable. */\n        enableBoard() {\n            this.$board.removeClass('disabled');\n        }\n\n        /** Disable the board, making it unclickable. */\n        disableBoard() {\n            this.$board.addClass('disabled');\n        }\n\n        /**\n         * Handle an user move try.\n         * @param {Object} event - The event associated to a click\n         * in a board square (a move) made by the user.\n         */\n        handleMove(event) {\n            let move = Number(event.currentTarget.dataset.square);\n            this.board.makeMove.bind(this.board)(move, this.humanToken);\n            this.continueGame(this.humanToken, this.cpuPlayer);\n        }\n\n        /**\n         * Check if the game can continue or not and act according to that.\n         * If game can continue, run the next player turn.\n         * If not, announce the result, reset the game and show the modal.\n         * @param {String} player - The token of the actual player.\n         * @param {Function} playerFunction - The function to execute if the\n         * game should continue.\n         */\n        continueGame(player, playerFunction) {\n            if (this.isGameOver()) {\n                let winner = this.getWinner();\n                console.log((winner)? `Player ${winner} won.`:'It was a tie.');\n                window.setTimeout(this.reset.bind(this), 800);\n            } else {\n                playerFunction.bind(this)(this.rival[player]);\n            }\n        }\n\n        /**\n         * Reset a Tic Tac Toe Game.\n         */\n        reset() {\n            this.board = new Board();\n            this.turn = 0;\n            this.$modal.removeClass('hidden');\n        }\n\n        /**\n         * Get squares still available (empty) in the board.\n         * @returns {Number[]} List of empty squares in the board.\n         */\n        getValidMoves() {\n            let squares = this.board.squares;\n            let emptySquare = function(element, index) {\n                return squares[index] === EMPTY;\n            };\n            return [...squares.keys()].filter(emptySquare.bind(this));\n        }\n\n        /**\n         * Answer if the game has come to an end.\n         * @returns {Boolean} True or false if game has come to an end or not.\n         */\n        isGameOver() {\n            return this.getWinner() || !this.getValidMoves().length;\n        }\n\n        /**\n         * Convert a board positions array to a board tokens array.\n         * @param {Number[]} indexArr - The array of board positions.\n         */\n        toTokenArray(indexArr) {\n            return indexArr.map(element => this.board.squares[element]);\n        }\n\n        /**\n         * Check if a move is a fork move.\n         * @param {Number} forkCandidate - The position to check.\n         * @player {String} player - The player for whom the check is being done.\n         * @returns {Boolean} true if it's a fork move, false otherwise.\n         */\n        isForkMove(forkCandidate, player) {\n\n            let isForkLine = function (crossline) {\n                let tokens = this.toTokenArray(crossline);\n                return oneInARow(tokens, player);\n            };\n            let forkLines = this.board.crossLines[forkCandidate]\n                            .filter(isForkLine.bind(this));\n            return forkLines.length > 1;\n        }\n\n        /**\n         * Get the token of the winner player.\n         * @returns {?String} The token of the actual winner. null means a tie.\n         */\n        getWinner() {\n            for (let line of this.board.lines) {\n                let row = this.toTokenArray(line);\n                if (threeInARow(row)) {\n                    return row[0];\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Get the best move to do for CPU to never lose.\n         * @param {String} player - The CPU player token.\n         * @returns {Number} The best move to do for not lose.\n         */\n        bestMove(player) {\n            // if cpu has two in a row, win\n            for (let line of this.board.lines) {\n                let row = this.toTokenArray(line);\n                if (twoInARow(row, player)) {\n                    return line[row.indexOf(EMPTY)];\n                }\n            }\n            // if human has two in a row, block him\n            for (let line of this.board.lines) {\n                let row = this.toTokenArray(line);\n                if (twoInARow(row, this.humanToken)) {\n                    return line[row.indexOf(EMPTY)];\n                }\n            }\n            // if there's a chance to create a fork create it\n            let validMoves = this.getValidMoves();\n            for (let square of validMoves) {\n                if (this.isForkMove(square, player)) {\n                    return square;\n                }\n            }\n            // if there's a chance to the opponent to create a fork, block it\n            for (let square of validMoves) {\n                if (this.isForkMove(square, this.humanToken)) {\n                    return square;\n                }\n            }\n            // if center is free, taken it\n            if (validMoves.indexOf(this.board.center) !== -1) {\n                return this.board.center;\n            }\n            // if the opponent takes a corner, play the opposite corner\n            let corners = [...this.board.corners.entries()];\n            let oppositeCorners = corners\n                               .filter((key, value) =>\n                               (this.board.squares[key] === this.humanToken)\n                               && (this.board.squares[value] === EMPTY));\n            if (oppositeCorners.length) {\n                let value = this.board.corners.get(oppositeCorners[0][0]);\n                return value;\n            }\n            // if there's a empty corner, take it\n            for (let corner of this.board.corners.keys()) {\n                if (this.board.squares[corner] === EMPTY) {\n                    return corner;\n                }\n            }\n            // if there's an empty middle square, take it\n            for (let middle of this.board.middles) {\n                if (this.board.squares[middle] === EMPTY) {\n                    return middle;\n                }\n            }\n        }\n\n        /**\n         * Run cpu player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        cpuPlayer(player) {\n            console.time('cpu move');\n            this.disableBoard();\n            let move;\n            if (this.turn) {\n                move = this.bestMove(player);\n            } else {\n                move = Math.floor(Math.random() * this.getValidMoves().length);\n            }\n            this.board.makeMove.bind(this.board)(move, player);\n            console.timeEnd('cpu move');\n            this.continueGame(player, this.humanPlayer);\n        }\n\n        /**\n         * Run human player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        humanPlayer(player) {\n            this.turn++;\n            this.enableBoard();\n        }\n\n        /**\n         * Start the Tic Tac Toe game.\n         * An OptionsModal should be instantiated for this to work.\n         */\n        start() {\n            if (this.playerOne === 'human') {\n                this.humanPlayer(this.humanToken);\n            } else {\n                this.cpuPlayer(this.rival[this.humanToken]);\n            }\n        }\n    }\n\n    /** Class representing an options modal window for the game. */\n    class OptionsModal {\n        /**\n         * Create a modal for a Tic Tac Toe game.\n         * @param {Object} game - A TicTacToe instance.\n         */\n        constructor(game) {\n            this.game = game;\n            this.cacheDom();\n            this.bindEvents();\n        }\n\n        /** Cache the DOM elements of the modal */\n        cacheDom() {\n            this.$tokens = $('.token');\n            this.$players = $('.player');\n            this.$start = $('#start-btn');\n            this.$modal = $('.modal');\n        }\n\n        /** Bind events to DOM elements */\n        bindEvents() {\n            this.$tokens.on('click', this.handleTokenSelection.bind(this));\n            this.$players.on('click', this.handlePlayerSelection.bind(this));\n            this.$start.on('click', this.handleStart.bind(this));\n        }\n\n        /**\n         * Handle the token selection by the user.\n         * @param {Object} event - The event associated to a click\n         * in a token button made by the user, choosing their token.\n         */\n        handleTokenSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$tokens.toggleClass('unselected');\n                this.token = $this.attr('data-token');\n            }\n        }\n\n        /**\n         * Handle the selection of player one by the user.\n         * @param {Object} event - The event associated to a click\n         * in a player button made by the user, choosing which player\n         * will start the game.\n         */\n        handlePlayerSelection(event) {\n            let $this = $(event.currentTarget);\n            if ($this.hasClass('unselected')) {\n                this.$players.toggleClass('unselected');\n                this.playerOne = $this.attr('data-playerone');\n            }\n        }\n\n        /**\n         * Handle the click in the modal start button by the user.\n         * @param {Object} event - The event associated to a click\n         * in the start button made by the user, for starting the game.\n         */\n        handleStart(event) {\n            this.game.playerOne = this.playerOne || 'human';\n            this.game.humanToken = this.token || 'X';\n            this.$modal.addClass('hidden');\n            this.game.start();\n        }\n    }\n\n    /** Create and launch a Tic Tac Toe game. */\n    function newGame(){\n        let ttt = new TicTacToe();\n        let modal = new OptionsModal(ttt);\n    }\n\n    newGame();\n})();"],"sourceRoot":"/source/"}