{"version":3,"sources":["app.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","err","Object","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","protoProps","staticProps","prototype","threeInARow","row","token","EMPTY","every","element","game","ttt","TicTacToe","start","TOP","Board","this","squares","fill","board","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","entries","_step$value","index","console","log","move","player","makeMove","rival","O","X","turn","lines","constructor","emptySquare","concat","keys","filter","bind","getWinner","getValidMoves","_this","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","line","map","depth","winner","playerFunction","isGameOver","draw","reset","bestMove","currentMax","max","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","minValue","α","β","evalFinalState","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_move","Math","undoMove","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_move2","min","maxValue","time","minimax","floor","random","timeEnd","continueGame","humanPlayer","askMove","validMoves","Number","prompt","indexOf","cpuPlayer","playerOne","arguments"],"mappings":"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","file":"app.js","sourcesContent":["(function(){\n    /** @constant {String} EMPTY - Represent an EMPTY square in the board */\n    const EMPTY = '*';\n    /** @constant {String} X - The X token for the board*/\n    const X = 'X';\n    /** @constant {String} O - The O token for the board */\n    const O = 'O';\n    /**\n     * @constant {Number} TOP - The maximum value to be used by the search\n     * tree algorithm.\n     */\n    const TOP = 100;\n\n    /**\n     * Answer if the row isn't empty and all their elements are equal.\n     * @param {String[]} row - Array of tokens of one winning line.\n     * @returns {Boolean} True if all line elements are equal and not the\n     * empty token, false otherwise.\n     */\n    function threeInARow(row) { // return true if all row elements are equal\n        let token = row[0];\n        if (token !== EMPTY) {\n            return row.every(element => element === token);\n        }\n    }\n\n    /** Class representing a board. */\n    class Board {\n        /** Create a board. */\n        constructor() {\n            this.squares = Array(9).fill(EMPTY);\n        }\n\n        /** Draw the game board. */\n        draw() {\n            let board = '';\n            for (let [index, value] of this.squares.entries()) {\n                board += (index % 3)? value: `\\n${value}`;\n            }\n            console.log(board);\n        }\n\n        /**\n         * Place the token of a player in the board.\n         * @param {Number} move - The position where the token will be placed.\n         * @param {String} player - The token of the player.\n         */\n        makeMove(move, player) {\n            this.squares[move] = player;\n        }\n\n        /**\n         * Remove the player token in the given position of the board.\n         * @param {Number} move - The position of the token to be erased.\n         */\n        undoMove(move) {\n            this.makeMove(move, EMPTY);\n        }\n    }\n\n    /** Class representing a Tic Tac Toe game */\n    class TicTacToe {\n        /**\n         * Create a Tic Tac Toe game.\n         * @property {Board} board - The board where the game is played.\n         * @property {Object.<String, String>} - Pairs each token with their\n         * opposite, for easy switching between player tokens.\n         * @property {Number} turn - The actual turn of the game.\n         * @property {Array[]} lines - Array of winning lines in a Tic Tac Toe\n         * game.\n         */\n        constructor() {\n            this.board = new Board();\n            this.rival = {'O': 'X', 'X': 'O'};\n            this.turn = 0;\n            this.lines= [[0,1,2], [3,4,5], [6,7,8], // vertical\n                        [0,3,6], [1,4,7], [2,5,8], // horizontal\n                        [0,4,8],[2,4,6]];          // diagonal\n        }\n\n        /**\n         * Reset a Tic Tac Toe Game.\n         */\n        reset() {\n            this.constructor();\n        }\n\n        /**\n         * Get squares still available (empty) in the board.\n         * @returns {Number[]} List of empty squares in the board.\n         */\n        getValidMoves() {\n            let squares = this.board.squares;\n            let emptySquare = function(element, index) {\n                return squares[index] === EMPTY;\n            };\n            return [...squares.keys()].filter(emptySquare.bind(this));\n        }\n\n        /**\n         * Answer if the game has come to an end.\n         * @returns {Boolean} True or false if game has come to an end or not.\n         */\n        isGameOver() {\n            return this.getWinner() || !this.getValidMoves().length;\n        }\n\n        /**\n         * Get the token of the winner player.\n         * @returns {?String} The token of the actual winner. null means a tie.\n         */\n        getWinner() {\n            for (let line of this.lines) {\n                let row = line.map(element => this.board.squares[element]);\n                if (threeInARow(row)) {\n                    return row[0];\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Evaluate (score) the state of the player at the end of a game.\n         * The possible states are: «Win» (a positive number),\n         * «Lose» (a negative) or «Tie» (zero).\n         * Take the number of moves done (depth) into account. Not taking that\n         * into account leads to a CPU playing awfully: a win in 4 moves is\n         * more valuable that one achieved in 6.\n         * @param {String} player - The token of the player which state is\n         * being evaluated.\n         * @param {Number} depth - The number of moves done to reach the actual\n         * state of the game.\n         *\n         * @returns {Number} The score of the actual state from the player\n         * perspective.\n         */\n        evalFinalState(player, depth) {\n            let winner = this.getWinner();\n            if (winner === player) {\n                return TOP - depth;\n            } else if (winner === this.rival[player]) {\n                return -TOP + depth;\n            }\n            return 0;\n        }\n\n        /**\n         * Check if the game can continue or not and act according to that.\n         * If game can continue, run the next player turn.\n         * If not, draw the final status of the game and init a new one.\n         * @param {String} player - The token of the actual player.\n         * @param {Function} playerFunction - The function to execute if the\n         * game should continue.\n         */\n        continueGame(player, playerFunction) {\n            if (this.isGameOver()) {\n                this.board.draw();\n                let winner = this.getWinner();\n                console.log((winner)? `Player ${winner} won.`:'It was a tie.');\n                this.reset();\n                this.start();\n            } else {\n                playerFunction.bind(this)(this.rival[player]);\n            }\n        }\n\n        /**\n         * Implement search of the best move to execute next in the game.\n         * Use MiniMax algorithm enhanced with alpha-beta pruning.\n         * @returns {Number} bestMove - Best move to do next to play perfectly.\n         */\n        minimax(player, depth) {\n            let bestMove,\n                currentMax,\n                max = -TOP;\n            for (let move of this.getValidMoves()) {\n                currentMax = this.minValue(move, depth, this.rival[player],\n                                           -TOP, TOP);\n                if (currentMax > max) {\n                    max = currentMax;\n                    bestMove = move;\n                }\n            }\n            return bestMove;\n        }\n\n        /**\n         * Evaluate the given position and get the best result the player could\n         * achieve from that.\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Best situation the player could achieve from the\n         * given position.\n         */\n        maxValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    α = Math.max(α,\n                                 this.minValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return β;\n                    }\n                }\n                return α;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Evaluate the given position and get the worst result for the player\n         * opponent (the best for the player).\n         * @param {Number} move - The token position being evaluated.\n         * @param {Number} depth - The number of moves done to reach the\n         * actual state of the game.\n         * @param {String} player - The token of the player movement being\n         * evaluated.\n         * @param {Number} α - Best result possible till the moment for the\n         * player.\n         * @param {Number} β - Best result possible till the moment for the\n         * opponent.\n         * @returns {Number} Worst situation the opponent player could achieve\n         * from the given position.\n         */\n        minValue(move, depth, player, α, β) {\n            try {\n                this.board.makeMove(move, player);\n                if (this.isGameOver()) {\n                    return this.evalFinalState(player, depth);\n                }\n                for (let move of this.getValidMoves()) {\n                    β = Math.min(β,\n                                 this.maxValue(move, depth + 1,\n                                               this.rival[player], α, β));\n                    if (α >= β) {\n                        return α;\n                    }\n                }\n                return β;\n            }\n            finally {\n                this.board.undoMove(move);\n            }\n        }\n\n        /**\n         * Run cpu player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        cpuPlayer(player) {\n            console.time('cpu move');\n            this.board.draw();\n            let move;\n            if (this.turn) {\n                move = this.minimax(player, this.turn);\n            } else {\n                move = Math.floor(Math.random() * this.getValidMoves().length);\n            }\n            console.log(`Cpu moves ${move}`);\n            console.timeEnd('cpu move');\n            this.board.makeMove(move, player);\n\n            this.continueGame(player, this.humanPlayer);\n        }\n\n        /**\n         * Run human player turn.\n         * @param {String} player - Token for the actual player.\n         */\n        humanPlayer(player) {\n            this.turn++;\n            console.log(`Turn ${this.turn}`);\n            this.board.draw();\n            let validMoves = this.getValidMoves();\n\n            function askMove() { // print moves available\n                console.log(`Moves available: ${validMoves}`);\n                // ask player for their next move\n                let move = Number(prompt('Give me your move: '));\n\n                if (validMoves.indexOf(move) !== -1) {\n                    return move;\n                }\n                console.log(`${move} isn't a valid move. Try again.`);\n                return askMove();\n            }\n\n            let move = askMove();\n            this.board.makeMove(move, player);\n            this.continueGame(player, this.cpuPlayer);\n        }\n\n        /**\n         * Start the Tic Tac Toe game.\n         * @param {String} [playerOne='cpu'] - Player one (starts the game).\n         * @param {String} [token='X'] - Token of the player one.\n         */\n        start(playerOne='cpu', token='X') {\n            if (playerOne === 'cpu') {\n                this.cpuPlayer(token);\n            } else {\n                this.humanPlayer(token);\n            }\n        }\n    }\n\n    /**\n     * Create and launch a Tic Tac Toe game.\n     */\n    function game(){\n        let ttt = new TicTacToe();\n        ttt.start();\n    }\n\n    game();\n})();"],"sourceRoot":"/source/"}